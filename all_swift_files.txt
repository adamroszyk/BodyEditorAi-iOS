2025-05-27 09:54:38
//
//  LoadingMessages.swift
//  HairStyle
//
//  Created by adam on 30/04/2025.
//


//  LoadingMessages.swift
//  PicUp
//  Generated 30‚Äë04‚Äë2025 ‚Äì A sprinkle of Gen‚ÄëZ flavoured loading banter ‚ú®
//
//  Call `LoadingMessages.random()` whenever you need a fresh status line.
//  Example:
//      Text(LoadingMessages.random())
//
//  The list can be expanded or localized later.

import Foundation

enum LoadingMessages {
    static let all: [String] = [
       /* "Casting ‚ú® filters‚Ä¶ hold my boba!",
        "Crunching pixels like kettle chips‚Ä¶",
        "Tweaking the vibe parameters (scientifically, of course)‚Ä¶",
        "GPU is doing burpees‚Äîalmost done!",
        "Uploading imagination to the cloud ‚òÅÔ∏è‚Ä¶",
        "Painting happy little bytes‚Ä¶",
        "Assembling AI drip, please stand by‚Ä¶",
        "Turning coffee into gradients‚Ä¶",
        "Charging the creativity capacitor ‚ö°Ô∏è‚Ä¶",
        "Optimizing the funniness algorithm‚Ä¶",
        "Feeding hamsters more voltage‚Ä¶",
        "Rendering in ‚ú® Ultra‚ÄëMega‚Äë1080p ‚ú®‚Ä¶",
        "Spinning up rainbow shaders‚Ä¶",
        "Injecting extra serotonin into pixels‚Ä¶",
        "Reticulating splines 2.0‚Ä¶",
        "Aligning photonic chakras‚Ä¶",
        "Manifesting your best self‚Ä¶",
        "Negotiating with the color wheel‚Ä¶",
        "Loading swag assets (almost there)‚Ä¶",
        "Finalizing epicness‚Äîdo not unplug!",*/
        "Personalizing look‚Ä¶ ‚ú®",
        "Matching shades‚Ä¶ üíÑ",
        "Crafting routine‚Ä¶ üìù",
        "Virtual try‚Äëon‚Ä¶ ü§≥",
        "Beauty tips‚Ä¶ üí°",
        "Natural glow‚Ä¶ üåü",
        "Perfect combos‚Ä¶ üîÑ",
        "Loading palette‚Ä¶ üé®",
        "Next‚Äëlevel glam‚Ä¶ üöÄ",
        "Highlighting you‚Ä¶ ‚ú®",
        "Color match‚Ä¶ üéØ",
        "Beauty roadmap‚Ä¶ üó∫Ô∏è",
        "Refining look‚Ä¶ üîß",
        "Pro tutorials‚Ä¶ üé•",
        "Mood tune‚Ä¶ üé≠",
        "Step‚Äëby‚Äëstep‚Ä¶ üìö",
        "Dream vibe‚Ä¶ ‚ú®",
        "Beauty upgrade‚Ä¶ üîí",
        "Unlock VIP‚Ä¶ üîì",
        "Premium awaits‚Ä¶ üíé",
        "Subscribe now‚Ä¶ üè∑Ô∏è",
        "Pro tools‚Ä¶ üõ†Ô∏è",
        "Go PREMIUM! üö®",
        "Glam boost‚Ä¶ üåà",
        "Beauty perks‚Ä¶ ‚ö°Ô∏è",
        "Luxe filters‚Ä¶ üíº",
        "Almost ready‚Ä¶ ü•Ç",
        "Get VIP access‚Ä¶ üåü"
    ]

    /// Returns a random playful loading string.
    static func random() -> String {
        all.randomElement() ?? "Generating‚Ä¶ hang tight!"
    }
}
import SwiftUI

/// Grid picker that shows the bundled persona shots.
struct AvatarPickerView: View {
    let avatars: [UIImage]
    let onSelect: (UIImage) -> Void
    let onCancel: () -> Void

    private let columns = [GridItem(.adaptive(minimum: 100), spacing: 20)]

    var body: some View {
        NavigationView {
            ScrollView {
                LazyVGrid(columns: columns, spacing: 20) {
                    ForEach(avatars.indices, id: \.self) { idx in
                        Image(uiImage: avatars[idx])
                            .resizable()
                            .scaledToFill()
                            .frame(width: 100, height: 100)
                            .clipped()
                            .cornerRadius(12)
                            .onTapGesture { onSelect(avatars[idx]) }
                    }
                }
                .padding()
            }
            .navigationTitle("Select AI Avatar")
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Cancel", action: onCancel)
                }
            }
        }
    }
}
import SwiftUI

// MARK: ‚Äì Photo / slider view
// MARK: ‚Äì Photo / slider / empty‚Äëstate wrapper
struct PhotoWithRefreshOverlay: View {
    // Inputs
    let originalImage: UIImage?
    let editedImage: UIImage?
    let depthMapImage: UIImage?
    let isGenerating: Bool

    @Binding var sliderPosition: CGFloat
    @Binding var showSlider: Bool

    let onReplaceTap: () -> Void
    let onAddTap: () -> Void
    let onAvatarTap: () -> Void     // NEW
    let onSaveTap: () -> Void

    var body: some View {
        ZStack { contentView }
    }

    @ViewBuilder
    private var contentView: some View {
        if let orig = originalImage, let edit = editedImage {
            Image(uiImage: edit).resizable().scaledToFit()
        } else if let edit = editedImage {
            Image(uiImage: edit).resizable().scaledToFit()
        } else {
            EmptyStateView(
                onAddTap: onAddTap,
                onAvatarTap: onAvatarTap,
                isGenerating: isGenerating
            )
        }
    }
}

// MARK: ‚Äì Empty state with two shiny buttons
struct EmptyStateView: View {
    let onAddTap: () -> Void
    let onAvatarTap: () -> Void
    let isGenerating: Bool

    @State private var shineAdd = false
    @State private var shineAvatar = false

    var body: some View {
        VStack {
            Spacer()
            if isGenerating {
                Text(LoadingMessages.random())
                    .font(.headline)
                    .multilineTextAlignment(.center)
                    .foregroundColor(.white)
                    .padding()
            } else {
                HStack(spacing: 20) {
                    shimmerButton(
                        systemIcon: "photo.fill.on.rectangle.fill",
                        label: "Add Photo",
                        action: onAddTap,
                        shine: $shineAdd
                    )
                    shimmerButton(
                        systemIcon: "person.crop.rectangle",
                        label: "Select AI Avatar",
                        action: onAvatarTap,
                        shine: $shineAvatar
                    )
                }
            }
            Spacer()
        }
    }

    // Shared shimmering‚Äëbutton builder
    private func shimmerButton(systemIcon: String,
                               label: String,
                               action: @escaping () -> Void,
                               shine: Binding<Bool>) -> some View {
        Button(action: {
            shine.wrappedValue = false
            action()
        }) {
            VStack(spacing: 12) {
                Image(systemName: systemIcon)
                    .font(.system(size: 40))
                Text(label).font(.headline)
            }
            .foregroundColor(.black)
            .padding()
            .frame(width: 150)
            .background(Color.white)
            .cornerRadius(12)
            .shadow(radius: 10)
            .overlay(
                Rectangle()
                    .fill(
                        LinearGradient(
                            gradient: Gradient(colors: [
                                Color.white.opacity(0.1),
                                Color.white.opacity(0.4),
                                Color.white.opacity(0.1)
                            ]),
                            startPoint: .leading,
                            endPoint: .trailing
                        )
                    )
                    .rotationEffect(.degrees(30))
                    .offset(x: shine.wrappedValue ? 200 : -200)
                    .mask(RoundedRectangle(cornerRadius: 12))
            )
        }
        .onAppear {
            withAnimation(.linear(duration: 1.5).repeatForever(autoreverses: false)) {
                shine.wrappedValue = true
            }
        }
    }
}

// MARK: ‚Äì Stub generation worker
 enum ImageEditingWorker {
    static func generate(input: UIImage, prompt: String) async -> UIImage? {
        let vm = ImageEditingViewModel()
        do {
            try await vm.loadModel()
            vm.editedImage = input
            vm.prompt = prompt
            await MainActor.run { vm.editImage() }
            while await MainActor.run(body: { vm.isLoading }) {
                if #available(iOS 16.0, *) {
                    try? await Task.sleep(for: .milliseconds(100))
                } else {
                    // Fallback on earlier versions
                }
            }
            return await MainActor.run(body: { vm.editedImage })
        } catch {
            print("Generation failed: \(error)")
            return nil
        }
    }
}
import SwiftUI

struct BeforeAfterPage: View {
    let transformation: Transformation
    let onContinue: () -> Void

    @State private var showAfter     = false
    @State private var hasInteracted = false

    var body: some View {
        ZStack {
            // 1) blurred fill-to-screen bg
            GeometryReader { proxy in
                Image(showAfter
                        ? transformation.afterImageName
                        : transformation.beforeImageName)
                    .resizable()
                    .scaledToFill()
                    .frame(width: proxy.size.width,
                           height: proxy.size.height)
                    .clipped()
                    .blur(radius: 30)
            }

            // 2) crisp before/after image on top
            Image(showAfter
                    ? transformation.afterImageName
                    : transformation.beforeImageName)
                .resizable()
                .scaledToFit()
                .frame(maxWidth: .infinity,
                       maxHeight: .infinity)

            // 3) caption + controls
            VStack {
                Spacer()

                Text(transformation.caption)
                    .font(.system(size: 22, weight: .bold, design: .rounded))
                    .shadow(radius: 5)
                    .multilineTextAlignment(.center)
                    .padding(.horizontal)
                    .padding(.bottom, 12)

                VStack(spacing: 16) {
                    WideSegmentedToggle(isAfter: $showAfter)
                        .onChange(of: showAfter) { _ in
                            if !hasInteracted { hasInteracted = true }
                        }

                    Button(action: onContinue) {
                        Text("Continue")
                            .font(.headline)
                            .frame(maxWidth: .infinity)
                            .frame(height: 48)
                    }
                    .buttonStyle(.plain)
                    .background(.ultraThinMaterial)
                    .cornerRadius(24)
                    .shadow(color: .black.opacity(0.25),
                            radius: 8, x: 0, y: 4)
                    .opacity(hasInteracted ? 1 : 0.3)
                    .disabled(!hasInteracted)
                }
                .padding(20)
                .background(.ultraThinMaterial)
                .cornerRadius(28)
                .shadow(color: .black.opacity(0.25),
                        radius: 12, x: 0, y: 6)
                .padding(.horizontal, 32)
                .padding(.bottom, 40)
            }
        }
        .ignoresSafeArea()    // ‚Üê ensures your blurred bg shows under the home-indicator too
    }
}


/// A pill‚Äêshaped toggle whose selected segment
/// uses a stronger material + higher opacity.
struct WideSegmentedToggle: View {
    @Binding var isAfter: Bool
    private let height: CGFloat = 48

    var body: some View {
        HStack(spacing: 0) {
            segment("Before", active: !isAfter) {
                withAnimation(.easeInOut) { isAfter = false }
            }
            segment("After",  active:  isAfter) {
                withAnimation(.easeInOut) { isAfter = true }
            }
        }
        .frame(height: height)
        .background(.ultraThinMaterial)  // parent track
        .clipShape(RoundedRectangle(
            cornerRadius: height/2,
            style: .continuous
        ))
        .shadow(color: .black.opacity(0.25),
                radius: 8, x: 0, y: 4)
        .animation(.easeInOut, value: isAfter)
    }

    private func segment(
        _ label: String,
        active: Bool,
        action: @escaping () -> Void
    ) -> some View {
        Button(action: action) {
            Text(label)
                .font(.headline.weight(.semibold))
                .frame(maxWidth: .infinity)
                .frame(height: height)
        }
        .buttonStyle(.plain)
        .background(
            RoundedRectangle(cornerRadius: height/2,
                             style: .continuous)
                // use a stronger material when selected‚Ä¶
                .fill(active ? .regularMaterial : .ultraThinMaterial)
                // ‚Ä¶and bump opacity for extra pop
                .opacity(active ? 1.0 : 0.6)
        )
        .animation(.easeInOut, value: active)
    }
}
import SwiftUI

/// The enhancement panel shows a scroll of options and a bottom bar.
/// It pre-selects the first option automatically.
import SwiftUI

struct BottomBar: View {
    let iconAssetName: String?
    let onCancel: () -> Void
    let onApply: () -> Void
    let canApply: Bool

    @State private var shineApply = false

    var body: some View {
        HStack {
            // Cancel
            Button(action: onCancel) {
                Label("Cancel", systemImage: "xmark")
                    .font(.headline)
                    .foregroundColor(.white)
                    .padding(.vertical, 14)
                    .padding(.horizontal, 20)
            }

            Spacer()

            // Icon
            if let asset = iconAssetName {
                Image(asset)
                    .resizable()
                    .aspectRatio(contentMode: .fit)
                    .frame(width: 44, height: 44)
            }

            Spacer()

            // Apply with shimmer when canApply
            Button(action: onApply) {
                Label("Apply", systemImage: "checkmark")
                    .font(.headline)
                    .foregroundColor(.white)
                    .padding(.vertical, 12)
                    .padding(.horizontal, 24)
                    .background(
                        // use the mask & moving gradient
                        RoundedRectangle(cornerRadius: 24)
                            .fill(Color.clear)
                            .overlay(
                                Group {
                                    if canApply {
                                        Rectangle()
                                            .fill(
                                                LinearGradient(
                                                    gradient: Gradient(colors: [
                                                        Color.black.opacity(0.1),
                                                        Color.black.opacity(0.3),
                                                        Color.black.opacity(0.1)
                                                    ]),
                                                    startPoint: .leading,
                                                    endPoint: .trailing
                                                )
                                            )
                                            .rotationEffect(.degrees(30))
                                            .offset(x: shineApply ? 200 : -200)
                                            .mask(RoundedRectangle(cornerRadius: 24))
                                            .animation(
                                                Animation
                                                    .linear(duration: 2.5)
                                                    .repeatForever(autoreverses: false),
                                                value: shineApply
                                            )
                                    }
                                }
                            )
                    )
            }
            .onAppear {
                // kick it off if we're already allowed
                if canApply {
                    shineApply = true
                }
            }
            .onChange(of: canApply) { newValue in
                // whenever we flip to true, reset & start the shimmer
                if newValue {
                    shineApply = false
                    shineApply = true
                } else {
                    shineApply = false
                }
            }
        }
        .padding(.horizontal, 7)
        .padding(.bottom, 20)
    }
}

// EnhancementPanelView itself
struct EnhancementPanelView: View {
    let section: String
    let options: [EnhancementOption]
    @Binding var selectedOption: EnhancementOption?
    let applyAction: () -> Void
    let cancelAction: () -> Void

    var body: some View {
        VStack(spacing: 12) {
            PillsScroll(options: options, selectedOption: $selectedOption)
            Divider().background(Color.white.opacity(0.5))
            BottomBar(
                iconAssetName: sectionIconName,
                onCancel: cancelAction,
                onApply: applyAction,
                canApply: selectedOption != nil
            )
        }
        .background(.ultraThinMaterial)
        .cornerRadius(16)
        .padding(.horizontal, 16)
        .padding(.bottom, 8)
        .padding(.top, 12)
        .onAppear {
            // Pre-select first option
            if selectedOption == nil, let first = options.first {
                selectedOption = first
            }
        }
    }

    private var sectionIconName: String {
        section.replacingOccurrences(of: " ", with: "")
    }
}




// MARK: ‚Äî Pills Scroll
private struct PillsScroll: View {
    let options: [EnhancementOption]
    @Binding var selectedOption: EnhancementOption?

    var body: some View {
        ScrollView(.horizontal, showsIndicators: false) {
            HStack(spacing: 16) {
                ForEach(options) { opt in
                    OptionPill(
                        option: opt,
                        isSelected: opt.id == selectedOption?.id
                    )
                    .onTapGesture { selectedOption = opt }
                }
            }
            .padding(.horizontal, 16)
            .padding(.bottom, 8)
            .padding(.top, 12)
        }
    }
}

// MARK: ‚Äî Single Pill
private struct OptionPill: View {
    let option: EnhancementOption
    let isSelected: Bool

    private var iconName: String {
        switch option.id {
        case "round":        return "circle"
        case "heart_shaped": return "heart.fill"
        case "superlift":    return "flame.fill"
        default:             return "sparkles"
        }
    }

    private var titleColor: AnyShapeStyle {
        if isSelected {
            AnyShapeStyle(
                LinearGradient(
                    colors: [Color.pink, Color.orange],
                    startPoint: .leading,
                    endPoint: .trailing
                )
            )
        } else {
            AnyShapeStyle(Color.white.opacity(0.9))
        }
    }

    var body: some View {
        HStack(spacing: 12) {
            Image(systemName: iconName)
                .font(.subheadline)
                .foregroundColor(isSelected ? .white : .white.opacity(0.7))
            Text(option.title)
                .font(.subheadline)
                .fontWeight(.medium)
                .foregroundStyle(titleColor)
        }
        .padding(.vertical, 12)
        .padding(.horizontal, 20)
        .background(isSelected ? Color.black.opacity(0.85) : Color.black.opacity(0.6))
        .cornerRadius(24)
        .overlay(
            Group {
                if isSelected {
                    Image(systemName: "checkmark.circle.fill")
                        .font(.title3)
                        .foregroundColor(.white)
                        .offset(x: 8, y: -8)
                }
            }, alignment: .topTrailing
        )
    }
}
//
//  OnboardingFlowView.swift
//  HairStyle
//

import SwiftUI
import StoreKit
import UserNotifications

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Root onboarding flow ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
struct OnboardingFlowView: View {
    @AppStorage("hasCompletedOnboarding") private var done     = false
    @AppStorage("isPremium")              private var premium  = false
    
    @EnvironmentObject private var manager: SubscriptionManager
    @State private var page = 0
    /// Convenience: number of Before‚ÜíAfter screens
    private var extraStart: Int { onboardingTransformations.count }
    
    var body: some View {
        TabView(selection: $page) {
            // ‚îÄ‚îÄ Before / After pages ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            ForEach(0..<onboardingTransformations.count, id: \.self) { idx in
                BeforeAfterPage(
                    transformation: onboardingTransformations[idx]
                ) { page += 1 }
                    .tag(idx)               // 0,1,2,‚Ä¶
            }

            ReviewPage { page += 1 }        // tag N
                .tag(extraStart)

            BudgetPage { page += 1 }        // tag N+1
                .tag(extraStart + 1)

            // SkillPage *no longer* finishes the flow ‚Äì it just advances
            SkillPage { page += 1 }         // tag N+2
                .tag(extraStart + 2)

            // üîë NEW ‚Äì Paywall right after the skill page
            PaywallPageView(
                isPremium: $premium,        // bind to @AppStorage
                onComplete: finish          // call finish() afterwards
            )
            .tag(extraStart + 3)

            // Optional: uncomment NotifyPage if you still need it
            // NotifyPage { finish() }
            //     .tag(extraStart + 4)
        }
        .tabViewStyle(.page(indexDisplayMode: .never))
        .ignoresSafeArea()
    }
    
    private func finish() { done = true }
}

// MARK: ‚Äì Gradient helper
struct PinkGradient<Content: View>: View {
    @ViewBuilder var content: () -> Content
    var body: some View {
        LinearGradient(
            colors: [Color(red: 1, green: 0.95, blue: 0.96),
                     Color(red: 1, green: 0.87, blue: 0.90)],
            startPoint: .top, endPoint: .bottom
        )
        .ignoresSafeArea()
        .overlay(content())
    }
}

/// A reusable dark mesh-gradient background that you can
/// overlay with any content.
struct DarkMeshGradient<Content: View>: View {
    @ViewBuilder var content: () -> Content
    
    var body: some View {
        ZStack {
            // --- Mesh: 3√ó3 grid, 9 control points --------------
            if #available(iOS 18.0, *) {
                MeshGradient(
                    width: 3,
                    height: 3,
                    points: [
                        .init(0.00, 0.00), .init(0.50, 0.00), .init(1.00, 0.00),
                        .init(0.00, 0.50), .init(0.50, 0.50), .init(1.00, 0.50),
                        .init(0.00, 1.00), .init(0.50, 1.00), .init(1.00, 1.00)
                    ],
                    
                    // Subtle dark palette ‚Äì- corners almost black,
                    // mid-tones get a touch of indigo / teal.
                    colors: [
                        .black,                     Color(hex: 0x10121A),       .black,
                        Color(hex: 0x06070C),       Color(hex: 0x1A1C27),       Color(hex: 0x0E1119),
                        .black,                     Color(hex: 0x121726),       .black
                    ]
                )
                // A big blur softens the colour transitions so you
                // don‚Äôt see obvious ‚Äúpatches‚Äù from the mesh cells.
                .blur(radius: 80)
            } else {
                // Fallback on earlier versions
            }
            
            // Faint angular sweep = a hint of depth / vignette.
            AngularGradient(
                colors: [.clear, .white.opacity(0.05), .clear],
                center: .center
            )
            .blendMode(.overlay)
        }
        .ignoresSafeArea()
        .overlay(content())          // your foreground
    }
}

// MARK: - Small colour helper
extension Color {
    /// Initialise `Color` with 24-bit hex, e.g. `0x1A2B3C`
    init(hex: UInt32, opacity: Double = 1) {
        self.init(.sRGB,
                  red:   Double((hex >> 16) & 0xff) / 255,
                  green: Double((hex >>  8) & 0xff) / 255,
                  blue:  Double( hex        & 0xff) / 255,
                  opacity: opacity)
    }
}



// MARK: ‚Äì Pill helper
private struct Pill: View {
    var title: String
    var body: some View {
        Text(title)
            .font(.headline.weight(.semibold))
            .padding(.vertical, 12)
            .padding(.horizontal, 30)
            .background(Color.white)
            .cornerRadius(26)
            .shadow(color: .black.opacity(0.06), radius: 4, y: 2)
    }
}
// MARK: ‚Äì Page ‚Äì Usage volume
private struct BudgetPage: View {
    let onContinue: () -> Void
    @State private var selection: String?
    
    /// Options deliberately steer frequent editors to Premium
    private let opts: [(String,String)] = [
        ("üì∑", "1‚Äì2 photos / week "),
        ("‚ö°Ô∏è", "Up to 15 edits / week "),
        ("üíé", "Unlimited edits"),
        ("üöÄ", "Batch HD exports")
    ]
    
    var body: some View {
        DarkMeshGradient {
            VStack(spacing: 42) {
                Spacer().frame(height: 60)
                
                Text("How many photos\nwill you **perfect** every week?")
                    .font(.largeTitle.bold())
                    .foregroundColor(.white)
                    .multilineTextAlignment(.center)
                
                VStack(spacing: 22) {
                    ForEach(opts, id:\.1) { em, txt in
                        Button { selection = txt } label: {
                            Pill(title: "\(em)  \(txt)")
                                .overlay(
                                    RoundedRectangle(cornerRadius: 26)
                                        .stroke(Color.yellow.opacity(selection == txt ? 0.8 : 0),
                                                lineWidth: 2)
                                )
                        }
                    }
                }
                
                Spacer()
                
                Button(action: onContinue) {
                    Text(selection?.contains("Premium") == true
                         ? "Unlock AI Power ‚Üí"
                         : "Next")
                        .font(.headline)
                        .frame(maxWidth: .infinity)
                        .padding(.vertical, 18)
                        .background(Color.white)
                        .cornerRadius(32)
                }
                .padding(.horizontal, 40)
                .opacity(selection == nil ? 0.3 : 1)
                .disabled(selection == nil)
                
                Spacer(minLength: 30)
            }
            .padding(.horizontal)
        }
    }
}


// MARK: ‚Äì Page ‚Äì Editing power level
private struct SkillPage: View {
    let onContinue: () -> Void
    @State private var selection: String?
    
    private let opts: [(String,String)] = [
        ("üôÇ", "Basic smoothing"),
        ("üí™", "Shape & Slim"),
        ("üî•", "Full Body Makeover"),
        ("‚ù§Ô∏è", "4K full picture edits")
    ]
    
    var body: some View {
        DarkMeshGradient {
            VStack(spacing: 42) {
                Spacer().frame(height: 60)
                
                Text("Choose your\nediting **power level**")
                    .font(.largeTitle.bold())
                    .foregroundColor(.white)
                    .multilineTextAlignment(.center)
                
                VStack(spacing: 22) {
                    ForEach(opts, id:\.1) { em, txt in
                        Button { selection = txt } label: {
                            Pill(title: "\(em)  \(txt)")
                                .overlay(
                                    RoundedRectangle(cornerRadius: 26)
                                        .stroke(Color.yellow.opacity(selection == txt ? 0.8 : 0),
                                                lineWidth: 2)
                                )
                        }
                    }
                }
                
                Spacer()
                
                Button(action: onContinue) {
                    Text(selection?.contains("Premium") == true
                         ? "Continue ‚Üí"
                         : "Finish")
                        .font(.headline)
                        .frame(maxWidth: .infinity)
                        .padding(.vertical, 18)
                        .background(Color.white)
                        .cornerRadius(32)
                }
                .padding(.horizontal, 40)
                .opacity(selection == nil ? 0.3 : 1)
                .disabled(selection == nil)
                
                Spacer(minLength: 30)
            }
            .padding(.horizontal)
        }
    }
}


private struct ReviewPage: View {
    let onContinue: () -> Void
    
    var body: some View {
        DarkMeshGradient {        // ‚¨ÖÔ∏è new gradient
            VStack(spacing: 36) {
                Spacer().frame(height: 60)
                
                Text("Enjoying HairStyle?")
                    .font(.title.bold())
                    .foregroundColor(.white)
                    .multilineTextAlignment(.center)
                
                Text("Keep stunning looks coming ‚Äì a quick **5-star** rating helps us add more styles for you!")
                    .font(.title3.weight(.medium))
                    .foregroundColor(.white.opacity(0.9))
                    .multilineTextAlignment(.center)
                    .padding(.horizontal)
                
                VStack(spacing: 8) {
                    HStack(spacing: 10) {
                        ForEach(0..<5) { _ in
                            Image(systemName: "star.fill")
                                .resizable()
                                .frame(width: 44, height: 44)
                                .foregroundColor(.yellow)
                        }
                    }
                    Text("5 / 5")
                        .font(.headline.weight(.semibold))
                        .foregroundColor(.yellow)
                }
                .shadow(radius: 4)
                
                Spacer()
                
                Button {
                    if let scene = UIApplication.shared.connectedScenes.first as? UIWindowScene {
                        SKStoreReviewController.requestReview(in: scene)
                    }
                    onContinue()
                } label: {
                    Text("Rate 5 Stars ‚≠êÔ∏è")
                        .font(.headline.weight(.semibold))
                        .frame(maxWidth: .infinity)
                        .padding(.vertical, 18)
                        .background(Color.white)
                        .cornerRadius(32)
                }
                .padding(.horizontal, 40)
                
                Spacer(minLength: 30)
            }
            .padding(.horizontal)
        }
    }
}


// MARK: ‚Äì Page ‚Äì Notification permission (FINISH)
private struct NotifyPage: View {
    let onContinue: () -> Void
    @State private var requesting = false

    var body: some View {
        PinkGradient {
            VStack(spacing:32) {
                Spacer().frame(height:60)

                Text("Allow Notifications")
                    .font(.largeTitle.bold())
                    .multilineTextAlignment(.center)

                Image(systemName:"app.badge.fill")
                    .resizable().scaledToFit()
                    .frame(width:180)
                    .foregroundColor(.pink)

                Spacer()
                Button {
                    requesting = true
                    UNUserNotificationCenter.current()
                        .requestAuthorization(options: [.alert,.sound,.badge]) { _,_ in
                            DispatchQueue.main.async {
                                requesting = false
                                onContinue()
                            }
                        }
                } label: {
                    Text("Enable notifications! ü•∞")
                        .font(.headline)
                        .frame(maxWidth:.infinity)
                        .padding(.vertical,18)
                        .background(Color.white)
                        .cornerRadius(32)
                }
                .padding(.horizontal,40)
                .opacity(requesting ? 0.5 : 1)
                .disabled(requesting)
                Spacer(minLength:30)
            }
            .padding(.horizontal)
        }
    }
}
//
//  PhotoContainerView.swift
//  HairStyle
//
//  Created by adam on 25/04/2025.
//

import SwiftUI

// MARK: ‚Äì Photo container
struct PhotoContainerView: View {
    @Binding var inputImage: UIImage?
    let isGenerating: Bool
    let editedImage: UIImage?
    let depthMapImage: UIImage?
    @Binding var sliderPosition: CGFloat
    @Binding var showSlider: Bool
    let onAddTap: () -> Void
    let onReplaceTap: () -> Void
    let onAvatarTap: () -> Void     // NEW
    let onSaveTap: () -> Void

    var body: some View {
           ZStack {
               // ‚îÄ‚îÄ NEW: dynamic blurred background ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
               if let bg = editedImage ?? inputImage {          // fall back if editedImage is nil
                   Image(uiImage: bg)
                       .resizable()
                       .scaledToFill()                          // fills width *and* height
                       .blur(radius: 7)                         // ‚üµ requested blur
                       .ignoresSafeArea()                       // under status-/home-bars
               }

               // existing foreground content
               PhotoWithRefreshOverlay(
                   originalImage: inputImage,
                   editedImage: editedImage,
                   depthMapImage: depthMapImage,
                   isGenerating: isGenerating,
                   sliderPosition: $sliderPosition,
                   showSlider: $showSlider,
                   onReplaceTap: onReplaceTap,
                   onAddTap: onAddTap,
                   onAvatarTap: onAvatarTap,
                   onSaveTap: onSaveTap
               )
           }
       }


    @ViewBuilder private var backgroundView: some View {
        if let img = inputImage {
            Image(uiImage: img).resizable().scaledToFill().blur(radius: 120).overlay(Color.black.opacity(0.4))
        } else {
            Color.black.opacity(0.6)
        }
    }
}
import SwiftUI
import UIKit
import StoreKit

// MARK: ‚Äì Thumbnail‚Äëstrip item
struct ThumbItem: Identifiable {
    /// id == -1 ‚Üí original; 0‚Ä¶3 ‚Üí generated slots
    let id: Int
    var image: UIImage? = nil
    var isLoading: Bool = false
    var isOriginal: Bool { id == -1 }
}

// MARK: ‚Äì GenView
struct GenView: View {
    // MARK: Inputs
    let section: String

    init(section: String) {
         self.section = section
     }
    // MARK: View‚Äëmodel
    @StateObject private var viewModel = ImageEditingViewModel()

    // MARK: UI state
    @State private var selectedOption: EnhancementOption?
    @State private var inputImage: UIImage?
    @State private var showingImagePicker = false
    @State private var showingAvatarPicker = false            // NEW
    @State private var sliderPosition: CGFloat = 0.5
    @State private var showSlider = false
    @State private var showSaveSuccessAlert = false

    // thumbnails: original + generated
    @State private var thumbs: [ThumbItem] = []
    @State private var currentIdx: Int? = nil

    // paywall modal flag
    @State private var showPaywallModal = false

    // MARK: Environment
    @Environment(\.dismiss) private var dismiss
    @EnvironmentObject private var subscriptionManager: SubscriptionManager

    // Derived
    private var isGenerating: Bool { thumbs.contains { !$0.isOriginal && $0.isLoading } }
    private var hasThumbs: Bool { !thumbs.isEmpty }
    private var shouldShowPaywall: Bool {
        !subscriptionManager.purchasedIdentifiers.contains("weeksub") &&
        thumbs.count >= 5 &&
        thumbs.dropFirst().allSatisfy { !$0.isLoading }
    }

    // MARK: ‚Äì Pre‚Äëbundled avatars
    private var builtInAvatars: [UIImage] = {
        (1...10).compactMap { UIImage(named: String(format: "Persona%02d", $0)) }
    }()

    // MARK: Body ----------------------------------------------------------------
    var body: some View {
        ZStack {
            GeometryReader { geo in
                PhotoContainerView(
                    inputImage: $inputImage,
                    isGenerating: isGenerating,
                    editedImage: mainDisplayedImage,
                    depthMapImage: viewModel.depthMapImage,
                    sliderPosition: $sliderPosition,
                    showSlider: $showSlider,
                    onAddTap: handleReplacePhoto,
                    onReplaceTap: handleReplacePhoto,
                    onAvatarTap: { showingAvatarPicker = true }, // NEW
                    onSaveTap: saveImage
                )
                .frame(width: geo.size.width, height: geo.size.height)
                .ignoresSafeArea()

                if inputImage != nil {
                    TopButtons(
                        onBack: { dismiss() },
                        onReplace: handleReplacePhoto,
                        onShare: shareImage,
                        onSave: saveImage,
                        topInset: -20
                    )
                    .padding(.horizontal, 16)
                }

                VStack {
                    Spacer()
                    if hasThumbs {
                        ThumbnailsStrip(
                            thumbs: thumbs,
                            onSelect: { currentIdx = $0 },
                            onRetry: beginParallelGeneration
                        )
                    } else {
                        EnhancementPanelView(
                            section: section,
                            options: enhancementOptions,
                            selectedOption: $selectedOption,
                            applyAction: beginParallelGeneration,
                            cancelAction: { dismiss() }
                        )
                    }
                }
                .frame(width: geo.size.width)
            }
        }
        .navigationBarBackButtonHidden(true)
        .overlay { overlayGenerating }
        .sheet(isPresented: $showingImagePicker, onDismiss: loadImage) {
            ImagePicker(image: $inputImage)
        }
        .sheet(isPresented: $showingAvatarPicker) {
            AvatarPickerView(
                avatars: builtInAvatars,
                onSelect: { ui in
                    inputImage = ui
                    loadImage()
                    showingAvatarPicker = false
                },
                onCancel: { showingAvatarPicker = false }
            )
        }
        .alert("Saved", isPresented: $showSaveSuccessAlert) {
            Button("OK", role: .cancel) { }
        } message: { Text("Image saved to Photos") }
        .onChange(of: shouldShowPaywall) { if $0 { showPaywallModal = true } }
        .fullScreenCover(isPresented: $showPaywallModal) { paywall }
    }

    // MARK: ‚Äì Sub‚Äëviews
    private var overlayGenerating: some View {
        Group {
            if isGenerating {
                Color.black.opacity(0.35).ignoresSafeArea()
                ProgressView()
                    .progressViewStyle(CircularProgressViewStyle(tint: .white))
                    .scaleEffect(2)
            }
        }
    }

    private var paywall: some View {
        WeeklyPaywallView(
            thumbs: thumbs,
            onUnlock: { showPaywallModal = false },
            onClose: {
                showPaywallModal = false
                dismiss()
            }
        )
        .environmentObject(subscriptionManager)
    }

    // MARK: Helpers ------------------------------------------------------------
    private var mainDisplayedImage: UIImage? {
        guard let idx = currentIdx, thumbs.indices.contains(idx) else {
            return viewModel.editedImage
        }
        return idx == 0 ? inputImage : thumbs[idx].image
    }

    // MARK: Generation ----------------------------------------------------------
    private func beginParallelGeneration() {
        guard let base = inputImage,
              let prompt = selectedOption?.prompt else { return }

        // 1Ô∏è‚É£  Free quota *still* available OR user is subscribed
        if subscriptionManager.canGenerate {
            thumbs = [ThumbItem(id: -1, image: base)] +
                     (0..<6).map { ThumbItem(id: $0, isLoading: true) }
            currentIdx = 1
            
            Task.detached(priority: .userInitiated) {
                await withTaskGroup(of: (Int, UIImage?).self) { group in
                    for idx in 0..<6 {
                        group.addTask {
                            (idx, await ImageEditingWorker.generate(
                                       input: base, prompt: prompt))
                        }
                    }
                    for await (idx, img) in group {
                        await MainActor.run {
                            thumbs[idx + 1].image    = img
                            thumbs[idx + 1].isLoading = false
                        }
                    }
                }
                // ‚¨áÔ∏è count this run *only* for free users
                await MainActor.run {
                    subscriptionManager.markGenerationUsed()
                }
            }
            return
        }

        // 2Ô∏è‚É£  Free quota exhausted ‚Äì show progressively blurred copy, no API call
        let previous  = mainDisplayedImage ?? base
        let radius    = pow(2.0,
                            Double(subscriptionManager.freeGenerationsUsed)) * 5
        guard let blurred = previous.blurred(radius: radius) else { return }

        thumbs      = [ThumbItem(id: -1, image: base),
                       ThumbItem(id: 0, image: blurred)]
        currentIdx  = 1
        // bump counter so next tap doubles the blur again
        subscriptionManager.markGenerationUsed()
    }


    // MARK: UI actions ---------------------------------------------------------
    private func handleReplacePhoto() { showingImagePicker = true }

    private func loadImage() {
        guard let img = inputImage else { return }
        viewModel.editedImage = img
        thumbs.removeAll()
        currentIdx = nil
    }

    private func saveImage() {
        guard let img = mainDisplayedImage else { return }
        UIImageWriteToSavedPhotosAlbum(img, nil, nil, nil)
        showSaveSuccessAlert = true
    }

    private func shareImage() {
        guard let img = mainDisplayedImage else { return }
        let av = UIActivityViewController(activityItems: [img], applicationActivities: nil)
        UIApplication.shared.windows.first?.rootViewController?.present(av, animated: true)
    }

    // MARK: Enhancement options -----------------------------------------------
    private var enhancementOptions: [EnhancementOption] {
        switch section {
        case "Chest":    return BodyEnhancementPrompts.breast
        case "Belly":    return BodyEnhancementPrompts.belly
        case "Buttock":  return BodyEnhancementPrompts.buttock
        case "Muscle":   return BodyEnhancementPrompts.muscle
        case "Hair":     return BodyEnhancementPrompts.hair
        case "Nose":     return BodyEnhancementPrompts.nose
        case "Eyes":     return BodyEnhancementPrompts.eyes
        case "Skin":     return BodyEnhancementPrompts.skin
        case "Face":     return BodyEnhancementPrompts.face
        case "Lips":     return BodyEnhancementPrompts.lips
        case "Waist":    return BodyEnhancementPrompts.waist
        case "Legs":     return BodyEnhancementPrompts.leg
        case "jewellery":return BodyEnhancementPrompts.jewellery
        case "Eyewear":  return BodyEnhancementPrompts.eyewear
        
        // üîë Fallback for any free‚Äëtext prompt coming from the horizontal panel
        default:
            return [
                EnhancementOption(
                    id: "custom",
                    title: "Apply",     // label on the pill
                    subtitle: nil,
                    prompt: section,    // the full sentence prompt
                    isFree: true)
            ]
        }
    }
}

struct ThumbnailsStrip: View {
    // MARK: ‚Äì Inputs
    let thumbs: [ThumbItem]
    let onSelect: (Int) -> Void
    let onRetry: () -> Void
    
    // MARK: ‚Äì Layout constants
    private let thumbWidth:  CGFloat = 91   // 70 pt √ó 1.3
    private let thumbHeight: CGFloat = 118  // 70 pt √ó 1.3 (portrait)
    
    // MARK: ‚Äì Derived
    var isGenerating: Bool { thumbs.contains { !$0.isOriginal && $0.isLoading } }
    
    // MARK: ‚Äì Body ------------------------------------------------------------
    var body: some View {
        ScrollView(.horizontal, showsIndicators: false) {
            HStack(spacing: 16) {
                // thumbnails --------------------------------------------------
                ForEach(thumbs) { thumb in
                    ZStack {
                        // image or placeholder
                        Group {
                            if let ui = thumb.image {
                                Image(uiImage: ui)
                                    .resizable()
                                    .aspectRatio(contentMode: .fill)
                            } else {
                                Color.gray.opacity(0.3)
                            }
                        }
                        .frame(width: thumbWidth, height: thumbHeight)
                        .clipped()
                        .cornerRadius(14)
                        
                        // spinner
                        if thumb.isLoading {
                            ProgressView()
                                .progressViewStyle(CircularProgressViewStyle(tint: .white))
                        }
                        
                        // ‚ÄúORIGINAL‚Äù badge
                        if thumb.isOriginal {
                            VStack {
                                Spacer()
                                Text("ORIGINAL")
                                    .font(.caption2.weight(.bold))
                                    .foregroundColor(.white)
                                    .padding(.vertical, 2)
                                    .frame(maxWidth: .infinity)
                                    .background(Color.black.opacity(0.6))
                            }
                        }
                    }
                    .frame(width: thumbWidth, height: thumbHeight)
                    .onTapGesture { onSelect(thumb.id == -1 ? 0 : thumb.id + 1) }
                }
                
                // retry button ------------------------------------------------
                Button(action: onRetry) {
                    ZStack {
                        Color.black.opacity(0.6)
                        Image(systemName: "arrow.clockwise")
                            .font(.title3.weight(.semibold))
                            .foregroundColor(.white)
                    }
                    .frame(width: thumbWidth, height: thumbHeight)
                    .cornerRadius(14)
                    .overlay(isGenerating ? Color.black.opacity(0.4).cornerRadius(14) : nil)
                }
                .disabled(isGenerating)
            }
            .padding(.horizontal, 16)
            .padding(.vertical, 8)
        }
        .frame(height: thumbHeight + 16)      // keeps the strip‚Äôs height tight
        .background(.ultraThinMaterial)
        .cornerRadius(16)
    }
}

private struct TopButtons: View {
    let onBack, onReplace, onShare, onSave: () -> Void
    let topInset: CGFloat
    var body: some View {
        HStack(spacing: 12) {
            Button(action: onBack)    { Image(systemName: "chevron.left").modifier(circleIcon) }
            Button(action: onReplace) { Image(systemName: "arrow.triangle.2.circlepath").modifier(circleIcon) }
            Spacer()
            HStack(spacing: 12) {
                Button(action: onShare) { Image(systemName: "paperplane.fill").modifier(circleIcon) }
                Button(action: onSave)  { Image(systemName: "square.and.arrow.down").modifier(circleIcon) }
            }
        }
        .padding(.top, topInset + 20)
    }
    private var circleIcon: some ViewModifier { CircleIcon() }
}
private struct CircleIcon: ViewModifier {
    func body(content: Content) -> some View {
        content
            .font(.system(size: 20, weight: .medium))
            .foregroundColor(.white)
            .frame(width: 36, height: 36)
            .background(Color.black.opacity(0.6))
            .clipShape(Circle())
    }
}

// UIImage+Blur.swift
import UIKit
import CoreImage
import CoreImage.CIFilterBuiltins   // ‚Üê ADD THIS LINE

extension UIImage {
    func blurred(radius: Double) -> UIImage? {
        guard let cg = cgImage else { return nil }

        let ciImg  = CIImage(cgImage: cg)
        let filter = CIFilter.gaussianBlur()   // now resolves correctly
        filter.inputImage = ciImg
        filter.radius     = Float(radius)      // property is Float, so cast

        guard let out = filter.outputImage else { return nil }
        let ctx  = CIContext()
        guard let cgOut = ctx.createCGImage(out, from: ciImg.extent) else { return nil }
        return UIImage(cgImage: cgOut)
    }
}
import SwiftUI

struct CatalogView: View {
    // MARK: ‚Äî Prompt definitions shown in the horizontal panel
    private let promptItems: [PromptItem] = [
        
        .init(name: "üóëÔ∏è Remove Objects",
              prompt: "Erase unwanted objects or people from the background and intelligently rebuild the missing scenery for a spotless shot"),

        .init(name: "üëî Professional Photo",
              prompt: "respectfully make the photo look more professional, like a corporate portrait with neutral backdrop, balanced lighting, and crisp details, keep the face details and photo composition the same"),

        .init(name: "üèñÔ∏è Body Tuner",
              prompt: "Refine waistline, smooth skin, and subtly enhance posture for a confident, natural swimsuit silhouette"),

        .init(name: "üêª Wild Hug",
              prompt: "Composite the subject embracing a photorealistic wild animal‚Äîmatching lighting and shadows for a seamless, share-worthy moment"),

        .init(name: "ü§µ‚Äç‚ôÇÔ∏è Classy Seaside",
              prompt: "Reimagine the portrait on Italy‚Äôs sun-soaked coast with Bond-style elegance: turquoise sea, retro speedboat, and golden light"),

        .init(name: "üõ†Ô∏è Fix Bad Photo",
              prompt: "Rescue blurry, dark, or pixelated shots by sharpening details, balancing exposure, and reviving true-to-life colours"),

        .init(name: "üíá‚Äç‚ôÄÔ∏è Volume & Style",
              prompt: "Respectfully enhance the natural hair volume for a salon-perfect finish"),

        .init(name: "üòÅ Smile Boost",
              prompt: "Gently lift lip corners, brighten teeth, and align facial harmony to create a natural, confident smile"),

        .init(name: "üì± Phone Removal",
              prompt: "remove the smartphone from the image, make the pose natural, and add a subtle background, enhance the smile"),

        
        .init(name: "üåÖ Golden-Hour Glow",
              prompt: "Infuse the scene with gentle sunset warmth, adding soft highlights and a cinematic amber tint"),
        .init(name: "üí° Fairy-Light Bokeh",
              prompt: "Scatter dreamy string-light bokeh in the background while keeping the subject tack-sharp"),
        .init(name: "üì∏ Mirror Selfie Cleanup",
              prompt: "Erase smudges, fingerprints, and edge glare for a spotless mirror-selfie finish"),
        .init(name: "üéûÔ∏è 35 mm Film Grain",
              prompt: "Overlay fine analog grain and subtle color shifts for an authentic film-camera feel"),
        .init(name: "üè† Cozy Tone",
              prompt: "Warm up shadows and mid-tones for a soft, homely ambience that flatters skin tones"),
        .init(name: "üì∑ Depth Portrait",
              prompt: "Simulate DSLR-style depth of field, blurring cluttered closets so the subject pops"),
        .init(name: "ü™û Reflection Boost",
              prompt: "Enhance mirror reflections and add subtle vignetting to frame the subject elegantly"),
        .init(name: "üö™ Closet Fade",
              prompt: "Desaturate and soften wardrobe colors in the background to reduce visual noise"),
        .init(name: "üå¨Ô∏è Soft-Breeze Hair",
              prompt: "Introduce a gentle hair movement and airy lightness for a candid, in-motion effect"),
        .init(name: "‚ú® Velvet Skin",
              prompt: "Smooth complexion just enough to mimic natural evening light, retaining realistic texture"),

        
            .init(name: "üì± Story Frame 9:16",
                  prompt: "Auto-crop to a perfect 9:16 ratio, extending blurred edges if needed so nothing important is lost"),
            .init(name: "ü§≥ Arm-Length Perspective",
                  prompt: "Correct wide-angle distortion from a front-camera lens for natural proportions and straighter lines"),
            .init(name: "üîÜ Window Light Boost",
                  prompt: "Add soft, directional daylight from one side, creating gentle face highlights and clear catch-lights"),
            .init(name: "üí´ Vertical Lens Flare",
                  prompt: "Overlay subtle golden flare streaks that run top-to-bottom to enhance back-lit selfies"),
            .init(name: "‚ûø Spiral Focus",
                  prompt: "Apply a delicate spiral blur emanating from corners to draw attention straight to the subject‚Äôs eyes"),
            .init(name: "üéûÔ∏è Film Burn Edge",
                  prompt: "Introduce warm, analog film-burn at the upper and lower edges for a retro story vibe"),
            .init(name: "üå´Ô∏è Haze Fade",
                  prompt: "Fade distant background elements with a soft vertical haze for extra depth and reduced clutter"),
            .init(name: "üö∂‚Äç‚ôÄÔ∏è Body Highlight",
                  prompt: "Add subtle rim lighting along the torso to flatter full-length mirror selfies and define shape"),
            .init(name: "üìè Slim Stretch",
                  prompt: "Gently elongate the canvas to add perceived height while preserving realistic body ratios"),
            .init(name: "üé≠ Mood DuoTone",
                  prompt: "Blend two complementary warm tones from top to bottom, creating a stylish magazine-grade gradient"),

        .init(name: "üë©‚Äçüíº CEO Hair",
              prompt: "Give hair a sleek, power-professional style that‚Äôs perfect for LinkedIn headshots"),
        .init(name: "üßú‚Äç‚ôÄÔ∏è Mermaid Waves",
              prompt: "Create soft mermaid-inspired waves with beachy texture‚Äîno heat needed"),
        .init(name: "üíñ Barbie Pink",
              prompt: "Re-colour hair to a glossy, vibrant Barbie-pink while keeping strands defined"),
        .init(name: "üéÆ Anime Glam",
              prompt: "Transform the photo into stylised anime art with cel-shaded hair and bright eyes"),
        .init(name: "üåå Galactic Ombr√©",
              prompt: "Blend cosmic purples and blues into a seamless space-ombr√© gradient"),
        .init(name: "üöÄ Big-Hair Boost",
              prompt: "Simulate a voluminous salon blow-out with maximum bounce and body"),
        .init(name: "ü™û Glass Skin",
              prompt: "Smooth and illuminate complexion for a pore-less glass-skin glow"),
        .init(name: "ü´ß Anti-Frizz",
              prompt: "Erase frizz and flyaways for silky, perfectly polished strands"),
        .init(name: "üíú Neon Streaks",
              prompt: "Paint electrifying neon streaks through the hair for a cyber-punk vibe"),
        .init(name: "ü¶∏‚Äç‚ôÄÔ∏è Action Figure",
              prompt: "Render the subject as a hyper-detailed action figure with dramatic lighting"),
        .init(name: "üö´ Ex Eraser",
              prompt: "Remove an unwanted person from the shot while enhancing the remaining subject"),
        .init(name: "üì∏ Bokeh Pop",
              prompt: "Add creamy DSLR-style background bokeh so the subject pops instantly"),

        
        
        
        
        
        .init(name: "üßπ Remove Objects",
              prompt: "Remove the unwanted objects from the background keeping the subject intact"),
        .init(name: "üé® Clear Background",
              prompt: "Replace the background with a plain, neutral colour"),
        .init(name: "üéûÔ∏è Blur Background",
              prompt: "Blur the background softly to emphasise the subject"),
        .init(name: "üåà Vibrant Colours",
              prompt: "Enhance all colours for a vivid, saturated look while preserving skin tones"),
        .init(name: "ü™Ñ Magic Retouch",
              prompt: "Subtly smooth skin and reduce blemishes for a polished finish"),
        .init(name: "‚ú® Highlight Pop",
              prompt: "Increase highlights and contrast to make the subject stand out"),
        .init(name: "üóëÔ∏è Object Eraser",
                  prompt: "Erase distracting items while keeping the main subject crisp"),

            // 2. Body tuning
            .init(name: "üèãÔ∏è‚Äç‚ôÇÔ∏è Body Sculpt",
                  prompt: "Subtly reshape and refine body contours for a balanced, natural look"),

            // 3. Face retouch
            .init(name: "üíÜ‚Äç‚ôÄÔ∏è Face Refine",
                  prompt: "Smooth skin and adjust facial features while preserving authenticity"),

            // 4. Teeth correction
            .init(name: "üòÅ Bright Smile",
                  prompt: "Whiten and perfect teeth for a confident, natural-looking grin"),

            // 5. Background removal
            .init(name: "‚úÇÔ∏è Cut-Out",
                  prompt: "Remove the background entirely, delivering a clean transparent PNG"),

            // 6. Wrinkle removal
            .init(name: "üß¥ Smooth Lines",
                  prompt: "Reduce wrinkles and fine lines for a refreshed appearance"),

            // 7. AI weight loss
            .init(name: "‚öñÔ∏è Slim Fit",
                  prompt: "Trim the silhouette realistically for a slimmer profile"),

            // 8. AI Auto elegance
            .init(name: "‚ú® Auto Elegance",
                  prompt: "Automatically balance tone, lighting, and colour for an upscale finish"),

            // 9. AI Hair ‚Äì haircut, colouring, restoration
            .init(name: "üíá‚Äç‚ôÄÔ∏è Hair Studio",
                  prompt: "Preview new haircuts, colours, or fuller volume with lifelike results"),

            // 10. HD Portrait
            .init(name: "üì∏ HD Portrait",
                  prompt: "Enhance portrait clarity and detail to high-definition quality"),

            // 11. One-touch makeup
            .init(name: "üíÑ Insta Makeup",
                  prompt: "Apply natural-looking makeup instantly, matched to skin tone"),

            // 12. 3D beauty
            .init(name: "üåÄ 3D Glam",
                  prompt: "Add subtle depth and contour for a dimensional beauty effect"),

            // 13. Hi-res
            .init(name: "üîç Upscale 4K",
                  prompt: "Increase resolution up to 4K while preserving sharpness and detail"),

            // 14. Hair volumes
            .init(name: "üåü Volume Boost",
                  prompt: "Add fullness and body to hair for a luxuriously voluminous style"),

            // 15. Beauty filters
            .init(name: "üéûÔ∏è Beauty Film",
                  prompt: "Apply a soft cinematic filter for an instant glow"),

            // 16. Face tools
            .init(name: "üõ†Ô∏è Face Toolkit",
                  prompt: "Precisely adjust eyes, nose, lips and more with intuitive sliders")

    ]

    // MARK: ‚Äî Data for grid sections
    private let bodyShapeItems: [(title: String, icon: String)] = [
        ("Chest Curve",   "Chest"),
        ("Flat Abs",      "Belly"),
        ("Buttocks+",     "Buttock"),
        ("Slim Waist",    "Waist"),
        ("Legs",          "Legs"),
        ("Muscles",       "Muscle")
    ]

    private let facialItems: [(title: String, icon: String)] = [
        ("Face",          "Face"),
        ("Eyes",          "Eyes"),
        ("Nose",          "Nose"),
        ("Lips",          "Lips"),
        ("Skin",          "Skin")
    ]

    private let hairAccessoryItems: [(title: String, icon: String)] = [
        ("Hair",          "Hair"),
        ("Jewellery",     "jewellery"),
        ("Eyewear",       "Eyewear")
    ]

    // Three flexible columns
    private let columns = Array(
        repeating: GridItem(.flexible(), spacing: 16),
        count: 3
    )

    var body: some View {
        NavigationView {
            ScrollView {
                VStack(alignment: .leading, spacing: 32) {
                    // MARK: ‚Äî Header
                    HStack {
                        Text("BodyEditor Ai")
                            .font(.largeTitle)
                            .fontWeight(.bold)
                            .foregroundStyle(
                                LinearGradient(
                                    gradient: Gradient(colors: [Color.pink, Color.orange]),
                                    startPoint: .leading,
                                    endPoint: .trailing
                                )
                            )
                        Spacer()
                    }
                    .padding(.horizontal)

                    // MARK: ‚Äî Prompt Panel
                    HorizontalPromptScroll(items: promptItems)
                        .padding(.top, 4)

                    // MARK: ‚Äî Body Shape Section
                    SectionGrid(
                        title: "Body Shape",
                        items: bodyShapeItems,
                        columns: columns
                    )

                    // MARK: ‚Äî Facial Section
                    SectionGrid(
                        title: "Facial",
                        items: facialItems,
                        columns: columns
                    )

                    // MARK: ‚Äî Hair & Accessories Section
                    SectionGrid(
                        title: "Hair & Accessories",
                        items: hairAccessoryItems,
                        columns: columns
                    )
                }
                .padding(.vertical)
            }
            .background(Color(red: 0.14, green: 0.13, blue: 0.13).edgesIgnoringSafeArea(.all))
            .navigationBarHidden(true)
        }
    }
}

// MARK: ‚Äî Section Grid (unchanged)
private struct SectionGrid: View {
    let title: String
    let items: [(title: String, icon: String)]
    let columns: [GridItem]

    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text(title)
                .font(.headline)
                .foregroundColor(.white)
                .padding(.horizontal)

            LazyVGrid(columns: columns, alignment: .leading, spacing: 16) {
                ForEach(items, id: \ .title) { item in
                    NavigationLink(
                        destination: GenView(section: item.icon)
                    ) {
                        VStack(spacing: 8) {
                            // Circular icon background
                            ZStack {
                                RoundedRectangle(cornerRadius: 18)
                                    .fill(Color.black.opacity(0.6))
                                    .frame(width: 70, height: 70)
                                    .shadow(color: Color.white.opacity(0.2),
                                            radius: 6,
                                            x: 0,
                                            y: 0)

                                Image(item.icon)
                                    .resizable()
                                    .aspectRatio(contentMode: .fit)
                                    .frame(width: 50, height: 50)
                            }

                            Text(item.title)
                                .font(.caption)
                                .multilineTextAlignment(.center)
                                .foregroundColor(.white)
                        }
                        .frame(maxWidth: .infinity)
                    }
                }
            }
            .padding(.horizontal)
        }
    }
}

struct CatalogView_Previews: PreviewProvider {
    static var previews: some View {
        CatalogView()
            .preferredColorScheme(.dark)
    }
}
import SwiftUI

// MARK: - Prompt model --------------------------------------------------------
struct PromptItem: Identifiable {
    let id = UUID()
    let name: String    // Emoji‚Äëprefixed label shown in the pill
    let prompt: String  // Full prompt passed to GenView
}

// MARK: - Two‚Äërow, horizontally scrolling prompt panel -----------------------
struct HorizontalPromptScroll: View {
    let items: [PromptItem]

    // Two fixed‚Äëheight rows stacked vertically inside a horizontally scrolling grid
    private let rows = [
        GridItem(.fixed(48), spacing: 12),
        GridItem(.fixed(48))
    ]

    var body: some View {
        ScrollView(.horizontal, showsIndicators: false) {
            LazyHGrid(rows: rows, alignment: .center, spacing: 16) {
                ForEach(items) { item in
                    NavigationLink(destination: GenView(section: item.prompt)) {
                        PromptTag(text: item.name)
                    }
                }
            }
            .padding(.horizontal, 16)
            .padding(.vertical, 8)
        }
        .background(Color.clear)
    }
}

// MARK: - Single prompt pill --------------------------------------------------
private struct PromptTag: View {
    let text: String

    var body: some View {
        Text(text)
            .font(.subheadline.weight(.semibold))
            .foregroundColor(.white)
            .padding(.vertical, 10)
            .padding(.horizontal, 20)
            .background(
                RoundedRectangle(cornerRadius: 24)
                    .fill(Color.black.opacity(0.55))
            )
    }
}
//
//  WeeklyPaywallView.swift
//  HairStyle
//

import SwiftUI
import StoreKit

struct WeeklyPaywallView: View {
    
    // MARK: ‚Äì Dependencies
    @EnvironmentObject private var manager: SubscriptionManager
    
    // MARK: ‚Äì Inputs
    var thumbs: [ThumbItem] = []            // OPTIONAL ‚Äì default empty
    let onUnlock: () -> Void
    let onClose:  () -> Void
    
    // MARK: ‚Äì Local state
    @State private var closeDisabled = true
    @State private var currentPage   = 0
    @State private var bounceOffset: CGFloat  = 0
    @State private var hasBounced    = false
    @State private var buttonScale:  CGFloat  = 1
    
    // MARK: ‚Äì Derived
    private var weeklyProduct: Product? {
        manager.subscriptions.first { $0.id == "weeksub" }
    }
    private var imageSize: CGFloat { UIScreen.main.bounds.width * 0.7 }
    
    // MARK: ‚Äì Body
    var body: some View {
        ZStack(alignment: .topLeading) {
            background
            closeButton
            content
        }
        .onAppear(perform: configureAnimations)
    }
}

// MARK: - Sub-views
private extension WeeklyPaywallView {
    
    var background: some View {
        LinearGradient(
            colors: [
                Color(red: 1, green: 0.95, blue: 0.96),
                Color(red: 1, green: 0.87, blue: 0.90)
            ],
            startPoint: .top,
            endPoint: .bottom
        )
        .ignoresSafeArea()
    }
    
    var closeButton: some View {
        Button(action: onClose) {
            Image(systemName: "xmark")
                .font(.system(size: 15, weight: .medium))
                .foregroundColor(.black)
                .opacity(closeDisabled ? 0.3 : 0.6)
                .padding(24)
        }
        .disabled(closeDisabled)
    }
    
    var content: some View {
        VStack(spacing: 24) {
            Spacer().frame(height: 60)
            
            // MARK: ‚Äî Headline (no truncation)
            Text("GET YOUR DREAM APPEARANCE!")
                .font(.largeTitle).bold()
                .foregroundColor(.black)
                .multilineTextAlignment(.center)
                .fixedSize(horizontal: false, vertical: true)

            Text("Proven to help you transform your beauty routine.")
                .font(.subheadline)
                .foregroundColor(.gray)
                .multilineTextAlignment(.center)
                .fixedSize(horizontal: false, vertical: true)
                .padding(.horizontal, 32)

            // MARK: ‚Äî Carousel & Dots
            Text("Reveal what you'll look like üëÄ")
                .font(.headline)
                .foregroundColor(.black)
            
            if !thumbs.isEmpty { carouselSection }
            
            Text("1,000,000+ beauty upgrades created")
                .font(.caption)
                .foregroundColor(.gray)
            
            unlockButton
                .padding(.horizontal, 32)
            
            renewalInfo
            
            Spacer()
            
            footer
                .padding(.horizontal, 32)
            
            Spacer(minLength: 20)
        }
    }
    
    // ---------- optional carousel ----------
    @ViewBuilder
    var carouselSection: some View {
        
        TabView(selection: $currentPage) {
            ForEach(thumbs.indices, id: \.self) { idx in
                if let ui = thumbs[idx].image {
                    Image(uiImage: ui)
                        .resizable()
                        .scaledToFill()
                        .frame(width: imageSize, height: imageSize)
                        .blur(radius: 6.5)
                        .clipShape(RoundedRectangle(cornerRadius: 16))
                        .overlay(
                            RoundedRectangle(cornerRadius: 16)
                                .stroke(Color.white.opacity(0.6), lineWidth: 4)
                        )
                        .offset(x: idx == 0 ? bounceOffset : 0)
                        .tag(idx)
                }
            }
        }
        .tabViewStyle(.page(indexDisplayMode: .never))
        .frame(height: imageSize)
        
        HStack(spacing: 8) {
            ForEach(0..<thumbs.count, id: \.self) { d in
                Circle()
                    .frame(width: 8, height: 8)
                    .foregroundColor(d == currentPage ? .black : .gray)
            }
        }
    }
    
    // ---------- CTA ----------
    var unlockButton: some View {
        Button(action: purchase) {
            Text("Unlock Now")
                .font(.title3.bold())
                .frame(maxWidth: .infinity)
                .padding(.vertical, 16)
                .background(Color.white)
                .cornerRadius(30)
                .foregroundColor(.black)              // always black
                .shadow(color: .black.opacity(0.1), radius: 4, y: 2)
        }
        .disabled(weeklyProduct == nil)
        .scaleEffect(buttonScale)
    }
    
    var renewalInfo: some View {
        (Text("Renews Weekly at ")
         + Text(weeklyProduct?.displayPrice ?? "‚Äì")
            .bold()
            .foregroundColor(.black))
        .font(.callout)
        .foregroundColor(.gray)
    }
    
    var footer: some View {
        HStack {
            Button("Terms of Use") { openURL("https://active-outcome.vercel.app/beautyCam") }
            Spacer()
            Button("Restore Purchase") { Task { await restore() } }
            Spacer()
            Button("Privacy Policy") { openURL("https://active-outcome.vercel.app/beautyCam") }
        }
        .font(.footnote)
        .foregroundColor(.gray)
    }
}

// MARK: - Logic
private extension WeeklyPaywallView {
    
    func configureAnimations() {
        // unlock √ó after 9 s
        DispatchQueue.main.asyncAfter(deadline: .now() + 9) {
            withAnimation { closeDisabled = false }
        }
        
        // carousel nudge
        if !thumbs.isEmpty && !hasBounced {
            hasBounced = true
            DispatchQueue.main.asyncAfter(deadline: .now() + 3) {
                withAnimation(.easeInOut(duration: 0.28)) { bounceOffset = -16 }
                DispatchQueue.main.asyncAfter(deadline: .now() + 0.28) {
                    withAnimation(.interpolatingSpring(stiffness: 220, damping: 18)) { bounceOffset = 0 }
                }
            }
        }
        
        // CTA pulse
        DispatchQueue.main.asyncAfter(deadline: .now() + 7) {
            withAnimation(.easeInOut(duration: 0.4)) { buttonScale = 1.1 }
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.4) {
                withAnimation(.easeInOut(duration: 0.4)) { buttonScale = 1.0 }
            }
        }
    }
    
    func purchase() {
        guard let p = weeklyProduct else { return }
        Task {
            if (try? await manager.purchase(p)) != nil { onUnlock() }
        }
    }
    
    func restore() async {
        for await v in Transaction.currentEntitlements {
            if case let .verified(t) = v, t.productID == "weeksub" { onUnlock(); break }
        }
    }
    
    func openURL(_ s: String) {
        guard let url = URL(string: s) else { return }
        UIApplication.shared.open(url)
    }
}
import SwiftUI
import Photos
import StoreKit

struct OnboardingView: View {
    @AppStorage("hasCompletedOnboarding") var hasCompletedOnboarding: Bool = false
    @AppStorage("isPremium") var isPremium: Bool = false
    
    @State private var currentPage = 0
    private let totalPages = 6

    var body: some View {
        TabView(selection: $currentPage) {
            // Page 1: Review Prompt (moved to first)
            ReviewPromptPageView(onContinue: { currentPage = 1 })
                .tag(0)
            
            // Page 2: Benefit 1
            OnboardingPageView(imageName: "star.fill",
                               title: "Amazing Features",
                               description: "Discover advanced AI editing to bring out your best self.",
                               onContinue: { currentPage = 2 })
                .tag(1)
            
            // Page 3: Benefit 2
            OnboardingPageView(imageName: "sparkles",
                               title: "Effortless Beauty",
                               description: "Instantly enhance your selfies with just a tap.",
                               onContinue: { currentPage = 3 })
                .tag(2)
            
            // Page 4: Benefit 3
            OnboardingPageView(imageName: "heart.fill",
                               title: "Share Your Style",
                               description: "Create stunning images and share your unique look with friends.",
                               onContinue: { currentPage = 4 })
                .tag(3)
            
            // Page 5: Photo Library Permission
            PhotoLibraryPermissionPageView(onContinue: { currentPage = 5 })
                .tag(4)
            
            // Page 6: Paywall
            PaywallPageView(isPremium: $isPremium, onComplete: completeOnboarding)
                .tag(5)
        }
        .tabViewStyle(PageTabViewStyle(indexDisplayMode: .never))
    }
    
    private func completeOnboarding() {
        hasCompletedOnboarding = true
    }
}

struct OnboardingPageView: View {
    let imageName: String
    let title: String
    let description: String
    let onContinue: () -> Void
    
    var body: some View {
        VStack(spacing: 20) {
            Spacer()
            Image(systemName: imageName)
                .resizable()
                .scaledToFit()
                .frame(width: 120, height: 120)
                .foregroundColor(.blue)
            Text(title)
                .font(.largeTitle)
                .fontWeight(.bold)
            Text(description)
                .font(.title3)
                .multilineTextAlignment(.center)
                .padding(.horizontal)
            Spacer()
            Button(action: onContinue) {
                Text("Continue")
                    .foregroundColor(.white)
                    .padding()
                    .frame(maxWidth: .infinity)
                    .background(Color.blue)
                    .cornerRadius(8)
            }
            .padding(.horizontal)
        }
    }
}

struct PhotoLibraryPermissionPageView: View {
    @State private var permissionGranted = false
    let onContinue: () -> Void

    var body: some View {
        VStack(spacing: 20) {
            Spacer()
            Image(systemName: "photo.on.rectangle.angled")
                .resizable()
                .scaledToFit()
                .frame(width: 120, height: 120)
                .foregroundColor(permissionGranted ? .green : .orange)
            Text("Photo Library Access")
                .font(.largeTitle)
                .fontWeight(.bold)
            Text("We need permission to save your edited photos to your library.")
                .font(.title3)
                .multilineTextAlignment(.center)
                .padding(.horizontal)
            Button(action: {
                PHPhotoLibrary.requestAuthorization(for: .addOnly) { status in
                    DispatchQueue.main.async {
                        permissionGranted = (status == .authorized || status == .limited)
                    }
                }
            }) {
                Text(permissionGranted ? "Permission Granted" : "Grant Photo Library Access")
                    .foregroundColor(.white)
                    .padding()
                    .frame(maxWidth: .infinity)
                    .background(permissionGranted ? Color.green : Color.blue)
                    .cornerRadius(8)
            }
            .padding(.horizontal)
            Spacer()
            Button(action: onContinue) {
                Text("Continue")
                    .foregroundColor(.white)
                    .padding()
                    .frame(maxWidth: .infinity)
                    .background(Color.blue)
                    .cornerRadius(8)
            }
            .padding(.horizontal)
        }
    }
}

struct ReviewPromptPageView: View {
    let onContinue: () -> Void

    var body: some View {
        VStack(spacing: 20) {
            Spacer()
            Image(systemName: "hand.thumbsup.fill")
                .resizable()
                .scaledToFit()
                .frame(width: 120, height: 120)
                .foregroundColor(.purple)
            Text("Enjoying the App?")
                .font(.largeTitle)
                .fontWeight(.bold)
            Text("We‚Äôd love to hear your feedback. Please take a moment to rate us!")
                .font(.title3)
                .multilineTextAlignment(.center)
                .padding(.horizontal)
            Button(action: {
                if let scene = UIApplication.shared.connectedScenes.first as? UIWindowScene {
                    SKStoreReviewController.requestReview(in: scene)
                }
            }) {
                Text("Rate Now")
                    .foregroundColor(.white)
                    .padding()
                    .frame(maxWidth: .infinity)
                    .background(Color.purple)
                    .cornerRadius(8)
            }
            .padding(.horizontal)
            Spacer()
            Button(action: onContinue) {
                Text("Continue")
                    .foregroundColor(.white)
                    .padding()
                    .frame(maxWidth: .infinity)
                    .background(Color.purple)
                    .cornerRadius(8)
            }
            .padding(.horizontal)
        }
    }
}
//
//  PaywallPageView.swift
//  HairStyle
//

import SwiftUI
import StoreKit

struct PaywallPageView: View {

    @EnvironmentObject private var subscriptionManager: SubscriptionManager
    @Binding var isPremium: Bool
    let onComplete: () -> Void

    @State private var buttonScale: CGFloat = 1
    @State private var notNowLocked     = true

    // Detect iPad once, reuse
    private let isPad = UIDevice.current.userInterfaceIdiom == .pad

    // MARK: ‚Äì StoreKit
    private var weeklyProduct: Product? {
        subscriptionManager.subscriptions.first { $0.id == "weeksub" }
        ?? subscriptionManager.subscriptions.first
    }

    // MARK: ‚Äì Copy
    private let perks: [(String,String)] = [
        ("ü§≥", "AI Photo Retake ‚Äì perfect every snap"),
        ("üî•", "Body Tuner for true confidence"),
        ("‚ú®", "Instant Skin Retouch & Glow"),
        ("üßΩ", "Erase unwanted objects"),
        ("üíé", "4 K HD exports, watermark-free")
    ]

    // MARK: ‚Äì Body
    var body: some View {
        ZStack {
            // ‚îÄ‚îÄ‚îÄ Background (darker on iPad) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            LinearGradient(
                colors: isPad
                    ? [Color(red:0.90,green:0.55,blue:0.65),
                       Color(red:0.82,green:0.35,blue:0.52)]
                    : [Color(red:1,green:0.95,blue:0.96),
                       Color(red:1,green:0.87,blue:0.90)],
                startPoint: .top, endPoint: .bottom
            )
            .ignoresSafeArea()

            // ‚îÄ‚îÄ‚îÄ Main stack ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            VStack(spacing: isPad ? 40 : 28) {

                Spacer().frame(height: isPad ? 120 : 72)

                // Headline
                Text("Unlock Your Best Look\nToday")
                    .font(isPad ? .system(size:50, weight:.heavy)
                                 : .largeTitle.bold())
                    .foregroundColor(.white)
                    .multilineTextAlignment(.center)

                // Perks card
                VStack(alignment:.leading, spacing:isPad ? 18 : 12) {
                    ForEach(perks, id:\.1) { em, txt in
                        HStack(spacing:12) { Text(em); Text(txt) }
                    }
                }
                .font(isPad ? .title3.weight(.semibold)
                            : .callout.weight(.semibold))
                .foregroundColor(.white)
                .padding(isPad ? 30 : 20)
                .background(.black.opacity(0.3))
                .cornerRadius(24)
                .frame(maxWidth: isPad ? 520 : .infinity)
                .padding(.horizontal,isPad ? 0 : 32)

                // Free-trial badge
                Text("3-Day **FREE** Trial ‚Äì cancel anytime")
                    .font(isPad ? .callout.weight(.medium) : .footnote.weight(.medium))
                    .foregroundColor(.white.opacity(0.9))
                    .padding(.horizontal,24)
                    .padding(.vertical,8)
                    .background(Color.white.opacity(0.18))
                    .cornerRadius(16)

                Spacer()

                // Bottom panel
                bottomPanel
                    .frame(maxWidth: isPad ? 600 : .infinity)
                    .padding(.horizontal,isPad ? 0 : 32)
                    .padding(.bottom,isPad ? 60 : 40)
            }
        }
        .onAppear {
            schedulePulse()
            DispatchQueue.main.asyncAfter(deadline: .now()+8) {
                withAnimation { notNowLocked = false }
            }
        }
    }
}

// MARK: ‚Äì Bottom panel
private extension PaywallPageView {

    var bottomPanel: some View {
        VStack(spacing:isPad ? 22 : 16) {

            // CTA
            Button(action: purchase) {
                Text("Start Free Trial")
                    .font(isPad ? .title3.weight(.semibold) : .headline)
                    .foregroundColor(.white)
                    .frame(maxWidth:.infinity)
                    .frame(height:isPad ? 56 : 48)
            }
            .buttonStyle(.plain)
            .background(.ultraThinMaterial)
            .cornerRadius(isPad ? 28 : 24)
            .shadow(color:.black.opacity(0.3), radius:10, y:5)
            .disabled(weeklyProduct == nil)
            .scaleEffect(buttonScale)

            // Renewal price
            if let price = weeklyProduct?.displayPrice {
                (Text("Then ") + Text(price).bold() + Text(" / week, cancel anytime"))
                    .font(.footnote)
                    .foregroundColor(.white.opacity(0.9))
            }

            // Links
            HStack {
                Button("Terms")   { openURL("https://example.com/terms") }
                Spacer()
                Button("Restore") { Task { await restore() } }
                Spacer()
                Button("Privacy") { openURL("https://example.com/privacy") }
            }
            .font(.footnote)
            .foregroundColor(.white.opacity(0.85))

            // Not-now
            Button("Not Now", action: onComplete)
                .font(.footnote)
                .foregroundColor(.white)
                .opacity(notNowLocked ? 0.3 : 1)
                .disabled(notNowLocked)
        }
        .padding(isPad ? 28 : 20)
        .background(.regularMaterial)          // stronger blur on iPad
        .cornerRadius(isPad ? 32 : 28)
        .shadow(color:.black.opacity(0.35), radius:14, y:6)
    }
}

// MARK: ‚Äì Logic
private extension PaywallPageView {

    func schedulePulse() {
        DispatchQueue.main.asyncAfter(deadline:.now()+7) {
            withAnimation(.easeInOut(duration:0.4)) { buttonScale = 1.1 }
            DispatchQueue.main.asyncAfter(deadline:.now()+0.4) {
                withAnimation(.easeInOut(duration:0.4)) { buttonScale = 1.0 }
            }
        }
    }

    func purchase() {
        guard let product = weeklyProduct else { return }
        Task {
            if let _ = try? await subscriptionManager.purchase(product) {
                isPremium = true
                onComplete()
            }
        }
    }

    func restore() async {
        for await ent in Transaction.currentEntitlements {
            if case let .verified(t) = ent, t.productID == weeklyProduct?.id {
                isPremium = true
                onComplete()
                break
            }
        }
    }

    func openURL(_ s:String) {
        guard let url = URL(string:s) else { return }
        UIApplication.shared.open(url)
    }
}
//
//  SubscriptionManager.swift
//  HairStyle
//

import StoreKit
import SwiftUI

@MainActor
final class SubscriptionManager: ObservableObject {
    
    // MARK:  Published
    @Published var subscriptions: [Product]          = []
    @Published var purchasedIdentifiers: Set<String> = []
    
    /// Optional thumbnails the paywall can show on first launch.
    /// `ThumbItem` is already declared in **GenView.swift**, so we just
    /// reference it here‚Äîno second definition!
    let previewThumbs: [ThumbItem] = []          // ‚Üê keep empty or fill later
    
    // üëá NEW ‚Äì counter for free users (persists in UserDefaults)
    @Published private(set) var freeGenerationsUsed: Int {
        didSet { UserDefaults.standard.set(freeGenerationsUsed,
                                           forKey: "freeGenerationsUsed") }
    }
    let freeGenerationLimit = 1          // change here if you want 2, 3, ‚Ä¶

    
    // MARK:  Private
    private let productIDs = ["weeksub"]
    private var updateTask: Task<Void, Never>?
    
    
    // MARK:  Init -------------------------------------------------------------
    init() {
        // NEW ‚Äì restore counter before anything else
        freeGenerationsUsed = UserDefaults.standard
            .integer(forKey: "freeGenerationsUsed")
        
        updateTask = listenForTransactions()
        Task {
            await requestProducts()
            await refreshEntitlements()
        }
    }
}

// MARK: ‚Äì StoreKit helpers
extension SubscriptionManager {
    
    /// `true` if the user owns `"weeksub"`
    var isSubscribed: Bool {
        purchasedIdentifiers.contains("weeksub")
    }
    
    /// `true` ‚Üí *one more* Gemini request is allowed.
    var canGenerate: Bool {
        isSubscribed || freeGenerationsUsed < freeGenerationLimit
    }
    
    /// Call once after *each* successful generation for a **free** user.
    func markGenerationUsed() {
        guard !isSubscribed else { return }
        freeGenerationsUsed += 1
    }
    func requestProducts() async {
        do {
            subscriptions = try await Product.products(for: productIDs)
        } catch {
            print("‚ùå StoreKit product request failed:", error)
        }
    }
    
    private func listenForTransactions() -> Task<Void, Never> {
        Task.detached { [weak self] in
            guard let self else { return }
            for await update in Transaction.updates {
                if let tx = try? await self.verified(update) {
                    await self.refreshEntitlements()
                    await tx.finish()
                }
            }
        }
    }
    
    private func refreshEntitlements() async {
        purchasedIdentifiers.removeAll()
        for await vr in Transaction.currentEntitlements {
            if let tx = try? verified(vr) {
                purchasedIdentifiers.insert(tx.productID)
            }
        }
    }
    
    func purchase(_ product: Product) async throws -> StoreKit.Transaction? {
        switch try await product.purchase() {
        case .success(let vr):
            let tx = try verified(vr)
            await tx.finish()
            await refreshEntitlements()
            return tx
        case .userCancelled, .pending: return nil
        @unknown default:              return nil
        }
    }
    
    // Helper to unwrap verified transactions / results
    private func verified<T>(_ vr: VerificationResult<T>) throws -> T {
        switch vr {
        case .verified(let val): return val
        case .unverified:        throw StoreError.failedVerification
        }
    }
    
    enum StoreError: Error { case failedVerification }
}
import SwiftUI
import Vision
import CoreML
import CoreImage
import UIKit
import os


// MARK: - ImageEditingViewModel
class ImageEditingViewModel: ObservableObject {
    // MARK: - Published Properties
    @Published var prompt: String = ""
    @Published var editedImage: UIImage? = nil
    @Published var textResult: String = ""
    @Published var isLoading: Bool = false
    @Published var errorMessage: String = ""
    @Published var showPremiumAlert: Bool = false
    @Published var depthMapImage: UIImage? = nil  // Holds the generated depth map image
    
    // Depth model property
    //var model: DepthAnythingV2SmallF16?
    
    // Proxy endpoint for your Gemini API key.
    let apiURL = URL(string: "https://gemini-proxy-flame.vercel.app/api/gemini2")! // earlier was https://gemini-proxy-flame.vercel.app/api/gemini
    
    // Define the target size expected by the model.
    private let targetSize = CGSize(width: 518, height: 392)
    
    // Shared CIContext instance.
    private let ciContext = CIContext()
    
    
    // New property: Public sharing checkbox state (default true)
    @Published var isPublicSharing: Bool = true
    
    // MARK: - Depth Model Loading & Depth Map Generation
    
    /// Loads your depth removal model.
    func loadModel() async throws {
        let config = MLModelConfiguration()
        config.computeUnits = .cpuOnly
       // model = try DepthAnythingV2SmallF16(configuration: config)
    }
    
    /*
    func generateDepthMap(for image: UIImage) async {
        // Ensure the model is loaded.
        guard let depthModel = model else {
            await MainActor.run { self.errorMessage = "Model not loaded." }
            return
        }
        
        // Create a resized pixel buffer (518 x 392) using the helper extension.
        guard let resizedBuffer = image.resizedPixelBuffer(width: Int(targetSize.width), height: Int(targetSize.height)) else {
            await MainActor.run { self.errorMessage = "Failed to create resized pixel buffer." }
            return
        }
        
        // Debug: confirm the pixel buffer size.
        let w = CVPixelBufferGetWidth(resizedBuffer)
        let h = CVPixelBufferGetHeight(resizedBuffer)
        print("Pixel buffer is \(w)x\(h)")  // Should be 518x392
        
        do {
            // Run model inference synchronously.
            let prediction = try depthModel.prediction(image: resizedBuffer)
            let depthBuffer = prediction.depth
            let depthCI = CIImage(cvPixelBuffer: depthBuffer)
            
            if let cgImage = ciContext.createCGImage(depthCI, from: depthCI.extent) {
                let finalUIImage = UIImage(cgImage: cgImage)
                await MainActor.run {
                    self.depthMapImage = finalUIImage
                    print("Depth map generation successful")
                }
            }
        } catch {
            await MainActor.run {
                self.errorMessage = "Depth model error: \(error.localizedDescription)"
            }
        }
    }

    */
    
    func editImage() {
        guard let image = editedImage,
              let imageData = image.jpegData(compressionQuality: 0.8)?.base64EncodedString() else {
            DispatchQueue.main.async {
                self.isLoading = false
                self.errorMessage = "No valid image selected"
            }
            return
        }
        
        isLoading = true
        errorMessage = ""
        textResult = ""
        
        let payload: [String: Any] = [
            "prompt": prompt,
            "image": imageData
        ]
        
        guard let jsonData = try? JSONSerialization.data(withJSONObject: payload) else {
            DispatchQueue.main.async {
                self.isLoading = false
                self.errorMessage = "Failed to serialize request"
            }
            return
        }
        
        var request = URLRequest(url: apiURL)
        request.httpMethod = "POST"
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")
        request.httpBody = jsonData
        
        URLSession.shared.dataTask(with: request) { [weak self] data, response, error in
            guard let self = self else { return }
            
            DispatchQueue.main.async { self.isLoading = false }
            
            if let error = error {
                DispatchQueue.main.async {
                    self.errorMessage = "Network error: \(error.localizedDescription)"
                }
                return
            }
            
            guard let data = data else {
                DispatchQueue.main.async {
                    self.errorMessage = "No data received from server"
                }
                return
            }
            
            do {
                if let jsonResponse = try JSONSerialization.jsonObject(with: data) as? [String: Any] {
                    // (Handle API error responses)
                    if let errorDict = jsonResponse["error"] as? [String: Any] {
                        let errorMessage = (errorDict["message"] as? String) ?? "Unknown error"
                        DispatchQueue.main.async {
                            self.errorMessage = "API Error: \(errorMessage)"
                        }
                        return
                    }
                    
                    // Process text and inline data responses
                    if let candidates = jsonResponse["candidates"] as? [[String: Any]],
                       let candidate = candidates.first,
                       let content = candidate["content"] as? [String: Any],
                       let parts = content["parts"] as? [[String: Any]] {
                        
                        for part in parts {
                            if let text = part["text"] as? String {
                                DispatchQueue.main.async {
                                    self.textResult += text
                                }
                            }
                            
                            if let inlineData = part["inlineData"] as? [String: Any],
                               let dataString = inlineData["data"] as? String,
                               let imageData = Data(base64Encoded: dataString),
                               let image = UIImage(data: imageData) {
                                
                                DispatchQueue.main.async {
                                    self.editedImage = image
                                }
                                
                                // Only share publicly if the toggle is on.
                             /*   if self.isPublicSharing {
                                    CloudinaryManager.upload(image: image) { secureUrl in
                                        if let url = secureUrl {
                                            print("Image uploaded to Cloudinary: \(url)")
                                            // Optionally: save the URL for your feed if needed.
                                        }
                                    }
                                }*/
                            }
                        }
                    } else {
                        let responseString = String(data: data, encoding: .utf8) ?? "Unable to parse response"
                        DispatchQueue.main.async {
                            self.textResult = "Response: \(responseString)"
                        }
                    }
                }
            } catch {
                DispatchQueue.main.async {
                    self.errorMessage = "Failed to parse response: \(error.localizedDescription)"
                    self.textResult = String(data: data, encoding: .utf8) ?? "Unable to display response"
                }
            }
        }.resume()
    }

    
    
    
}
//
//  Transformation.swift
//  HairStyle
//
//  Created by adam on 12/05/2025.
//


//
//  Transformations.swift
//

import Foundation

/// One transformation shown in onboarding (3 total for now)
struct Transformation: Identifiable {
    let id = UUID()
    let beforeImageName: String   // asset name for ‚Äúbefore‚Äù photo
    let afterImageName: String    // asset name for ‚Äúafter‚Äù photo
    let caption: String           // TikTok-style text under the image
}
/// Nine sample transformations for onboarding
let onboardingTransformations: [Transformation] = [

    Transformation(
        beforeImageName: "remove_before",
        afterImageName:  "remove_after",
        caption: "Clutter? Poof‚Äîgone üóëÔ∏è‚ú®"
    ),

    Transformation(
        beforeImageName: "pro_before",
        afterImageName:  "pro_after",
        caption: "Corporate glow-up in 1 tap üíº"
    ),

    Transformation(
        beforeImageName: "body_before",
        afterImageName:  "body_after",
        caption: "Beach-bod confidence üèñÔ∏èüî•"
    ),

    Transformation(
        beforeImageName: "hug_before",
        afterImageName:  "hug_after",
        caption: "Selfie + wild hug = viral üêªü§ó"
    ),

    Transformation(
        beforeImageName: "classy_before",
        afterImageName:  "classy_after",
        caption: "Bond vibes on the Riviera ü§µüèñÔ∏è"
    ),

   /* Transformation(
        beforeImageName: "fix_before",
        afterImageName:  "fix_after",
        caption: "Saved that blurry memory üõ†Ô∏èüì∏"
    ),*/

    Transformation(
        beforeImageName: "hair_before",
        afterImageName:  "hair_after",
        caption: "Big-hair energy üíá‚Äç‚ôÄÔ∏èüöÄ"
    ),

    Transformation(
        beforeImageName: "smile_before",
        afterImageName:  "smile_after",
        caption: "Turn that grin on üòÅ"
    ),

    Transformation(
        beforeImageName: "phone_before",
        afterImageName:  "phone_after",
        caption: "Hands-free selfie magic üì±‚úÇÔ∏è"
    )
]

//
//  EnhancementOption.swift
//  HairStyle
//
//  Created by adam on 25/04/2025.
//


//
//  BodyEnhancementPrompts.swift
//  HairStyle
//
//  Created by assistant on 25/04/2025.
//

import Foundation

/// A single enhancement option for a given body area.
struct EnhancementOption: Identifiable, Equatable {
    let id: String             // unique key
    let title: String          // display name
    let subtitle: String?      // optional secondary label (e.g., "Limited-time free")
    let prompt: String         // AI prompt to send
    let isFree: Bool           // whether this option is free
}


enum BodyEnhancementPrompts {
        static let breast: [EnhancementOption] = [
        EnhancementOption(id: "round",               title: "Round",                subtitle: nil,                prompt: "Respectfully enhance chest curvature",                                             isFree: true),
        EnhancementOption(id: "heart_shaped",        title: "Heart‚Äëshaped",        subtitle: "Limited‚Äëtime free", prompt: "Enhance chest into a heart‚Äëshaped bust",                                         isFree: true),
        EnhancementOption(id: "superlift",           title: "Superlift",           subtitle: nil,                prompt: "Apply superlift enhancement to chest",                                           isFree: false),
        EnhancementOption(id: "natural_lift",        title: "Natural Lift",        subtitle: nil,                prompt: "Apply natural lift enhancement to chest",                             isFree: false),
        EnhancementOption(id: "subtle_volume",       title: "Subtle Volume",       subtitle: nil,                prompt: "Respectfully but minimally enhance chest curvature",                           isFree: true),
        EnhancementOption(id: "snatched_cleavage",   title: "Snatched Cleavage",   subtitle: "Limited‚Äëtime free", prompt: "Respectfully but subtly enhance chest curvature",                      isFree: true)
        ]

       // MARK: ‚Äì Belly / Core
       static let belly: [EnhancementOption] = [
           EnhancementOption(id: "flat_abs",            title: "Flat Abs",            subtitle: nil,                prompt: "Respectfully slim and flatten the belly and waist",                               isFree: true),
           EnhancementOption(id: "hourglass",           title: "Hourglass",           subtitle: nil,                prompt: "Respectfully enhance the waist‚Äëto‚Äëhip curve",                                     isFree: false),
           EnhancementOption(id: "defined_abs",         title: "Defined Abs",         subtitle: nil,                prompt: "Respectfully enhance the abdominal abs",                                        isFree: false),
           EnhancementOption(id: "sculpted_core",       title: "Sculpted Core",       subtitle: nil,                prompt: "Respectfully sculpt and refine the core muscles for balance",                   isFree: true),
           EnhancementOption(id: "chiseled_midsection", title: "Chiseled Midsection", subtitle: nil,                prompt: "Respectfully enhance the lines of the midsection abs",                         isFree: false),
           EnhancementOption(id: "snatched_waist",      title: "Snatched Waist",      subtitle: "Limited‚Äëtime free", prompt: "Respectfully cinch the waist for a snatched silhouette",                         isFree: true),
           EnhancementOption(id: "vacuum_slim",         title: "Vacuum Slim",         subtitle: nil,                prompt: "Respectfully apply stomach‚Äëvacuum slimming for a flat profile",                 isFree: false),
           EnhancementOption(id: "core_carve",          title: "Core Carve",          subtitle: nil,                prompt: "Respectfully carve deep core lines for athletic definition",                   isFree: false)
       ]

       // MARK: ‚Äì Buttock / Glutes
       static let buttock: [EnhancementOption] = [
           EnhancementOption(id: "lift",                title: "Lift",                subtitle: nil,                prompt: "Lift and sculpt the buttocks for a firmer look",                              isFree: true),
           EnhancementOption(id: "round",               title: "Round",               subtitle: nil,                prompt: "Enhance roundness for a curvier silhouette",                                   isFree: false),
           EnhancementOption(id: "heart_shaped",        title: "Heart‚Äëshaped",        subtitle: "Limited‚Äëtime free", prompt: "Respectfully reshape glutes into a heart‚Äëshaped form",                          isFree: true),
           EnhancementOption(id: "superlift",           title: "Superlift",           subtitle: nil,                prompt: "Apply superlift enhancement to buttocks for maximum elevation",               isFree: false),
           EnhancementOption(id: "sculpted_glutes",     title: "Sculpted Glutes",     subtitle: nil,                prompt: "Respectfully define and sculpt the glute muscles for a toned look",           isFree: false),
           EnhancementOption(id: "perky",               title: "Perky",               subtitle: nil,                prompt: "Respectfully perk up the buttocks for a youthful, lifted appearance",        isFree: true),
           EnhancementOption(id: "voluminous",          title: "Voluminous",          subtitle: nil,                prompt: "Enhance volume and roundness for fuller, more pronounced glutes",            isFree: false),
           EnhancementOption(id: "peach_lift",          title: "Peach Lift",          subtitle: nil,                prompt: "Respectfully lift glutes for a peach‚Äëemoji vibe üçë",                          isFree: true),
           EnhancementOption(id: "bubble_booty",        title: "Bubble Booty",        subtitle: nil,                prompt: "Respectfully add bubble‚Äëshaped roundness for a playful look",                isFree: false),
           EnhancementOption(id: "brazilian_curve",     title: "Brazilian Curve",     subtitle: "Limited‚Äëtime free", prompt: "Respectfully enhance lower‚Äëupper glute transition for Brazilian shape",       isFree: true),
           EnhancementOption(id: "shape_360",           title: "360 Shape",           subtitle: nil,                prompt: "Respectfully smooth and contour hips & glutes for a 360¬∞ hourglass",         isFree: false)
       ]

       // MARK: ‚Äì Muscle / Arms
       static let muscle: [EnhancementOption] = [
           EnhancementOption(id: "tone",                title: "Upper Body",          subtitle: nil,                prompt: "Respectfully increase the muscle shape on neck and upper body",               isFree: true),
           EnhancementOption(id: "sculpt",              title: "Arms & Forearms",     subtitle: nil,                prompt: "Respectfully enhance the muscle shape on the arms and forearms",            isFree: false),
           EnhancementOption(id: "bicep_peak",          title: "Bicep Peak",          subtitle: nil,                prompt: "Respectfully accentuate the bicep peak for a more pronounced flex",        isFree: false),
           EnhancementOption(id: "tricep_tone",         title: "Tricep Tone",         subtitle: nil,                prompt: "Respectfully slim and tone the triceps for sleek definition",              isFree: true),
           EnhancementOption(id: "vascular_forearms",   title: "Vascular Forearms",   subtitle: "Limited‚Äëtime free", prompt: "Respectfully highlight forearm veins and muscle separation",                  isFree: true),
           EnhancementOption(id: "forearm_definition",  title: "Forearm Definition",  subtitle: nil,                prompt: "Respectfully define the forearm muscles for enhanced detail",              isFree: false),
           EnhancementOption(id: "arm_strength",        title: "Strength Boost",       subtitle: nil,                prompt: "Respectfully add subtle bulk to arms",                                   isFree: false),
           EnhancementOption(id: "swimmer_build",       title: "Swimmer Build",       subtitle: nil,                prompt: "Respectfully broaden shoulders and taper waist for swimmer aesthetics",     isFree: false),
           EnhancementOption(id: "athlete_tone",        title: "Athlete Tone",        subtitle: nil,                prompt: "Respectfully tone arms for an athletic, sporty vibe",                      isFree: true),
           EnhancementOption(id: "power_flex",          title: "Power Flex",          subtitle: "Limited‚Äëtime free", prompt: "Respectfully sharpen muscle definition for a power pose",                     isFree: true)
       ]
    
    // MARK: ‚Äì Waist
    static let waist: [EnhancementOption] = [
        // Existing
        EnhancementOption(id: "slim",             title: "Slim",             subtitle: nil,                prompt: "Slim and cinch the waist",                                                     isFree: true),
        EnhancementOption(id: "curve",            title: "Curve",            subtitle: nil,                prompt: "Enhance waist curves for definition",                                         isFree: false),
        EnhancementOption(id: "v_shape",          title: "V-Shape",          subtitle: nil,                prompt: "Respectfully sculpt a tapered V-shape waist",                                  isFree: false),
        EnhancementOption(id: "corset_cinch",     title: "Corset Cinch",     subtitle: "Limited-time free", prompt: "Respectfully simulate corset-style waist cinching for TikTok snatch",           isFree: true),

        // New additions
        EnhancementOption(id: "hourglass",        title: "Hourglass",        subtitle: nil,                prompt: "Respectfully sculpt an hourglass silhouette",                                  isFree: false),
        EnhancementOption(id: "micro_cinch",      title: "Micro Cinch",      subtitle: "Limited-time free", prompt: "Respectfully simulate an ultra-cinched micro waist",                           isFree: true),
        EnhancementOption(id: "athletic_tone",    title: "Athletic Tone",    subtitle: nil,                prompt: "Define a toned, athletic waistline",                                           isFree: false),
        EnhancementOption(id: "balanced_curve",   title: "Balanced Curve",   subtitle: nil,                prompt: "Add gentle definition for a balanced waist curve",                             isFree: true),
        EnhancementOption(id: "dream_sculpt",     title: "Dream Sculpt",     subtitle: nil,                prompt: "Sculpt a dreamy snatched waistline fit for viral looks",                       isFree: false),
        EnhancementOption(id: "vapor_snatch",     title: "Vapor Snatch",     subtitle: "Limited-time free", prompt: "Respectfully vapor-snatch the waist for an ethereal cinched look",             isFree: true),
        EnhancementOption(id: "soft_taper",       title: "Soft Taper",       subtitle: nil,                prompt: "Create a soft, natural waist taper",                                           isFree: true),
        EnhancementOption(id: "precision_trim",   title: "Precision Trim",   subtitle: nil,                prompt: "Apply precise trimming for a sleek waist contour",                             isFree: false)
    ]


       // MARK: ‚Äì Hair
       static let hair: [EnhancementOption] = [
           EnhancementOption(id: "volume",              title: "Volume",              subtitle: nil,                prompt: "Add natural volume and body to hair",                                    isFree: true),
           EnhancementOption(id: "smooth",              title: "Smooth",              subtitle: nil,                prompt: "Smooth hair and reduce frizz",                                          isFree: false),
           EnhancementOption(id: "silver_blonde",       title: "Silver Blonde",       subtitle: nil,                prompt: "Transform hair to a chic silver blonde shade",                            isFree: true),
           EnhancementOption(id: "bob_cut",             title: "Bob Cut",             subtitle: nil,                prompt: "Give hair a modern bob cut",                                            isFree: false),
           EnhancementOption(id: "afro",                title: "Afro",                subtitle: "Limited‚Äëtime free", prompt: "Define natural afro texture and volume",                                    isFree: true),
           EnhancementOption(id: "pixie_cut",           title: "Pixie Cut",           subtitle: nil,                prompt: "Create a stylish pixie cut",                                           isFree: false),
           EnhancementOption(id: "ombre",               title: "Ombre",               subtitle: nil,                prompt: "Add subtle ombre color blending",                                       isFree: true),
           EnhancementOption(id: "highlights",          title: "Highlights",          subtitle: nil,                prompt: "Incorporate bright highlights throughout hair",                           isFree: false),
           EnhancementOption(id: "balayage",            title: "Balayage",            subtitle: nil,                prompt: "Apply a natural balayage painting technique",                             isFree: false),
           EnhancementOption(id: "loose_curls",         title: "Loose Curls",         subtitle: nil,                prompt: "Add loose, bouncy curls for movement",                                   isFree: true),
           EnhancementOption(id: "beach_waves",         title: "Beach Waves",         subtitle: "Limited‚Äëtime free", prompt: "Create soft, effortless beach waves",                                      isFree: true),
           EnhancementOption(id: "sleek_straight",      title: "Sleek Straight",      subtitle: nil,                prompt: "Smooth hair into a sleek, straight style",                                 isFree: false),
           EnhancementOption(id: "butterfly_layers",    title: "Butterfly Layers",    subtitle: nil,                prompt: "Add TikTok trending butterfly layers for airy movement",                   isFree: true),
           EnhancementOption(id: "curtain_bangs",       title: "Curtain Bangs",       subtitle: nil,                prompt: "Add soft curtain bangs framing the face",                                isFree: false),
           EnhancementOption(id: "mermaid_waves",       title: "Mermaid Waves",       subtitle: "Limited‚Äëtime free", prompt: "Create long, flowing mermaid waves with shine",                              isFree: true),
           EnhancementOption(id: "copper_glow",         title: "Copper Glow",         subtitle: nil,                prompt: "Transform hair to a warm LA‚Äësun copper glow",                              isFree: false),
           EnhancementOption(id: "pastel_pink",         title: "Pastel Pink",         subtitle: nil,                prompt: "Tint hair a playful pastel pink",                                       isFree: false)
       ]
    // MARK: ‚Äì Nose
    static let nose: [EnhancementOption] = [
        // Existing
        EnhancementOption(id: "refine",           title: "Refine",            subtitle: nil,                 prompt: "Refine the nose shape subtly",                                                      isFree: true),
        EnhancementOption(id: "slim",             title: "Slim",              subtitle: nil,                 prompt: "Slim down the nose bridge",                                                        isFree: false),
        EnhancementOption(id: "button_tip",       title: "Button Tip",        subtitle: nil,                 prompt: "Respectfully soften and round the nose tip for a button effect",                  isFree: true),
        EnhancementOption(id: "soft_contour",     title: "Soft Contour",      subtitle: nil,                 prompt: "Respectfully add gentle shadow for a softly contoured nose",                      isFree: false),

        // New additions
        EnhancementOption(id: "pixie_lift",       title: "Pixie Lift",        subtitle: nil,                 prompt: "Respectfully lift and refine the nose tip for a pixie-esque profile",             isFree: false),
        EnhancementOption(id: "snatched_bridge",  title: "Snatched Bridge",   subtitle: "Limited-time free", prompt: "Respectfully slim and sharpen the nose bridge for a snatched look",               isFree: true),
        EnhancementOption(id: "doll_nose",        title: "Doll Nose",         subtitle: nil,                 prompt: "Respectfully sculpt a petite, doll-like nose shape",                               isFree: false),
        EnhancementOption(id: "airbrush_narrow",  title: "Airbrush Narrow",   subtitle: nil,                 prompt: "Airbrush-style narrowing for a photo-ready nose",                                  isFree: true),
        EnhancementOption(id: "slope_sculpt",     title: "Slope Sculpt",      subtitle: nil,                 prompt: "Respectfully sculpt a gentle ski-slope nose profile",                              isFree: false),
        EnhancementOption(id: "natural_polish",   title: "Natural Polish",    subtitle: "Limited-time free", prompt: "Add subtle refinement for a naturally polished nose",                               isFree: true),
        EnhancementOption(id: "cupids_dip",       title: "Cupid‚Äôs Dip",       subtitle: nil,                 prompt: "Create a delicate dip just beneath the tip for a Cupid-inspired contour",          isFree: false),
        EnhancementOption(id: "halo_highlight",   title: "Halo Highlight",    subtitle: nil,                 prompt: "Respectfully add soft highlight to accentuate the nose bridge",                   isFree: true)
    ]


    // MARK: ‚Äì Eyes
    static let eyes: [EnhancementOption] = [
        // Existing
        EnhancementOption(id: "brighten",         title: "Brighten",          subtitle: nil,                 prompt: "Brighten eyes and reduce shadows",                                                  isFree: true),
        EnhancementOption(id: "enlarge",          title: "Enlarge",           subtitle: nil,                 prompt: "Subtly enlarge the eyes",                                                          isFree: false),
        EnhancementOption(id: "fox_lift",         title: "Fox Lift",          subtitle: nil,                 prompt: "Respectfully lift outer corners for a fox-eye trend",                               isFree: true),
        EnhancementOption(id: "doll_eyes",        title: "Doll Eyes",         subtitle: "Limited-time free", prompt: "Respectfully widen and round eyes for a doll-like effect",                           isFree: true),
        EnhancementOption(id: "winged_liner",     title: "Winged Liner",      subtitle: nil,                 prompt: "Apply a clean winged-liner illusion for sharp definition",                          isFree: false),

        // New additions
        EnhancementOption(id: "siren_lift",       title: "Siren Lift",        subtitle: nil,                 prompt: "Respectfully raise outer corners for a sultry siren-eye look",                     isFree: false),
        EnhancementOption(id: "soft_sparkle",     title: "Soft Sparkle",      subtitle: nil,                 prompt: "Gently add subtle shimmer for softly sparkling eyes",                               isFree: true),
        EnhancementOption(id: "mega_pop",         title: "Mega Pop",          subtitle: "Limited-time free", prompt: "Intensify iris clarity for ultra-pop TikTok eyes",                                   isFree: true),
        EnhancementOption(id: "pastel_twinkle",   title: "Pastel Twinkle",    subtitle: nil,                 prompt: "Tint eyes with a pastel twinkle for dreamy vibes",                                   isFree: false),
        EnhancementOption(id: "graphic_flick",    title: "Graphic Flick",     subtitle: nil,                 prompt: "Apply a bold graphic liner flick for statement eyes",                               isFree: false),
        EnhancementOption(id: "dreamy_haze",      title: "Dreamy Haze",       subtitle: nil,                 prompt: "Add a soft-focus haze for ethereal eyes",                                           isFree: true),
        EnhancementOption(id: "icicle_bright",    title: "Icicle Bright",     subtitle: "Limited-time free", prompt: "Cool-tone brighten for an icy, refreshed gaze",                                      isFree: true),
        EnhancementOption(id: "subtle_smoke",     title: "Subtle Smoke",      subtitle: nil,                 prompt: "Respectfully add a gentle smoky contour for depth",                                 isFree: false)
    ]

    // MARK: ‚Äì Skin
    static let skin: [EnhancementOption] = [
        // Existing
        EnhancementOption(id: "smooth",        title: "Smooth",        subtitle: nil,                 prompt: "Smooth skin texture and even tone",                             isFree: true),
        EnhancementOption(id: "glow",          title: "Glow",          subtitle: nil,                 prompt: "Add a healthy, radiant glow",                                   isFree: false),

        // New additions
        EnhancementOption(id: "airbrush",      title: "Airbrush",      subtitle: nil,                 prompt: "Apply studio-grade airbrush smoothing and even tones",           isFree: false),
        EnhancementOption(id: "glass_skin",    title: "Glass Skin",    subtitle: "Limited-time free", prompt: "Respectfully create a dewy glass-skin finish",                    isFree: true),
        EnhancementOption(id: "peachy_blush",  title: "Peachy Blush",  subtitle: nil,                 prompt: "Add a soft peachy flush for a healthy TikTok blush look",        isFree: true),
        EnhancementOption(id: "bronze_tan",    title: "Bronze Tan",    subtitle: nil,                 prompt: "Apply a subtle sun-kissed bronze tan",                           isFree: false),
        EnhancementOption(id: "freckle_kiss",  title: "Freckle Kiss",  subtitle: "Limited-time free", prompt: "Sprinkle natural-looking sun freckles for playful vibes",        isFree: true),
        EnhancementOption(id: "clarity_boost", title: "Clarity Boost", subtitle: nil,                 prompt: "Reduce blemishes and enhance skin clarity",                      isFree: false),
        EnhancementOption(id: "matte_filter",  title: "Matte Filter",  subtitle: nil,                 prompt: "Respectfully mattify skin to reduce shine",                      isFree: true),
        EnhancementOption(id: "pearl_highlight",title: "Pearl Highlight",subtitle: nil,               prompt: "Apply soft pearl highlights for luminous skin accents",          isFree: false)
    ]

    // MARK: ‚Äì Face
    static let face: [EnhancementOption] = [
        // Existing
        EnhancementOption(id: "contour",        title: "Contour",        subtitle: nil,                 prompt: "Add subtle contour to face",                                   isFree: true),
        EnhancementOption(id: "smooth",         title: "Smooth",         subtitle: nil,                 prompt: "Smooth overall facial features",                               isFree: false),

        // New additions
        EnhancementOption(id: "jawline_define", title: "Jawline Define", subtitle: nil,                 prompt: "Sharpen jawline for a defined look",                           isFree: false),
        EnhancementOption(id: "cheek_lift",     title: "Cheek Lift",     subtitle: nil,                 prompt: "Respectfully lift and sculpt cheekbones",                      isFree: true),
        EnhancementOption(id: "v_face",         title: "V-Face",         subtitle: "Limited-time free", prompt: "Respectfully sculpt a sleek V-shaped face",                    isFree: true),
        EnhancementOption(id: "baby_soft",      title: "Baby Soft",      subtitle: nil,                 prompt: "Subtly soften features for a baby-face effect",                isFree: true),
        EnhancementOption(id: "siren_sculpt",   title: "Siren Sculpt",   subtitle: nil,                 prompt: "Respectfully sculpt striking features for a siren look",       isFree: false),
        EnhancementOption(id: "golden_ratio",   title: "Golden Ratio",   subtitle: nil,                 prompt: "Refine facial proportions toward the golden ratio",            isFree: false),
        EnhancementOption(id: "soft_highlight", title: "Soft Highlight", subtitle: "Limited-time free", prompt: "Add gentle highlighted glow to lift features",                 isFree: true),
        EnhancementOption(id: "chin_tuck",      title: "Chin Tuck",      subtitle: nil,                 prompt: "Subtly tuck chin for a refined profile",                       isFree: false)
    ]

    // MARK: ‚Äì Lips
    static let lips: [EnhancementOption] = [
        // Existing
        EnhancementOption(id: "full",           title: "Full",            subtitle: nil,                 prompt: "Enhance lip fullness",                                                         isFree: true),
        EnhancementOption(id: "color",          title: "Color",           subtitle: nil,                 prompt: "Add natural lip color",                                                        isFree: false),

        // New additions
        EnhancementOption(id: "gloss_sheen",    title: "Gloss Sheen",      subtitle: "Limited-time free", prompt: "Add a high-shine gloss sheen for viral glow",                                    isFree: true),
        EnhancementOption(id: "soft_ombre",     title: "Soft Ombr√©",       subtitle: nil,                 prompt: "Apply a subtle ombr√© gradient for fuller-looking lips",                          isFree: false),
        EnhancementOption(id: "cupid_bow",      title: "Cupid‚Äôs Bow",      subtitle: nil,                 prompt: "Enhance Cupid‚Äôs bow definition for a crisp lip shape",                           isFree: false),
        EnhancementOption(id: "velvet_matte",   title: "Velvet Matte",     subtitle: nil,                 prompt: "Give lips a plush velvet-matte finish",                                         isFree: false),
        EnhancementOption(id: "plump_pout",     title: "Plump Pout",       subtitle: "Limited-time free", prompt: "Respectfully plump lips for a TikTok-ready pout",                                isFree: true),
        EnhancementOption(id: "blushed_tint",   title: "Blushed Tint",     subtitle: nil,                 prompt: "Add a soft blushed tint for a natural flush",                                   isFree: true),
        EnhancementOption(id: "frosted_shine",  title: "Frosted Shine",    subtitle: nil,                 prompt: "Apply shimmering frosted shine for nostalgic Y2K vibes",                        isFree: false)
    ]
    // MARK: ‚Äì Legs
    static let leg: [EnhancementOption] = [
        // Existing
        EnhancementOption(id: "slim",              title: "Slim",               subtitle: nil,                 prompt: "Slim and lengthen legs",                                                          isFree: true),
        EnhancementOption(id: "tone",              title: "Tone",               subtitle: nil,                 prompt: "Tone leg muscles for definition",                                                isFree: false),

        // New additions
        EnhancementOption(id: "barbie_length",     title: "Barbie Length",      subtitle: "Limited-time free", prompt: "Lengthen and refine legs for Barbiecore proportions",                              isFree: true),
        EnhancementOption(id: "model_stretch",     title: "Model Stretch",      subtitle: nil,                 prompt: "Respectfully elongate legs for a runway-model stretch",                          isFree: false),
        EnhancementOption(id: "athletic_sculpt",   title: "Athletic Sculpt",    subtitle: nil,                 prompt: "Enhance muscle definition for a sporty leg sculpt",                               isFree: false),
        EnhancementOption(id: "pilates_tone",      title: "Pilates Tone",       subtitle: nil,                 prompt: "Add gentle Pilates-inspired toning",                                             isFree: true),
        EnhancementOption(id: "sun_kissed_glow",   title: "Sun-Kissed Glow",    subtitle: nil,                 prompt: "Apply a subtle sun-bronzed glow to legs",                                        isFree: false),
        EnhancementOption(id: "glass_shine",       title: "Glass Shine",        subtitle: "Limited-time free", prompt: "Add glossy glass-skin shine for viral leg sheen",                                 isFree: true),
        EnhancementOption(id: "dreamy_slim",       title: "Dreamy Slim",        subtitle: nil,                 prompt: "Soft-focus slim effect for dreamy long legs",                                    isFree: false),
        EnhancementOption(id: "v_line_define",     title: "V-Line Define",      subtitle: nil,                 prompt: "Sculpt inner-thigh V-line for crisp definition",                                 isFree: false)
    ]

    
    static let jewellery: [EnhancementOption] = [
        EnhancementOption(
                id: "gold_hoop_minimal",
                title: "Minimal Gold Hoops",
                subtitle: nil,
                prompt: "Add sleek, minimalistic gold hoop earrings",
                isFree: true
            ),
            EnhancementOption(
                id: "delicate_gold_chain",
                title: "Delicate Gold Chain",
                subtitle: nil,
                prompt: "Add a thin, delicate gold chain necklace",
                isFree: true
            ),
            EnhancementOption(
                id: "stackable_bands",
                title: "Stackable Bands",
                subtitle: nil,
                prompt: "Add a set of minimal stackable gold rings",
                isFree: false
            ),
            EnhancementOption(
                id: "geometric_studs",
                title: "Geometric Studs",
                subtitle: nil,
                prompt: "Add small geometric stud earrings in gold",
                isFree: true
            ),
            EnhancementOption(
                id: "thin_gold_bangle",
                title: "Thin Gold Bangle",
                subtitle: nil,
                prompt: "Add a slender, minimalistic gold bangle bracelet",
                isFree: false
            ),
            EnhancementOption(
                id: "gold_bar_necklace",
                title: "Gold Bar Necklace",
                subtitle: "Limited-time free",
                prompt: "Add a minimalist gold bar pendant necklace",
                isFree: true
            ),
            EnhancementOption(
                id: "link_chain_bracelet",
                title: "Link Chain Bracelet",
                subtitle: nil,
                prompt: "Add a bold gold link chain bracelet",
                isFree: false
            ),
            EnhancementOption(
                id: "pearls_and_gold",
                title: "Pearls & Gold",
                subtitle: nil,
                prompt: "Add a blend of pearls with gold accents",
                isFree: true
            ),
            EnhancementOption(
                id: "gold_cuff_minimal",
                title: "Minimal Gold Cuff",
                subtitle: nil,
                prompt: "Add a clean, minimalistic gold cuff bracelet",
                isFree: false
            ),
            EnhancementOption(
                id: "layered_gold_chains",
                title: "Layered Gold Chains",
                subtitle: nil,
                prompt: "Add multiple thin gold chain necklaces for layering",
                isFree: false
            ),
        EnhancementOption(
            id: "earrings",
            title: "Earrings",
            subtitle: nil,
            prompt: "Add stylish earrings",
            isFree: true
        ),
        EnhancementOption(
            id: "necklace",
            title: "Necklace",
            subtitle: nil,
            prompt: "Add a beautiful necklace",
            isFree: false
        ),
        EnhancementOption(
            id: "bracelet",
            title: "Bracelet",
            subtitle: nil,
            prompt: "Add a delicate bracelet around the wrist",
            isFree: true
        ),
        EnhancementOption(
            id: "ring",
            title: "Ring",
            subtitle: nil,
            prompt: "Add a sparkling ring to the fingers",
            isFree: false
        ),
        EnhancementOption(
            id: "anklet",
            title: "Anklet",
            subtitle: "Limited-time free",
            prompt: "Add a subtle anklet for a refined touch",
            isFree: true
        ),
        EnhancementOption(
            id: "chandelier_earrings",
            title: "Chandelier Earrings",
            subtitle: nil,
            prompt: "Add elegant chandelier-style earrings",
            isFree: false
        ),
        EnhancementOption(
            id: "hoop_earrings",
            title: "Hoop Earrings",
            subtitle: nil,
            prompt: "Add classic hoop earrings",
            isFree: true
        ),
        EnhancementOption(
            id: "cuff_bracelet",
            title: "Cuff Bracelet",
            subtitle: nil,
            prompt: "Add a bold cuff bracelet to the wrist",
            isFree: false
        ),
        EnhancementOption(
            id: "choker",
            title: "Choker",
            subtitle: nil,
            prompt: "Add a sleek choker around the neck",
            isFree: true
        ),
        EnhancementOption(
            id: "pendant",
            title: "Pendant",
            subtitle: nil,
            prompt: "Add a charming pendant on a fine chain",
            isFree: false
        ),
        EnhancementOption(
            id: "brooch",
            title: "Brooch",
            subtitle: nil,
            prompt: "Add a decorative brooch for a vintage flair",
            isFree: true
        ),
        EnhancementOption(
            id: "watch",
            title: "Watch",
            subtitle: nil,
            prompt: "Add a stylish wristwatch",
            isFree: false
        )
    ]

    // New Eyewear options
    static let eyewear: [EnhancementOption] = [
        EnhancementOption(
            id: "eyewear",
            title: "Eyewear",
            subtitle: nil,
            prompt: "Add stylish eyewear frames",
            isFree: true
        ),
        EnhancementOption(
            id: "sunglasses",
            title: "Sunglasses",
            subtitle: nil,
            prompt: "Add trendy sunglasses with reflective lenses",
            isFree: false
        ),
        EnhancementOption(
            id: "reading_glasses",
            title: "Reading Glasses",
            subtitle: "Limited-time free",
            prompt: "Add elegant reading glasses with thin frames",
            isFree: true
        ),
        EnhancementOption(
            id: "aviators",
            title: "Aviator Frames",
            subtitle: nil,
            prompt: "Add classic aviator sunglasses with metal frames",
            isFree: false
        ),
        EnhancementOption(
            id: "wayfarer",
            title: "Wayfarer",
            subtitle: nil,
            prompt: "Add stylish wayfarer-style glasses",
            isFree: true
        ),
        EnhancementOption(
            id: "round_frames",
            title: "Round Frames",
            subtitle: nil,
            prompt: "Add vintage round frame glasses",
            isFree: false
        ),
        EnhancementOption(
            id: "cat_eye",
            title: "Cat-eye",
            subtitle: nil,
            prompt: "Add chic cat-eye glasses for a retro look",
            isFree: true
        ),
        EnhancementOption(
            id: "translucent_frames",
            title: "Translucent Frames",
            subtitle: nil,
            prompt: "Add translucent frame glasses with modern vibe",
            isFree: false
        ),
        EnhancementOption(
            id: "sports_goggles",
            title: "Sports Goggles",
            subtitle: nil,
            prompt: "Add sporty wrap-around goggles",
            isFree: false
        ),
        EnhancementOption(
            id: "steampunk_goggles",
            title: "Steampunk Goggles",
            subtitle: "Limited-time free",
            prompt: "Add decorative steampunk-style goggles",
            isFree: true
        )
    ]
}
//
//  ImagePicker.swift
//  HairStyle
//
//  Created by Adam Roszyk on 3/19/25.
//
import SwiftUI
import PhotosUI


// UIKit-based image picker integrated into SwiftUI using UIViewControllerRepresentable
struct ImagePicker: UIViewControllerRepresentable {
    class Coordinator: NSObject, UINavigationControllerDelegate, UIImagePickerControllerDelegate {
        let parent: ImagePicker

        init(_ parent: ImagePicker) {
            self.parent = parent
        }
        func imagePickerController(_ picker: UIImagePickerController,
                                   didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey : Any]) {
            if let uiImage = info[.originalImage] as? UIImage {
                parent.image = uiImage
            }
            picker.dismiss(animated: true)
        }
    }
    
    @Binding var image: UIImage?
    
    func makeCoordinator() -> Coordinator {
        Coordinator(self)
    }
    func makeUIViewController(context: Context) -> UIImagePickerController {
        let picker = UIImagePickerController()
        picker.delegate = context.coordinator
        return picker
    }
    func updateUIViewController(_ uiViewController: UIImagePickerController, context: Context) {}
}
import SwiftUI
@main
struct HairStyleApp: App {
    @AppStorage("hasSeenDemo")            private var hasSeenDemo            = false
    @AppStorage("hasCompletedOnboarding") private var hasCompletedOnboarding = false
    
    @StateObject private var subscriptionManager = SubscriptionManager()
    
    var body: some Scene {
        WindowGroup {
            if hasCompletedOnboarding {
                CatalogView()
                    .environmentObject(subscriptionManager)
            } else {
                OnboardingFlowView()          // ‚Üê new flow
                    .environmentObject(subscriptionManager)
            }
        }
    }
}
import SwiftUI
import Vision
import CoreML
import CoreImage
import UIKit
import os

// MARK: - CIImage Extension
extension CIImage {
    /// Returns a resized CIImage.
    func resized(to size: CGSize) -> CIImage {
        let scaleX = size.width / extent.width
        let scaleY = size.height / extent.height
        var outputImage = transformed(by: CGAffineTransform(scaleX: scaleX, y: scaleY))
        // Reset the origin to (0,0)
        outputImage = outputImage.transformed(by: CGAffineTransform(translationX: -outputImage.extent.origin.x,
                                                                    y: -outputImage.extent.origin.y))
        return outputImage
    }
}
extension CIContext {
    /// Renders a CIImage to a new CVPixelBuffer using the specified pixel format.
    func render(_ image: CIImage, pixelFormat: OSType) -> CVPixelBuffer? {
        // Ensure valid dimensions by rounding up and enforcing a minimum value
        let width = max(Int(ceil(image.extent.width)), 1)
        let height = max(Int(ceil(image.extent.height)), 1)
        let attrs: [CFString: Any] = [
            kCVPixelBufferCGImageCompatibilityKey: true,
            kCVPixelBufferCGBitmapContextCompatibilityKey: true,
            kCVPixelBufferIOSurfacePropertiesKey: [:]
        ]
        var pixelBuffer: CVPixelBuffer?
        let status = CVPixelBufferCreate(
            kCFAllocatorDefault,
            width,
            height,
            pixelFormat,
            attrs as CFDictionary,
            &pixelBuffer
        )
        guard status == kCVReturnSuccess, let buffer = pixelBuffer else {
            print("CVPixelBufferCreate failed with status: \(status)")
            return nil
        }
        self.render(image, to: buffer)
        return buffer
    }
}


// Extension to enhance image contrast
extension UIImage {
    func applyingContrast(_ contrast: CGFloat) -> UIImage? {
        guard let cgImage = self.cgImage else { return nil }
        
        let context = CIContext()
        let ciImage = CIImage(cgImage: cgImage)
        
        let filter = CIFilter(name: "CIColorControls")
        filter?.setValue(ciImage, forKey: kCIInputImageKey)
        filter?.setValue(contrast, forKey: kCIInputContrastKey)
        filter?.setValue(0, forKey: kCIInputBrightnessKey)
        filter?.setValue(1.0, forKey: kCIInputSaturationKey)
        
        guard let outputImage = filter?.outputImage,
              let filteredCGImage = context.createCGImage(outputImage, from: outputImage.extent) else {
            return nil
        }
        
        return UIImage(cgImage: filteredCGImage, scale: self.scale, orientation: self.imageOrientation)
    }
}

extension UIImage {
    func resizedPixelBuffer(width: Int, height: Int) -> CVPixelBuffer? {
        var pxBuffer: CVPixelBuffer?
        let attrs = [
            kCVPixelBufferCGImageCompatibilityKey: true,
            kCVPixelBufferCGBitmapContextCompatibilityKey: true
        ] as CFDictionary
        
        guard CVPixelBufferCreate(kCFAllocatorDefault,
                                  width,
                                  height,
                                  kCVPixelFormatType_32ARGB,
                                  attrs,
                                  &pxBuffer) == kCVReturnSuccess,
              let buffer = pxBuffer,
              let cgImage = self.cgImage else {
            return nil
        }
        CVPixelBufferLockBaseAddress(buffer, [])
        defer { CVPixelBufferUnlockBaseAddress(buffer, []) }
        
        let context = CGContext(data: CVPixelBufferGetBaseAddress(buffer),
                                width: width,
                                height: height,
                                bitsPerComponent: 8,
                                bytesPerRow: CVPixelBufferGetBytesPerRow(buffer),
                                space: CGColorSpaceCreateDeviceRGB(),
                                bitmapInfo: CGImageAlphaInfo.noneSkipFirst.rawValue)
        guard let ctx = context else { return nil }
        
        let rect = CGRect(x: 0, y: 0, width: width, height: height)
        ctx.draw(cgImage, in: rect)
        
        return buffer
    }
}
