2025-05-02 11:21:53
//
//  LoadingMessages.swift
//  HairStyle
//
//  Created by adam on 30/04/2025.
//


//  LoadingMessages.swift
//  PicUp
//  Generated 30‚Äë04‚Äë2025 ‚Äì A sprinkle of Gen‚ÄëZ flavoured loading banter ‚ú®
//
//  Call `LoadingMessages.random()` whenever you need a fresh status line.
//  Example:
//      Text(LoadingMessages.random())
//
//  The list can be expanded or localized later.

import Foundation

enum LoadingMessages {
    static let all: [String] = [
        "Casting ‚ú® filters‚Ä¶ hold my boba!",
        "Crunching pixels like kettle chips‚Ä¶",
        "Tweaking the vibe parameters (scientifically, of course)‚Ä¶",
        "GPU is doing burpees‚Äîalmost done!",
        "Uploading imagination to the cloud ‚òÅÔ∏è‚Ä¶",
        "Painting happy little bytes‚Ä¶",
        "Assembling AI drip, please stand by‚Ä¶",
        "Turning coffee into gradients‚Ä¶",
        "Charging the creativity capacitor ‚ö°Ô∏è‚Ä¶",
        "Optimizing the funniness algorithm‚Ä¶",
        "Feeding hamsters more voltage‚Ä¶",
        "Rendering in ‚ú® Ultra‚ÄëMega‚Äë1080p ‚ú®‚Ä¶",
        "Spinning up rainbow shaders‚Ä¶",
        "Injecting extra serotonin into pixels‚Ä¶",
        "Reticulating splines 2.0‚Ä¶",
        "Aligning photonic chakras‚Ä¶",
        "Manifesting your best self‚Ä¶",
        "Negotiating with the color wheel‚Ä¶",
        "Loading swag assets (almost there)‚Ä¶",
        "Finalizing epicness‚Äîdo not unplug!"
    ]

    /// Returns a random playful loading string.
    static func random() -> String {
        all.randomElement() ?? "Generating‚Ä¶ hang tight!"
    }
}
import SwiftUI

/// The bottom action bar for the enhancement panel.
/// Now displays the currently selected option‚Äôs icon in the center.
struct BottomBar: View {
    /// The name of the asset to show between Cancel and Apply.
    let iconAssetName: String?
    let onCancel: () -> Void
    let onApply: () -> Void

    var body: some View {
        HStack {
            // Cancel button
            Button(action: onCancel) {
                Label("Cancel", systemImage: "xmark")
                    .font(.headline)
                    .foregroundColor(.white)
                    .padding(.vertical, 14)
                    .padding(.horizontal, 20)
            }

            Spacer()

            // Center icon for the selected enhancement
            if let asset = iconAssetName {
                Image(asset)
                    .resizable()
                    .aspectRatio(contentMode: .fit)
                    .frame(width: 44, height: 44)
            }

            Spacer()

            // Apply button
            Button(action: onApply) {
                Label("Apply", systemImage: "checkmark")
                    .font(.headline)
                    .foregroundColor(.white)
                    .padding(.vertical, 6)
                    .padding(.horizontal, 18)
            }
        }
        .padding(.horizontal, 7)
        .padding(.bottom, 20)
    }
}
import SwiftUI

// MARK: ‚Äì Photo / slider view
 struct PhotoWithRefreshOverlay: View {
    // Inputs
    let originalImage: UIImage?
    let editedImage: UIImage?
    let depthMapImage: UIImage?
    let isGenerating: Bool
    @Binding var sliderPosition: CGFloat
    @Binding var showSlider: Bool
    let onReplaceTap: () -> Void
    let onAddTap: () -> Void
    let onSaveTap: () -> Void

    // Zoom / pan state omitted for brevity ‚Äì unchanged from earlier version

    var body: some View {
        ZStack {
            contentView
        }
    }

    @ViewBuilder private var contentView: some View {
        if let orig = originalImage, let edit = editedImage {
            Image(uiImage: edit).resizable().scaledToFit()
        } else if let edit = editedImage {
            Image(uiImage: edit).resizable().scaledToFit()
        } else {
            EmptyStateView(onAddTap: onAddTap, isGenerating: isGenerating)
        }
    }
}

// MARK: ‚Äì Empty state
private struct EmptyStateView: View {
    let onAddTap: () -> Void
    let isGenerating: Bool

    var body: some View {
        VStack {
            Spacer()
            if isGenerating {
                Text(LoadingMessages.random())
                    .font(.headline)
                    .multilineTextAlignment(.center)
                    .foregroundColor(.white)
                    .padding()
            } else {
                Button(action: onAddTap) {
                    VStack(spacing: 12) {
                        Image(systemName: "photo.fill.on.rectangle.fill").font(.system(size: 40))
                        Text("Add Image +").font(.headline)
                    }
                    .foregroundColor(.black)
                    .padding()
                    .background(Color.white)
                    .cornerRadius(12)
                    .shadow(radius: 10)
                }
            }
            Spacer()
        }
    }
}

// MARK: ‚Äì Stub generation worker
 enum ImageEditingWorker {
    static func generate(input: UIImage, prompt: String) async -> UIImage? {
        let vm = ImageEditingViewModel()
        do {
            try await vm.loadModel()
            vm.editedImage = input
            vm.prompt = prompt
            await MainActor.run { vm.editImage() }
            while await MainActor.run(body: { vm.isLoading }) {
                try? await Task.sleep(for: .milliseconds(100))
            }
            return await MainActor.run(body: { vm.editedImage })
        } catch {
            print("Generation failed: \(error)")
            return nil
        }
    }
}
import SwiftUI

struct EnhancementPanelView: View {
    let section: String
    let options: [EnhancementOption]
    @Binding var selectedOption: EnhancementOption?
    let applyAction: () -> Void
    let cancelAction: () -> Void

    var body: some View {
        VStack(spacing: 12) {
            PillsScroll(options: options, selectedOption: $selectedOption)
            Divider().background(Color.white.opacity(0.5))
            BottomBar(
                iconAssetName: sectionIconName,
                onCancel: cancelAction,
                onApply: applyAction
            )
        }
        .background(.ultraThinMaterial)
        .cornerRadius(16)
        .padding(.horizontal, 16)
        .padding(.bottom, 8)
        .padding(.top, 12)
    }
    
    private var sectionIconName: String {
        // e.g. "Slim Waist" ‚Üí "SlimWaist"
        section.replacingOccurrences(of: " ", with: "")
    }
}

// MARK: ‚Äî Pills Scroll

private struct PillsScroll: View {
    let options: [EnhancementOption]
    @Binding var selectedOption: EnhancementOption?

    var body: some View {
        ScrollView(.horizontal, showsIndicators: false) {
            HStack(spacing: 16) {
                ForEach(options) { opt in
                    OptionPill(
                        option: opt,
                        isSelected: opt.id == selectedOption?.id
                    )
                    .onTapGesture { selectedOption = opt }
                }
            }
            .padding(.horizontal, 16)
            .padding(.bottom, 8)
            .padding(.top, 12)
        }
    }
}

// MARK: ‚Äî Single Pill

private struct OptionPill: View {
    let option: EnhancementOption
    let isSelected: Bool

    // map id ‚Üí SF symbol
    private var iconName: String {
        switch option.id {
        case "round":        return "circle"
        case "heart_shaped": return "heart.fill"
        case "superlift":    return "flame.fill"
        default:             return "sparkles"
        }
    }

    private var titleColor: AnyShapeStyle {
        if isSelected {
            return AnyShapeStyle(
                LinearGradient(
                    colors: [Color.pink, Color.orange],
                    startPoint: .leading,
                    endPoint: .trailing
                )
            )
        } else {
            return AnyShapeStyle(Color.white.opacity(0.9))
        }
    }

    var body: some View {
        HStack(spacing: 12) {
            Image(systemName: iconName)
                .font(.subheadline)
                .foregroundColor(isSelected ? .white : .white.opacity(0.7))
            Text(option.title)
                .font(.subheadline)
                .fontWeight(.medium)
                .foregroundStyle(titleColor)
        }
        // ‚Üë bump horizontal padding from 16 ‚Üí 20, vertical from 8 ‚Üí 12
        .padding(.vertical, 12)
        .padding(.horizontal, 20)
        .background(isSelected
                    ? Color.black.opacity(0.85)
                    : Color.black.opacity(0.6))
        .cornerRadius(24)  // slightly larger radius
        .overlay(
                    Group {
                        if isSelected {
                            Image(systemName: "checkmark.circle.fill")
                                .font(.title3)            // slightly larger
                                .foregroundColor(.white)  // white+
                                .offset(x: 8, y: -8)

                        }
                    },
                    alignment: .topTrailing
                )    }
    @ViewBuilder
    private var checkmarkOverlay: some View {
        if isSelected {
            Image(systemName: "checkmark.circle.fill")
                .font(.caption)
                .foregroundColor(.green)
                .offset(x: 12, y: -12)
        }
    }
}
//
//  PhotoContainerView.swift
//  HairStyle
//
//  Created by adam on 25/04/2025.
//

import SwiftUI

// MARK: ‚Äì Photo container
 struct PhotoContainerView: View {
    @Binding var inputImage: UIImage?
    let isGenerating: Bool
    let editedImage: UIImage?
    let depthMapImage: UIImage?
    @Binding var sliderPosition: CGFloat
    @Binding var showSlider: Bool
    let onAddTap: () -> Void
    let onReplaceTap: () -> Void
    let onSaveTap: () -> Void

    var body: some View {
        ZStack {
            backgroundView.ignoresSafeArea()
            PhotoWithRefreshOverlay(
                originalImage: inputImage,
                editedImage: editedImage,
                depthMapImage: depthMapImage,
                isGenerating: isGenerating,
                sliderPosition: $sliderPosition,
                showSlider: $showSlider,
                onReplaceTap: onReplaceTap,
                onAddTap: onAddTap,
                onSaveTap: onSaveTap
            )
        }
    }

    @ViewBuilder private var backgroundView: some View {
        if let img = inputImage {
            Image(uiImage: img).resizable().scaledToFill().blur(radius: 120).overlay(Color.black.opacity(0.4))
        } else {
            Color.black.opacity(0.6)
        }
    }
}
//  GenView.swift
//  PicUp
//  FINAL ‚Äì original thumbnail appears **only after** Apply is tapped
//
//  ‚Ä¢ Thumbnail #0 is the ORIGINAL photo (labelled, no spinner) but is inserted
//    *after* the user taps **Apply**. Until then, the strip is hidden.
//  ‚Ä¢ Generated thumbnails (#1‚Äë#4) follow and may show spinners.
//  ‚Ä¢ loadImage() now simply resets thumbnails so the user can re‚Äëapply effects.

import SwiftUI
import UIKit

// MARK: ‚Äì Thumbnail item model -------------------------------------------------
private struct ThumbItem: Identifiable {
    /// id == -1 ‚Üí original; 0‚Ä¶3 ‚Üí generated slots
    let id: Int
    var image: UIImage? = nil
    var isLoading: Bool = false
    var isOriginal: Bool { id == -1 }
}

// MARK: ‚Äì GenView --------------------------------------------------------------
struct GenView: View {
    // MARK: Inputs
    let section: String

    // MARK: View‚Äëmodel
    @StateObject private var viewModel = ImageEditingViewModel()

    // MARK: UI state
    @State private var selectedOption: EnhancementOption?
    @State private var inputImage: UIImage?
    @State private var showingImagePicker = false
    @State private var sliderPosition: CGFloat = 0.5
    @State private var showSlider = false
    @State private var showSaveSuccessAlert = false

    // Thumbnails: original + up to 4 generations (populated after Apply)
    @State private var thumbs: [ThumbItem] = []
    @State private var currentIdx: Int? = nil      // index in thumbs

    // Derived flags
    private var isGenerating: Bool { thumbs.contains { !$0.isOriginal && $0.isLoading } }
    private var hasThumbs: Bool { !thumbs.isEmpty }

    // MARK: Environment
    @Environment(\.dismiss) private var dismiss

    // MARK: Body ----------------------------------------------------------------
    var body: some View {
        ZStack {
            GeometryReader { geo in
                // Photo area --------------------------------------------------
                PhotoContainerView(
                    inputImage: $inputImage,
                    isGenerating: isGenerating,
                    editedImage: mainDisplayedImage,
                    depthMapImage: viewModel.depthMapImage,
                    sliderPosition: $sliderPosition,
                    showSlider: $showSlider,
                    onAddTap: handleReplacePhoto,
                    onReplaceTap: handleReplacePhoto,
                    onSaveTap: saveImage
                )
                .frame(width: geo.size.width, height: geo.size.height)
                .ignoresSafeArea()

                // Top buttons ------------------------------------------------
                if inputImage != nil {
                    TopButtons(
                        onBack: { dismiss() },
                        onReplace: handleReplacePhoto,
                        onShare: shareImage,
                        onSave: saveImage,
                        topInset: -20
                    )
                    .padding(.horizontal, 16)
                }

                // Bottom area ------------------------------------------------
                VStack {
                    Spacer()
                    if hasThumbs {
                        ThumbnailsStrip(thumbs: thumbs, onSelect: { idx in currentIdx = idx }, onRetry: beginParallelGeneration)
                    } else {
                        EnhancementPanelView(
                            section: section,
                            options: enhancementOptions,
                            selectedOption: $selectedOption,
                            applyAction: beginParallelGeneration,
                            cancelAction: { dismiss() }
                        )
                    }
                }
                .frame(width: geo.size.width)
            }
        }
        .navigationBarBackButtonHidden(true)
        // Global overlay spinner -------------------------------------------
        .overlay {
            if isGenerating {
                Color.black.opacity(0.35).ignoresSafeArea()
                ProgressView()
                    .progressViewStyle(CircularProgressViewStyle(tint: .white))
                    .scaleEffect(2)
            }
        }
        // Image picker + save alert ----------------------------------------
        .sheet(isPresented: $showingImagePicker, onDismiss: loadImage) {
            ImagePicker(image: $inputImage)
        }
        .alert("Saved", isPresented: $showSaveSuccessAlert) {
            Button("OK", role: .cancel) {}
        } message: { Text("Image saved to Photos") }
    }

    // MARK: Helpers ------------------------------------------------------------
    private var mainDisplayedImage: UIImage? {
        guard let idx = currentIdx, thumbs.indices.contains(idx) else { return viewModel.editedImage }
        return idx == 0 ? inputImage : thumbs[idx].image
    }

    // MARK: Generation ----------------------------------------------------------
    private func beginParallelGeneration() {
        guard let base = inputImage, let prompt = selectedOption?.prompt else { return }

        // Seed thumbnails: original first, then 4 loading slots
        thumbs = [ThumbItem(id: -1, image: base, isLoading: false)] +
                 (0..<4).map { ThumbItem(id: $0, isLoading: true) }
        currentIdx = 1  // focus first generated placeholder

        Task.detached(priority: .userInitiated) {
            await withTaskGroup(of: (Int, UIImage?).self) { group in
                for idx in 0..<4 {
                    group.addTask { (idx, await ImageEditingWorker.generate(input: base, prompt: prompt)) }
                }
                for await (idx, img) in group {
                    await MainActor.run {
                        thumbs[idx + 1].image = img   // +1 shift (index 0 is original)
                        thumbs[idx + 1].isLoading = false
                    }
                }
            }
        }
    }

    // MARK: Image / UI actions --------------------------------------------------
    private func handleReplacePhoto() { showingImagePicker = true }

    private func loadImage() {
        guard let img = inputImage else { return }   // user cancelled
        viewModel.editedImage = img
        // Clear thumbnails; original will be added after next Apply
        thumbs.removeAll()
        currentIdx = nil
    }

    private func saveImage() {
        guard let img = mainDisplayedImage else { return }
        UIImageWriteToSavedPhotosAlbum(img, nil, nil, nil)
        showSaveSuccessAlert = true
    }

    private func shareImage() {
        guard let img = mainDisplayedImage else { return }
        let av = UIActivityViewController(activityItems: [img], applicationActivities: nil)
        UIApplication.shared.windows.first?.rootViewController?.present(av, animated: true)
    }

    // MARK: Enhancement options (unchanged) ------------------------------------
    private var enhancementOptions: [EnhancementOption] {
        switch section {
        case "Chest":    return BodyEnhancementPrompts.breast
        case "Belly":    return BodyEnhancementPrompts.belly
        case "Buttock":  return BodyEnhancementPrompts.buttock
        case "Muscle":   return BodyEnhancementPrompts.muscle
        case "Hair":     return BodyEnhancementPrompts.hair
        case "Nose":     return BodyEnhancementPrompts.nose
        case "Eyes":     return BodyEnhancementPrompts.eyes
        case "Skin":     return BodyEnhancementPrompts.skin
        case "Face":     return BodyEnhancementPrompts.face
        case "Lips":     return BodyEnhancementPrompts.lips
        case "Waist":    return BodyEnhancementPrompts.waist
        case "Legs":     return BodyEnhancementPrompts.leg
        case "jewellery":return BodyEnhancementPrompts.jewellery
        case "Eyewear":  return BodyEnhancementPrompts.eyewear
        default:          return []
        }
    }
}

// MARK: ‚Äì Thumbnails strip -----------------------------------------------------
private struct ThumbnailsStrip: View {
    let thumbs: [ThumbItem]
    let onSelect: (Int) -> Void
    let onRetry: () -> Void
    var isGenerating: Bool { thumbs.contains { $0.isLoading && !$0.isOriginal } }

    var body: some View {
        ScrollView(.horizontal, showsIndicators: false) {
            HStack(spacing: 16) {
                // Existing thumbnails
                ForEach(Array(thumbs.indices), id: \.self) { idx in
                    let thumb = thumbs[idx]
                    ZStack(alignment: .bottom) {
                        if let img = thumb.image {
                            Image(uiImage: img)
                                .resizable()
                                .aspectRatio(contentMode: .fill)
                        } else {
                            Color.gray.opacity(0.3)
                        }

                        if thumb.isOriginal {
                            Text("ORIGINAL")
                                .font(.caption2.weight(.bold))
                                .foregroundColor(.white)
                                .padding(.vertical, 2)
                                .frame(maxWidth: .infinity)
                                .background(Color.black.opacity(0.6))
                        }
                    }
                    .frame(width: 70, height: 70)
                    .clipped()
                    .cornerRadius(12)
                    .overlay {
                        if thumb.isLoading {
                            ProgressView()
                                .progressViewStyle(CircularProgressViewStyle(tint: .white))
                        }
                    }
                    .onTapGesture { onSelect(idx) }
                }

                // Retry button ------------------------------------------------
                Button(action: onRetry) {
                    ZStack {
                        Color.black.opacity(0.6)
                        Image(systemName: "arrow.clockwise")
                            .font(.title3.weight(.semibold))
                            .foregroundColor(.white)
                    }
                    .frame(width: 70, height: 70)
                    .cornerRadius(12)
                    .overlay {
                        if isGenerating {
                            // disabled look when still generating
                            Color.black.opacity(0.4).cornerRadius(12)
                        }
                    }
                }
                .disabled(isGenerating)
            }
            .padding(.horizontal, 16)
            .padding(.vertical, 8)
        }
        .background(.ultraThinMaterial)
        .cornerRadius(16)
    }
}

// MARK: ‚Äì Top buttons (unchanged) ---------------------------------------------
private struct TopButtons: View {
    let onBack: () -> Void
    let onReplace: () -> Void
    let onShare: () -> Void
    let onSave: () -> Void
    let topInset: CGFloat

    var body: some View {
        HStack(spacing: 12) {
            Button(action: onBack)    { Image(systemName: "chevron.left").modifier(circleIcon) }
            Button(action: onReplace) { Image(systemName: "arrow.triangle.2.circlepath").modifier(circleIcon) }
            Spacer()
            HStack(spacing: 12) {
                Button(action: onShare) { Image(systemName: "paperplane.fill").modifier(circleIcon) }
                Button(action: onSave)  { Image(systemName: "square.and.arrow.down").modifier(circleIcon) }
            }
        }
        .padding(.top, topInset + 20)
    }
    private var circleIcon: some ViewModifier { CircleIcon() }
}

private struct CircleIcon: ViewModifier {
    func body(content: Content) -> some View {
        content
            .font(.system(size: 20, weight: .medium))
            .foregroundColor(.white)
            .frame(width: 36, height: 36)
            .background(Color.black.opacity(0.6))
            .clipShape(Circle())
    }
}
import SwiftUI

struct CatalogView: View {
    // MARK: ‚Äî Data
    private let bodyShapeItems: [(title: String, icon: String)] = [
        ("Chest Curve",   "Chest"),
        ("Flat Abs",      "Belly"),
        ("Buttocks+",     "Buttock"),
        ("Slim Waist",    "Waist"),
        ("Legs",          "Legs"),
        ("Muscles",       "Muscle")
    ]

    private let facialItems: [(title: String, icon: String)] = [
        ("Face",          "Face"),
        ("Eyes",          "Eyes"),
        ("Nose",          "Nose"),
        ("Lips",          "Lips"),
        ("Skin",          "Skin")
    ]

    private let hairAccessoryItems: [(title: String, icon: String)] = [
        ("Hair",          "Hair"),
        ("Jewellery",     "jewellery"),
        ("Eyewear",       "Eyewear")
    ]

    // Three flexible columns
    private let columns = Array(
        repeating: GridItem(.flexible(), spacing: 16),
        count: 3
    )

    var body: some View {
        NavigationView {
            ScrollView {
                VStack(alignment: .leading, spacing: 32) {

                    // MARK: ‚Äî Header
                    HStack {
                        Text("BodyEditor Ai")
                            .font(.largeTitle).fontWeight(.bold)
                            .foregroundStyle(
                                LinearGradient(
                                    gradient: Gradient(colors: [Color.pink, Color.orange]),
                                    startPoint: .center,
                                    endPoint: .trailing
                                )
                            )
                        Spacer()
                    }
                    .padding(.horizontal)

                    // MARK: ‚Äî Body Shape Section
                    SectionGrid(
                        title: "Body Shape",
                        items: bodyShapeItems,
                        columns: columns
                    )

                    // MARK: ‚Äî Facial Section
                    SectionGrid(
                        title: "Facial",
                        items: facialItems,
                        columns: columns
                    )

                    // MARK: ‚Äî Hair & Accessories Section
                    SectionGrid(
                        title: "Hair & Accessories",
                        items: hairAccessoryItems,
                        columns: columns
                    )
                }
                .padding(.vertical)
            }
            .background(Color(red: 0.14, green: 0.13, blue: 0.13).edgesIgnoringSafeArea(.all))
            .navigationBarHidden(true)
        }
    }
}

private struct SectionGrid: View {
    let title: String
    let items: [(title: String, icon: String)]
    let columns: [GridItem]

    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text(title)
                .font(.headline)
                .foregroundColor(.white)
                .padding(.horizontal)

            LazyVGrid(columns: columns, alignment: .leading, spacing: 16) {
                ForEach(items, id: \.title) { item in
                    NavigationLink(
                        destination: GenView(section: item.icon)
                    ) {
                        VStack(spacing: 8) {
                            // Circular icon background
                            ZStack {
                                RoundedRectangle(cornerRadius: 18)
                                    .fill(Color.black.opacity(0.6))
                                    .frame(width: 70, height: 70)
                                    .shadow(color: Color.white.opacity(0.2),
                                            radius: 6,
                                            x: 0,
                                            y: 0)

                                Image(item.icon)
                                    .resizable()
                                    .aspectRatio(contentMode: .fit)
                                    .frame(width: 50, height: 50)
                            }
                            
                            Text(item.title)
                                .font(.caption)
                                .multilineTextAlignment(.center)
                                .foregroundColor(.white)
                        }
                        .frame(maxWidth: .infinity)
                    }
                }
            }
            .padding(.horizontal)
        }
    }
}

struct CatalogView_Previews: PreviewProvider {
    static var previews: some View {
        CatalogView()
            .preferredColorScheme(.dark)
    }
}
//
//  SubscriptionManager.swift
//  HairStyle
//
//  Created by adam on 25/03/2025.
//


import StoreKit
import SwiftUI

@MainActor
class SubscriptionManager: ObservableObject {
    /// The subscription products fetched from StoreKit configuration
    @Published var subscriptions: [Product] = []
    
    /// Keep track of purchased product identifiers
    @Published var purchasedIdentifiers = Set<String>()
    
    /// Task to listen for any subscription updates
    private var updates: Task<Void, Never>?
    
    /// Define your product IDs exactly as they appear in your StoreKit config
    private let productIDs = [
        "wbweek",  // replace with your actual weekly ID
        "wbyear"   // replace with your actual annual ID
    ]
    
    init() {
        // Start listening for transaction updates
        updates = listenForTransactions()
        
        // Immediately fetch products and update purchased info
        Task {
            await requestProducts()
            await updatePurchasedIdentifiers()
        }
    }
    
    /// Request products from StoreKit
    func requestProducts() async {
        do {
            let storeProducts = try await Product.products(for: productIDs)
            subscriptions = storeProducts
        } catch {
            print("Failed to request products: \(error)")
        }
    }
    
    /// Listen for any transaction updates (e.g., renewals, cancellations)
    private func listenForTransactions() -> Task<Void, Never> {
        Task.detached { [weak self] in
            guard let self = self else { return }
            for await result in Transaction.updates {
                do {
                    let transaction = try await self.checkVerified(result)
                    // If transaction is verified, apply changes
                    await self.updatePurchasedIdentifiers()
                    await transaction.finish()
                } catch {
                    print("Transaction failed verification")
                }
            }
        }
    }
    
    /// Update purchased identifiers from current entitlements
    private func updatePurchasedIdentifiers() async {
        purchasedIdentifiers.removeAll()
        for await verificationResult in Transaction.currentEntitlements {
            do {
                let transaction = try checkVerified(verificationResult)
                purchasedIdentifiers.insert(transaction.productID)
            } catch {
                // Not verified
            }
        }
    }
    
    /// Purchase a specific product
    func purchase(_ product: Product) async throws -> StoreKit.Transaction? {
        let result = try await product.purchase()
        switch result {
        case .success(let verification):
            let transaction = try checkVerified(verification)
            await transaction.finish()
            await updatePurchasedIdentifiers()
            return transaction
        case .userCancelled, .pending:
            return nil
        @unknown default:
            return nil
        }
    }
    
    /// Verify the transaction with StoreKit
    private func checkVerified<T>(_ result: VerificationResult<T>) throws -> T {
        switch result {
        case .unverified:
            throw StoreError.failedVerification
        case .verified(let safe):
            return safe
        }
    }
    
    enum StoreError: Error {
        case failedVerification
    }
}
import SwiftUI
import Vision
import CoreML
import CoreImage
import UIKit
import os


// MARK: - ImageEditingViewModel
class ImageEditingViewModel: ObservableObject {
    // MARK: - Published Properties
    @Published var prompt: String = ""
    @Published var editedImage: UIImage? = nil
    @Published var textResult: String = ""
    @Published var isLoading: Bool = false
    @Published var errorMessage: String = ""
    @Published var showPremiumAlert: Bool = false
    @Published var depthMapImage: UIImage? = nil  // Holds the generated depth map image
    
    // Depth model property
    var model: DepthAnythingV2SmallF16?
    
    // Proxy endpoint for your Gemini API key.
    let apiURL = URL(string: "https://gemini-proxy-flame.vercel.app/api/gemini")!
    
    // Define the target size expected by the model.
    private let targetSize = CGSize(width: 518, height: 392)
    
    // Shared CIContext instance.
    private let ciContext = CIContext()
    
    
    // New property: Public sharing checkbox state (default true)
    @Published var isPublicSharing: Bool = true
    
    // MARK: - Depth Model Loading & Depth Map Generation
    
    /// Loads your depth removal model.
    func loadModel() async throws {
        let config = MLModelConfiguration()
        config.computeUnits = .cpuOnly
        model = try DepthAnythingV2SmallF16(configuration: config)
    }
    
    
    func generateDepthMap(for image: UIImage) async {
        // Ensure the model is loaded.
        guard let depthModel = model else {
            await MainActor.run { self.errorMessage = "Model not loaded." }
            return
        }
        
        // Create a resized pixel buffer (518 x 392) using the helper extension.
        guard let resizedBuffer = image.resizedPixelBuffer(width: Int(targetSize.width), height: Int(targetSize.height)) else {
            await MainActor.run { self.errorMessage = "Failed to create resized pixel buffer." }
            return
        }
        
        // Debug: confirm the pixel buffer size.
        let w = CVPixelBufferGetWidth(resizedBuffer)
        let h = CVPixelBufferGetHeight(resizedBuffer)
        print("Pixel buffer is \(w)x\(h)")  // Should be 518x392
        
        do {
            // Run model inference synchronously.
            let prediction = try depthModel.prediction(image: resizedBuffer)
            let depthBuffer = prediction.depth
            let depthCI = CIImage(cvPixelBuffer: depthBuffer)
            
            if let cgImage = ciContext.createCGImage(depthCI, from: depthCI.extent) {
                let finalUIImage = UIImage(cgImage: cgImage)
                await MainActor.run {
                    self.depthMapImage = finalUIImage
                    print("Depth map generation successful")
                }
            }
        } catch {
            await MainActor.run {
                self.errorMessage = "Depth model error: \(error.localizedDescription)"
            }
        }
    }

    
    
    func editImage() {
        guard let image = editedImage,
              let imageData = image.jpegData(compressionQuality: 0.8)?.base64EncodedString() else {
            DispatchQueue.main.async {
                self.isLoading = false
                self.errorMessage = "No valid image selected"
            }
            return
        }
        
        isLoading = true
        errorMessage = ""
        textResult = ""
        
        let payload: [String: Any] = [
            "prompt": prompt,
            "image": imageData
        ]
        
        guard let jsonData = try? JSONSerialization.data(withJSONObject: payload) else {
            DispatchQueue.main.async {
                self.isLoading = false
                self.errorMessage = "Failed to serialize request"
            }
            return
        }
        
        var request = URLRequest(url: apiURL)
        request.httpMethod = "POST"
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")
        request.httpBody = jsonData
        
        URLSession.shared.dataTask(with: request) { [weak self] data, response, error in
            guard let self = self else { return }
            
            DispatchQueue.main.async { self.isLoading = false }
            
            if let error = error {
                DispatchQueue.main.async {
                    self.errorMessage = "Network error: \(error.localizedDescription)"
                }
                return
            }
            
            guard let data = data else {
                DispatchQueue.main.async {
                    self.errorMessage = "No data received from server"
                }
                return
            }
            
            do {
                if let jsonResponse = try JSONSerialization.jsonObject(with: data) as? [String: Any] {
                    // (Handle API error responses)
                    if let errorDict = jsonResponse["error"] as? [String: Any] {
                        let errorMessage = (errorDict["message"] as? String) ?? "Unknown error"
                        DispatchQueue.main.async {
                            self.errorMessage = "API Error: \(errorMessage)"
                        }
                        return
                    }
                    
                    // Process text and inline data responses
                    if let candidates = jsonResponse["candidates"] as? [[String: Any]],
                       let candidate = candidates.first,
                       let content = candidate["content"] as? [String: Any],
                       let parts = content["parts"] as? [[String: Any]] {
                        
                        for part in parts {
                            if let text = part["text"] as? String {
                                DispatchQueue.main.async {
                                    self.textResult += text
                                }
                            }
                            
                            if let inlineData = part["inlineData"] as? [String: Any],
                               let dataString = inlineData["data"] as? String,
                               let imageData = Data(base64Encoded: dataString),
                               let image = UIImage(data: imageData) {
                                
                                DispatchQueue.main.async {
                                    self.editedImage = image
                                }
                                
                                // Only share publicly if the toggle is on.
                             /*   if self.isPublicSharing {
                                    CloudinaryManager.upload(image: image) { secureUrl in
                                        if let url = secureUrl {
                                            print("Image uploaded to Cloudinary: \(url)")
                                            // Optionally: save the URL for your feed if needed.
                                        }
                                    }
                                }*/
                            }
                        }
                    } else {
                        let responseString = String(data: data, encoding: .utf8) ?? "Unable to parse response"
                        DispatchQueue.main.async {
                            self.textResult = "Response: \(responseString)"
                        }
                    }
                }
            } catch {
                DispatchQueue.main.async {
                    self.errorMessage = "Failed to parse response: \(error.localizedDescription)"
                    self.textResult = String(data: data, encoding: .utf8) ?? "Unable to display response"
                }
            }
        }.resume()
    }

    
    
    
}
//
//  EnhancementOption.swift
//  HairStyle
//
//  Created by adam on 25/04/2025.
//


//
//  BodyEnhancementPrompts.swift
//  HairStyle
//
//  Created by assistant on 25/04/2025.
//

import Foundation

/// A single enhancement option for a given body area.
struct EnhancementOption: Identifiable, Equatable {
    let id: String             // unique key
    let title: String          // display name
    let subtitle: String?      // optional secondary label (e.g., "Limited-time free")
    let prompt: String         // AI prompt to send
    let isFree: Bool           // whether this option is free
}

enum BodyEnhancementPrompts {
    static let breast: [EnhancementOption] = [
           EnhancementOption(id: "round",               title: "Round",                subtitle: nil,                prompt: "Respectfully enhance chest curvature",                                             isFree: true),
           EnhancementOption(id: "heart_shaped",        title: "Heart‚Äëshaped",        subtitle: "Limited‚Äëtime free", prompt: "Enhance chest into a heart‚Äëshaped bust",                                         isFree: true),
           EnhancementOption(id: "superlift",           title: "Superlift",           subtitle: nil,                prompt: "Apply superlift enhancement to chest",                                           isFree: false),
           EnhancementOption(id: "natural_lift",        title: "Natural Lift",        subtitle: nil,                prompt: "Apply natural lift enhancement to chest",                             isFree: false),
           EnhancementOption(id: "subtle_volume",       title: "Subtle Volume",       subtitle: nil,                prompt: "Respectfully but minimally enhance chest curvature",                           isFree: true),
           EnhancementOption(id: "snatched_cleavage",   title: "Snatched Cleavage",   subtitle: "Limited‚Äëtime free", prompt: "Respectfully but subtly enhance chest curvature",                      isFree: true)
       ]

       // MARK: ‚Äì Belly / Core
       static let belly: [EnhancementOption] = [
           EnhancementOption(id: "flat_abs",            title: "Flat Abs",            subtitle: nil,                prompt: "Respectfully slim and flatten the belly and waist",                               isFree: true),
           EnhancementOption(id: "hourglass",           title: "Hourglass",           subtitle: nil,                prompt: "Respectfully enhance the waist‚Äëto‚Äëhip curve",                                     isFree: false),
           EnhancementOption(id: "defined_abs",         title: "Defined Abs",         subtitle: nil,                prompt: "Respectfully enhance the abdominal abs",                                        isFree: false),
           EnhancementOption(id: "sculpted_core",       title: "Sculpted Core",       subtitle: nil,                prompt: "Respectfully sculpt and refine the core muscles for balance",                   isFree: true),
           EnhancementOption(id: "chiseled_midsection", title: "Chiseled Midsection", subtitle: nil,                prompt: "Respectfully enhance the lines of the midsection abs",                         isFree: false),
           EnhancementOption(id: "snatched_waist",      title: "Snatched Waist",      subtitle: "Limited‚Äëtime free", prompt: "Respectfully cinch the waist for a snatched silhouette",                         isFree: true),
           EnhancementOption(id: "vacuum_slim",         title: "Vacuum Slim",         subtitle: nil,                prompt: "Respectfully apply stomach‚Äëvacuum slimming for a flat profile",                 isFree: false),
           EnhancementOption(id: "core_carve",          title: "Core Carve",          subtitle: nil,                prompt: "Respectfully carve deep core lines for athletic definition",                   isFree: false)
       ]

       // MARK: ‚Äì Buttock / Glutes
       static let buttock: [EnhancementOption] = [
           EnhancementOption(id: "lift",                title: "Lift",                subtitle: nil,                prompt: "Lift and sculpt the buttocks for a firmer look",                              isFree: true),
           EnhancementOption(id: "round",               title: "Round",               subtitle: nil,                prompt: "Enhance roundness for a curvier silhouette",                                   isFree: false),
           EnhancementOption(id: "heart_shaped",        title: "Heart‚Äëshaped",        subtitle: "Limited‚Äëtime free", prompt: "Respectfully reshape glutes into a heart‚Äëshaped form",                          isFree: true),
           EnhancementOption(id: "superlift",           title: "Superlift",           subtitle: nil,                prompt: "Apply superlift enhancement to buttocks for maximum elevation",               isFree: false),
           EnhancementOption(id: "sculpted_glutes",     title: "Sculpted Glutes",     subtitle: nil,                prompt: "Respectfully define and sculpt the glute muscles for a toned look",           isFree: false),
           EnhancementOption(id: "perky",               title: "Perky",               subtitle: nil,                prompt: "Respectfully perk up the buttocks for a youthful, lifted appearance",        isFree: true),
           EnhancementOption(id: "voluminous",          title: "Voluminous",          subtitle: nil,                prompt: "Enhance volume and roundness for fuller, more pronounced glutes",            isFree: false),
           EnhancementOption(id: "peach_lift",          title: "Peach Lift",          subtitle: nil,                prompt: "Respectfully lift glutes for a peach‚Äëemoji vibe üçë",                          isFree: true),
           EnhancementOption(id: "bubble_booty",        title: "Bubble Booty",        subtitle: nil,                prompt: "Respectfully add bubble‚Äëshaped roundness for a playful look",                isFree: false),
           EnhancementOption(id: "brazilian_curve",     title: "Brazilian Curve",     subtitle: "Limited‚Äëtime free", prompt: "Respectfully enhance lower‚Äëupper glute transition for Brazilian shape",       isFree: true),
           EnhancementOption(id: "shape_360",           title: "360 Shape",           subtitle: nil,                prompt: "Respectfully smooth and contour hips & glutes for a 360¬∞ hourglass",         isFree: false)
       ]

       // MARK: ‚Äì Muscle / Arms
       static let muscle: [EnhancementOption] = [
           EnhancementOption(id: "tone",                title: "Upper Body",          subtitle: nil,                prompt: "Respectfully increase the muscle shape on neck and upper body",               isFree: true),
           EnhancementOption(id: "sculpt",              title: "Arms & Forearms",     subtitle: nil,                prompt: "Respectfully enhance the muscle shape on the arms and forearms",            isFree: false),
           EnhancementOption(id: "bicep_peak",          title: "Bicep Peak",          subtitle: nil,                prompt: "Respectfully accentuate the bicep peak for a more pronounced flex",        isFree: false),
           EnhancementOption(id: "tricep_tone",         title: "Tricep Tone",         subtitle: nil,                prompt: "Respectfully slim and tone the triceps for sleek definition",              isFree: true),
           EnhancementOption(id: "vascular_forearms",   title: "Vascular Forearms",   subtitle: "Limited‚Äëtime free", prompt: "Respectfully highlight forearm veins and muscle separation",                  isFree: true),
           EnhancementOption(id: "forearm_definition",  title: "Forearm Definition",  subtitle: nil,                prompt: "Respectfully define the forearm muscles for enhanced detail",              isFree: false),
           EnhancementOption(id: "arm_strength",        title: "Strength Boost",       subtitle: nil,                prompt: "Respectfully add subtle bulk to arms",                                   isFree: false),
           EnhancementOption(id: "swimmer_build",       title: "Swimmer Build",       subtitle: nil,                prompt: "Respectfully broaden shoulders and taper waist for swimmer aesthetics",     isFree: false),
           EnhancementOption(id: "athlete_tone",        title: "Athlete Tone",        subtitle: nil,                prompt: "Respectfully tone arms for an athletic, sporty vibe",                      isFree: true),
           EnhancementOption(id: "power_flex",          title: "Power Flex",          subtitle: "Limited‚Äëtime free", prompt: "Respectfully sharpen muscle definition for a power pose",                     isFree: true)
       ]

       // MARK: ‚Äì Waist
       static let waist: [EnhancementOption] = [
           EnhancementOption(id: "slim",                title: "Slim",                subtitle: nil,                prompt: "Slim and cinch the waist",                                               isFree: true),
           EnhancementOption(id: "curve",               title: "Curve",               subtitle: nil,                prompt: "Enhance waist curves for definition",                                   isFree: false),
           EnhancementOption(id: "v_shape",             title: "V‚ÄëShape",             subtitle: nil,                prompt: "Respectfully sculpt a tapered V‚Äëshape waist",                              isFree: false),
           EnhancementOption(id: "corset_cinch",        title: "Corset Cinch",        subtitle: "Limited‚Äëtime free", prompt: "Respectfully simulate corset‚Äëstyle waist cinching for TikTok snatch",          isFree: true)
       ]

       // MARK: ‚Äì Hair
       static let hair: [EnhancementOption] = [
           EnhancementOption(id: "volume",              title: "Volume",              subtitle: nil,                prompt: "Add natural volume and body to hair",                                    isFree: true),
           EnhancementOption(id: "smooth",              title: "Smooth",              subtitle: nil,                prompt: "Smooth hair and reduce frizz",                                          isFree: false),
           EnhancementOption(id: "silver_blonde",       title: "Silver Blonde",       subtitle: nil,                prompt: "Transform hair to a chic silver blonde shade",                            isFree: true),
           EnhancementOption(id: "bob_cut",             title: "Bob Cut",             subtitle: nil,                prompt: "Give hair a modern bob cut",                                            isFree: false),
           EnhancementOption(id: "afro",                title: "Afro",                subtitle: "Limited‚Äëtime free", prompt: "Define natural afro texture and volume",                                    isFree: true),
           EnhancementOption(id: "pixie_cut",           title: "Pixie Cut",           subtitle: nil,                prompt: "Create a stylish pixie cut",                                           isFree: false),
           EnhancementOption(id: "ombre",               title: "Ombre",               subtitle: nil,                prompt: "Add subtle ombre color blending",                                       isFree: true),
           EnhancementOption(id: "highlights",          title: "Highlights",          subtitle: nil,                prompt: "Incorporate bright highlights throughout hair",                           isFree: false),
           EnhancementOption(id: "balayage",            title: "Balayage",            subtitle: nil,                prompt: "Apply a natural balayage painting technique",                             isFree: false),
           EnhancementOption(id: "loose_curls",         title: "Loose Curls",         subtitle: nil,                prompt: "Add loose, bouncy curls for movement",                                   isFree: true),
           EnhancementOption(id: "beach_waves",         title: "Beach Waves",         subtitle: "Limited‚Äëtime free", prompt: "Create soft, effortless beach waves",                                      isFree: true),
           EnhancementOption(id: "sleek_straight",      title: "Sleek Straight",      subtitle: nil,                prompt: "Smooth hair into a sleek, straight style",                                 isFree: false),
           EnhancementOption(id: "butterfly_layers",    title: "Butterfly Layers",    subtitle: nil,                prompt: "Add TikTok trending butterfly layers for airy movement",                   isFree: true),
           EnhancementOption(id: "curtain_bangs",       title: "Curtain Bangs",       subtitle: nil,                prompt: "Add soft curtain bangs framing the face",                                isFree: false),
           EnhancementOption(id: "mermaid_waves",       title: "Mermaid Waves",       subtitle: "Limited‚Äëtime free", prompt: "Create long, flowing mermaid waves with shine",                              isFree: true),
           EnhancementOption(id: "copper_glow",         title: "Copper Glow",         subtitle: nil,                prompt: "Transform hair to a warm LA‚Äësun copper glow",                              isFree: false),
           EnhancementOption(id: "pastel_pink",         title: "Pastel Pink",         subtitle: nil,                prompt: "Tint hair a playful pastel pink",                                       isFree: false)
       ]

       // MARK: ‚Äì Nose
       static let nose: [EnhancementOption] = [
           EnhancementOption(id: "refine",              title: "Refine",              subtitle: nil,                prompt: "Refine the nose shape subtly",                                         isFree: true),
           EnhancementOption(id: "slim",                title: "Slim",                subtitle: nil,                prompt: "Slim down the nose bridge",                                           isFree: false),
           EnhancementOption(id: "button_tip",          title: "Button Tip",          subtitle: nil,                prompt: "Respectfully soften and round the nose tip for a button effect",          isFree: true),
           EnhancementOption(id: "soft_contour",        title: "Soft Contour",        subtitle: nil,                prompt: "Respectfully add gentle shadow for a softly contoured nose",             isFree: false)
       ]

       // MARK: ‚Äì Eyes
       static let eyes: [EnhancementOption] = [
           EnhancementOption(id: "brighten",            title: "Brighten",            subtitle: nil,                prompt: "Brighten eyes and reduce shadows",                                      isFree: true),
           EnhancementOption(id: "enlarge",             title: "Enlarge",             subtitle: nil,                prompt: "Subtly enlarge the eyes",                                            isFree: false),
           EnhancementOption(id: "fox_lift",            title: "Fox Lift",            subtitle: nil,                prompt: "Respectfully lift outer corners for a fox‚Äëeye trend",                   isFree: true),
           EnhancementOption(id: "doll_eyes",           title: "Doll Eyes",           subtitle: "Limited‚Äëtime free", prompt: "Respectfully widen and round eyes for a doll‚Äëlike effect",                 isFree: true),
           EnhancementOption(id: "winged_liner",        title: "Winged Liner",        subtitle: nil,                prompt: "Apply a clean winged‚Äëliner illusion for sharp definition",              isFree: false)
       ]
    static let skin: [EnhancementOption] = [
        EnhancementOption(
            id: "smooth",
            title: "Smooth",
            subtitle: nil,
            prompt: "Smooth skin texture and even tone",
            isFree: true
        ),
        EnhancementOption(
            id: "glow",
            title: "Glow",
            subtitle: nil,
            prompt: "Add a healthy, radiant glow",
            isFree: false
        )
    ]

    static let face: [EnhancementOption] = [
        EnhancementOption(
            id: "contour",
            title: "Contour",
            subtitle: nil,
            prompt: "Add subtle contour to face",
            isFree: true
        ),
        EnhancementOption(
            id: "smooth",
            title: "Smooth",
            subtitle: nil,
            prompt: "Smooth overall facial features",
            isFree: false
        )
    ]

    static let lips: [EnhancementOption] = [
        EnhancementOption(
            id: "full",
            title: "Full",
            subtitle: nil,
            prompt: "Enhance lip fullness",
            isFree: true
        ),
        EnhancementOption(
            id: "color",
            title: "Color",
            subtitle: nil,
            prompt: "Add natural lip color",
            isFree: false
        )
    ]

    static let leg: [EnhancementOption] = [
        EnhancementOption(
            id: "slim",
            title: "Slim",
            subtitle: nil,
            prompt: "Slim and lengthen legs",
            isFree: true
        ),
        EnhancementOption(
            id: "tone",
            title: "Tone",
            subtitle: nil,
            prompt: "Tone leg muscles for definition",
            isFree: false
        )
    ]
    
    static let jewellery: [EnhancementOption] = [
        EnhancementOption(
                id: "gold_hoop_minimal",
                title: "Minimal Gold Hoops",
                subtitle: nil,
                prompt: "Add sleek, minimalistic gold hoop earrings",
                isFree: true
            ),
            EnhancementOption(
                id: "delicate_gold_chain",
                title: "Delicate Gold Chain",
                subtitle: nil,
                prompt: "Add a thin, delicate gold chain necklace",
                isFree: true
            ),
            EnhancementOption(
                id: "stackable_bands",
                title: "Stackable Bands",
                subtitle: nil,
                prompt: "Add a set of minimal stackable gold rings",
                isFree: false
            ),
            EnhancementOption(
                id: "geometric_studs",
                title: "Geometric Studs",
                subtitle: nil,
                prompt: "Add small geometric stud earrings in gold",
                isFree: true
            ),
            EnhancementOption(
                id: "thin_gold_bangle",
                title: "Thin Gold Bangle",
                subtitle: nil,
                prompt: "Add a slender, minimalistic gold bangle bracelet",
                isFree: false
            ),
            EnhancementOption(
                id: "gold_bar_necklace",
                title: "Gold Bar Necklace",
                subtitle: "Limited-time free",
                prompt: "Add a minimalist gold bar pendant necklace",
                isFree: true
            ),
            EnhancementOption(
                id: "link_chain_bracelet",
                title: "Link Chain Bracelet",
                subtitle: nil,
                prompt: "Add a bold gold link chain bracelet",
                isFree: false
            ),
            EnhancementOption(
                id: "pearls_and_gold",
                title: "Pearls & Gold",
                subtitle: nil,
                prompt: "Add a blend of pearls with gold accents",
                isFree: true
            ),
            EnhancementOption(
                id: "gold_cuff_minimal",
                title: "Minimal Gold Cuff",
                subtitle: nil,
                prompt: "Add a clean, minimalistic gold cuff bracelet",
                isFree: false
            ),
            EnhancementOption(
                id: "layered_gold_chains",
                title: "Layered Gold Chains",
                subtitle: nil,
                prompt: "Add multiple thin gold chain necklaces for layering",
                isFree: false
            ),
        EnhancementOption(
            id: "earrings",
            title: "Earrings",
            subtitle: nil,
            prompt: "Add stylish earrings",
            isFree: true
        ),
        EnhancementOption(
            id: "necklace",
            title: "Necklace",
            subtitle: nil,
            prompt: "Add a beautiful necklace",
            isFree: false
        ),
        EnhancementOption(
            id: "bracelet",
            title: "Bracelet",
            subtitle: nil,
            prompt: "Add a delicate bracelet around the wrist",
            isFree: true
        ),
        EnhancementOption(
            id: "ring",
            title: "Ring",
            subtitle: nil,
            prompt: "Add a sparkling ring to the fingers",
            isFree: false
        ),
        EnhancementOption(
            id: "anklet",
            title: "Anklet",
            subtitle: "Limited-time free",
            prompt: "Add a subtle anklet for a refined touch",
            isFree: true
        ),
        EnhancementOption(
            id: "chandelier_earrings",
            title: "Chandelier Earrings",
            subtitle: nil,
            prompt: "Add elegant chandelier-style earrings",
            isFree: false
        ),
        EnhancementOption(
            id: "hoop_earrings",
            title: "Hoop Earrings",
            subtitle: nil,
            prompt: "Add classic hoop earrings",
            isFree: true
        ),
        EnhancementOption(
            id: "cuff_bracelet",
            title: "Cuff Bracelet",
            subtitle: nil,
            prompt: "Add a bold cuff bracelet to the wrist",
            isFree: false
        ),
        EnhancementOption(
            id: "choker",
            title: "Choker",
            subtitle: nil,
            prompt: "Add a sleek choker around the neck",
            isFree: true
        ),
        EnhancementOption(
            id: "pendant",
            title: "Pendant",
            subtitle: nil,
            prompt: "Add a charming pendant on a fine chain",
            isFree: false
        ),
        EnhancementOption(
            id: "brooch",
            title: "Brooch",
            subtitle: nil,
            prompt: "Add a decorative brooch for a vintage flair",
            isFree: true
        ),
        EnhancementOption(
            id: "watch",
            title: "Watch",
            subtitle: nil,
            prompt: "Add a stylish wristwatch",
            isFree: false
        )
    ]

    // New Eyewear options
    static let eyewear: [EnhancementOption] = [
        EnhancementOption(
            id: "eyewear",
            title: "Eyewear",
            subtitle: nil,
            prompt: "Add stylish eyewear frames",
            isFree: true
        ),
        EnhancementOption(
            id: "sunglasses",
            title: "Sunglasses",
            subtitle: nil,
            prompt: "Add trendy sunglasses with reflective lenses",
            isFree: false
        ),
        EnhancementOption(
            id: "reading_glasses",
            title: "Reading Glasses",
            subtitle: "Limited-time free",
            prompt: "Add elegant reading glasses with thin frames",
            isFree: true
        ),
        EnhancementOption(
            id: "aviators",
            title: "Aviator Frames",
            subtitle: nil,
            prompt: "Add classic aviator sunglasses with metal frames",
            isFree: false
        ),
        EnhancementOption(
            id: "wayfarer",
            title: "Wayfarer",
            subtitle: nil,
            prompt: "Add stylish wayfarer-style glasses",
            isFree: true
        ),
        EnhancementOption(
            id: "round_frames",
            title: "Round Frames",
            subtitle: nil,
            prompt: "Add vintage round frame glasses",
            isFree: false
        ),
        EnhancementOption(
            id: "cat_eye",
            title: "Cat-eye",
            subtitle: nil,
            prompt: "Add chic cat-eye glasses for a retro look",
            isFree: true
        ),
        EnhancementOption(
            id: "translucent_frames",
            title: "Translucent Frames",
            subtitle: nil,
            prompt: "Add translucent frame glasses with modern vibe",
            isFree: false
        ),
        EnhancementOption(
            id: "sports_goggles",
            title: "Sports Goggles",
            subtitle: nil,
            prompt: "Add sporty wrap-around goggles",
            isFree: false
        ),
        EnhancementOption(
            id: "steampunk_goggles",
            title: "Steampunk Goggles",
            subtitle: "Limited-time free",
            prompt: "Add decorative steampunk-style goggles",
            isFree: true
        )
    ]
}
//
//  ImagePicker.swift
//  HairStyle
//
//  Created by Adam Roszyk on 3/19/25.
//
import SwiftUI
import PhotosUI


// UIKit-based image picker integrated into SwiftUI using UIViewControllerRepresentable
struct ImagePicker: UIViewControllerRepresentable {
    class Coordinator: NSObject, UINavigationControllerDelegate, UIImagePickerControllerDelegate {
        let parent: ImagePicker

        init(_ parent: ImagePicker) {
            self.parent = parent
        }
        func imagePickerController(_ picker: UIImagePickerController,
                                   didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey : Any]) {
            if let uiImage = info[.originalImage] as? UIImage {
                parent.image = uiImage
            }
            picker.dismiss(animated: true)
        }
    }
    
    @Binding var image: UIImage?
    
    func makeCoordinator() -> Coordinator {
        Coordinator(self)
    }
    func makeUIViewController(context: Context) -> UIImagePickerController {
        let picker = UIImagePickerController()
        picker.delegate = context.coordinator
        return picker
    }
    func updateUIViewController(_ uiViewController: UIImagePickerController, context: Context) {}
}
import SwiftUI
import Vision
import CoreML
import CoreImage
import UIKit
import os

// MARK: - CIImage Extension
extension CIImage {
    /// Returns a resized CIImage.
    func resized(to size: CGSize) -> CIImage {
        let scaleX = size.width / extent.width
        let scaleY = size.height / extent.height
        var outputImage = transformed(by: CGAffineTransform(scaleX: scaleX, y: scaleY))
        // Reset the origin to (0,0)
        outputImage = outputImage.transformed(by: CGAffineTransform(translationX: -outputImage.extent.origin.x,
                                                                    y: -outputImage.extent.origin.y))
        return outputImage
    }
}
extension CIContext {
    /// Renders a CIImage to a new CVPixelBuffer using the specified pixel format.
    func render(_ image: CIImage, pixelFormat: OSType) -> CVPixelBuffer? {
        // Ensure valid dimensions by rounding up and enforcing a minimum value
        let width = max(Int(ceil(image.extent.width)), 1)
        let height = max(Int(ceil(image.extent.height)), 1)
        let attrs: [CFString: Any] = [
            kCVPixelBufferCGImageCompatibilityKey: true,
            kCVPixelBufferCGBitmapContextCompatibilityKey: true,
            kCVPixelBufferIOSurfacePropertiesKey: [:]
        ]
        var pixelBuffer: CVPixelBuffer?
        let status = CVPixelBufferCreate(
            kCFAllocatorDefault,
            width,
            height,
            pixelFormat,
            attrs as CFDictionary,
            &pixelBuffer
        )
        guard status == kCVReturnSuccess, let buffer = pixelBuffer else {
            print("CVPixelBufferCreate failed with status: \(status)")
            return nil
        }
        self.render(image, to: buffer)
        return buffer
    }
}


// Extension to enhance image contrast
extension UIImage {
    func applyingContrast(_ contrast: CGFloat) -> UIImage? {
        guard let cgImage = self.cgImage else { return nil }
        
        let context = CIContext()
        let ciImage = CIImage(cgImage: cgImage)
        
        let filter = CIFilter(name: "CIColorControls")
        filter?.setValue(ciImage, forKey: kCIInputImageKey)
        filter?.setValue(contrast, forKey: kCIInputContrastKey)
        filter?.setValue(0, forKey: kCIInputBrightnessKey)
        filter?.setValue(1.0, forKey: kCIInputSaturationKey)
        
        guard let outputImage = filter?.outputImage,
              let filteredCGImage = context.createCGImage(outputImage, from: outputImage.extent) else {
            return nil
        }
        
        return UIImage(cgImage: filteredCGImage, scale: self.scale, orientation: self.imageOrientation)
    }
}

extension UIImage {
    func resizedPixelBuffer(width: Int, height: Int) -> CVPixelBuffer? {
        var pxBuffer: CVPixelBuffer?
        let attrs = [
            kCVPixelBufferCGImageCompatibilityKey: true,
            kCVPixelBufferCGBitmapContextCompatibilityKey: true
        ] as CFDictionary
        
        guard CVPixelBufferCreate(kCFAllocatorDefault,
                                  width,
                                  height,
                                  kCVPixelFormatType_32ARGB,
                                  attrs,
                                  &pxBuffer) == kCVReturnSuccess,
              let buffer = pxBuffer,
              let cgImage = self.cgImage else {
            return nil
        }
        CVPixelBufferLockBaseAddress(buffer, [])
        defer { CVPixelBufferUnlockBaseAddress(buffer, []) }
        
        let context = CGContext(data: CVPixelBufferGetBaseAddress(buffer),
                                width: width,
                                height: height,
                                bitsPerComponent: 8,
                                bytesPerRow: CVPixelBufferGetBytesPerRow(buffer),
                                space: CGColorSpaceCreateDeviceRGB(),
                                bitmapInfo: CGImageAlphaInfo.noneSkipFirst.rawValue)
        guard let ctx = context else { return nil }
        
        let rect = CGRect(x: 0, y: 0, width: width, height: height)
        ctx.draw(cgImage, in: rect)
        
        return buffer
    }
}
//
//  HairStyleApp.swift
//  HairStyle
//
//  Created by Adam Roszyk on 3/19/25.
import SwiftUI

@main
struct HairStyleApp: App {
    @AppStorage("hasCompletedOnboarding") var hasCompletedOnboarding: Bool = true
    
    /// Create a single instance of SubscriptionManager
    @StateObject var subscriptionManager = SubscriptionManager()
    
    var body: some Scene {
        WindowGroup {
            if hasCompletedOnboarding {
                CatalogView()
                    .environmentObject(subscriptionManager)
            } else {
                OnboardingView()
                    .environmentObject(subscriptionManager)
            }
        }
    }
}
import SwiftUI
import Photos
import StoreKit

struct OnboardingView: View {
    @AppStorage("hasCompletedOnboarding") var hasCompletedOnboarding: Bool = false
    @AppStorage("isPremium") var isPremium: Bool = false
    
    @State private var currentPage = 0
    private let totalPages = 6

    var body: some View {
        TabView(selection: $currentPage) {
            // Page 1: Benefit 1
            OnboardingPageView(imageName: "star.fill",
                               title: "Amazing Features",
                               description: "Discover advanced AI editing to bring out your best self.",
                               onContinue: { currentPage = 1 })
                .tag(0)
            
            // Page 2: Benefit 2
            OnboardingPageView(imageName: "sparkles",
                               title: "Effortless Beauty",
                               description: "Instantly enhance your selfies with just a tap.",
                               onContinue: { currentPage = 2 })
                .tag(1)
            
            // Page 3: Benefit 3
            OnboardingPageView(imageName: "heart.fill",
                               title: "Share Your Style",
                               description: "Create stunning images and share your unique look with friends.",
                               onContinue: { currentPage = 3 })
                .tag(2)
            
            // Page 4: Photo Library Permission
            PhotoLibraryPermissionPageView(onContinue: { currentPage = 4 })
                .tag(3)
            
            // Page 5: Review Prompt
            ReviewPromptPageView(onContinue: { currentPage = 5 })
                .tag(4)
            
            // Page 6: Paywall
            PaywallPageView(isPremium: $isPremium, onComplete: completeOnboarding)
                .tag(5)
        }
        .tabViewStyle(PageTabViewStyle(indexDisplayMode: .never))
    }
    
    private func completeOnboarding() {
        hasCompletedOnboarding = true
    }
}

struct OnboardingPageView: View {
    let imageName: String
    let title: String
    let description: String
    let onContinue: () -> Void
    
    var body: some View {
        VStack(spacing: 20) {
            Spacer()
            Image(systemName: imageName)
                .resizable()
                .scaledToFit()
                .frame(width: 120, height: 120)
                .foregroundColor(.blue)
            Text(title)
                .font(.largeTitle)
                .fontWeight(.bold)
            Text(description)
                .font(.title3)
                .multilineTextAlignment(.center)
                .padding(.horizontal)
            Spacer()
            Button(action: onContinue) {
                Text("Continue")
                    .foregroundColor(.white)
                    .padding()
                    .frame(maxWidth: .infinity)
                    .background(Color.blue)
                    .cornerRadius(8)
            }
            .padding(.horizontal)
        }
    }
}

struct PhotoLibraryPermissionPageView: View {
    @State private var permissionGranted = false
    let onContinue: () -> Void

    var body: some View {
        VStack(spacing: 20) {
            Spacer()
            Image(systemName: "photo.on.rectangle.angled")
                .resizable()
                .scaledToFit()
                .frame(width: 120, height: 120)
                .foregroundColor(permissionGranted ? .green : .orange)
            Text("Photo Library Access")
                .font(.largeTitle)
                .fontWeight(.bold)
            Text("We need permission to save your edited photos to your library.")
                .font(.title3)
                .multilineTextAlignment(.center)
                .padding(.horizontal)
            Button(action: {
                PHPhotoLibrary.requestAuthorization(for: .addOnly) { status in
                    DispatchQueue.main.async {
                        permissionGranted = (status == .authorized || status == .limited)
                    }
                }
            }) {
                Text(permissionGranted ? "Permission Granted" : "Grant Photo Library Access")
                    .foregroundColor(.white)
                    .padding()
                    .frame(maxWidth: .infinity)
                    .background(permissionGranted ? Color.green : Color.blue)
                    .cornerRadius(8)
            }
            .padding(.horizontal)
            Spacer()
            Button(action: onContinue) {
                Text("Continue")
                    .foregroundColor(.white)
                    .padding()
                    .frame(maxWidth: .infinity)
                    .background(Color.blue)
                    .cornerRadius(8)
            }
            .padding(.horizontal)
        }
    }
}

struct ReviewPromptPageView: View {
    let onContinue: () -> Void

    var body: some View {
        VStack(spacing: 20) {
            Spacer()
            Image(systemName: "hand.thumbsup.fill")
                .resizable()
                .scaledToFit()
                .frame(width: 120, height: 120)
                .foregroundColor(.purple)
            Text("Enjoying the App?")
                .font(.largeTitle)
                .fontWeight(.bold)
            Text("We‚Äôd love to hear your feedback. Please take a moment to rate us!")
                .font(.title3)
                .multilineTextAlignment(.center)
                .padding(.horizontal)
            Button(action: {
                if let scene = UIApplication.shared.connectedScenes.first as? UIWindowScene {
                    SKStoreReviewController.requestReview(in: scene)
                }
            }) {
                Text("Rate Now")
                    .foregroundColor(.white)
                    .padding()
                    .frame(maxWidth: .infinity)
                    .background(Color.purple)
                    .cornerRadius(8)
            }
            .padding(.horizontal)
            Spacer()
            Button(action: onContinue) {
                Text("Continue")
                    .foregroundColor(.white)
                    .padding()
                    .frame(maxWidth: .infinity)
                    .background(Color.purple)
                    .cornerRadius(8)
            }
            .padding(.horizontal)
        }
    }
}
//
//  PaywallPageView.swift
//  HairStyle
//
//  Created by adam on 25/03/2025.
//


import SwiftUI
import StoreKit

struct PaywallPageView: View {
    /// We get the subscription manager from the environment
    @EnvironmentObject var subscriptionManager: SubscriptionManager
    
    /// This is your old @AppStorage property that indicates premium status
    @Binding var isPremium: Bool
    
    /// Called when user finishes this screen (either purchase or ‚ÄúNot Now‚Äù)
    let onComplete: () -> Void
    
    var body: some View {
        VStack(spacing: 20) {
            Spacer()
            Text("Upgrade to Premium")
                .font(.largeTitle)
                .fontWeight(.bold)
            Text("Unlock unlimited image edits. Choose your plan below:")
                .font(.title3)
                .multilineTextAlignment(.center)
                .padding(.horizontal)
            
            if subscriptionManager.subscriptions.isEmpty {
                // If the products haven't loaded yet, show a spinner
                ProgressView("Loading subscriptions...")
                    .padding()
            } else {
                // Show each subscription product
                ForEach(subscriptionManager.subscriptions) { product in
                    Button {
                        Task {
                            do {
                                // Attempt to purchase
                                let transaction = try await subscriptionManager.purchase(product)
                                if transaction != nil {
                                    // Purchase successful
                                    isPremium = true
                                    onComplete()
                                }
                            } catch {
                                print("Purchase failed: \(error)")
                            }
                        }
                    } label: {
                        // Display the product‚Äôs name and price from StoreKit
                        Text("\(product.displayName) ‚Äì \(product.displayPrice)")
                            .foregroundColor(.white)
                            .padding()
                            .frame(maxWidth: .infinity)
                            .background(Color.blue)
                            .cornerRadius(8)
                    }
                    .padding(.horizontal)
                }
            }
            
            Button(action: {
                // "Not Now" ‚Äì continue as freemium (limited to 3 generations)
                onComplete()
            }) {
                Text("Not Now")
                    .underline()
                    .foregroundColor(.gray)
            }
            Button(action: {
                if let url = URL(string: "https://example.com/terms") {
                    UIApplication.shared.open(url)
                }
            }) {
                Text("Terms of Service")
                    .underline()
                    .foregroundColor(.blue)
            }
            Spacer()
        }
        .padding(.horizontal)
    }
}
