2025-05-12 12:41:38
//
//  LoadingMessages.swift
//  HairStyle
//
//  Created by adam on 30/04/2025.
//


//  LoadingMessages.swift
//  PicUp
//  Generated 30â€‘04â€‘2025 â€“ A sprinkle of Genâ€‘Z flavoured loading banter âœ¨
//
//  Call `LoadingMessages.random()` whenever you need a fresh status line.
//  Example:
//      Text(LoadingMessages.random())
//
//  The list can be expanded or localized later.

import Foundation

enum LoadingMessages {
    static let all: [String] = [
       /* "Casting âœ¨ filtersâ€¦ hold my boba!",
        "Crunching pixels like kettle chipsâ€¦",
        "Tweaking the vibe parameters (scientifically, of course)â€¦",
        "GPU is doing burpeesâ€”almost done!",
        "Uploading imagination to the cloud â˜ï¸â€¦",
        "Painting happy little bytesâ€¦",
        "Assembling AI drip, please stand byâ€¦",
        "Turning coffee into gradientsâ€¦",
        "Charging the creativity capacitor âš¡ï¸â€¦",
        "Optimizing the funniness algorithmâ€¦",
        "Feeding hamsters more voltageâ€¦",
        "Rendering in âœ¨ Ultraâ€‘Megaâ€‘1080p âœ¨â€¦",
        "Spinning up rainbow shadersâ€¦",
        "Injecting extra serotonin into pixelsâ€¦",
        "Reticulating splines 2.0â€¦",
        "Aligning photonic chakrasâ€¦",
        "Manifesting your best selfâ€¦",
        "Negotiating with the color wheelâ€¦",
        "Loading swag assets (almost there)â€¦",
        "Finalizing epicnessâ€”do not unplug!",*/
        "Personalizing lookâ€¦ âœ¨",
        "Matching shadesâ€¦ ðŸ’„",
        "Crafting routineâ€¦ ðŸ“",
        "Virtual tryâ€‘onâ€¦ ðŸ¤³",
        "Beauty tipsâ€¦ ðŸ’¡",
        "Natural glowâ€¦ ðŸŒŸ",
        "Perfect combosâ€¦ ðŸ”„",
        "Loading paletteâ€¦ ðŸŽ¨",
        "Nextâ€‘level glamâ€¦ ðŸš€",
        "Highlighting youâ€¦ âœ¨",
        "Color matchâ€¦ ðŸŽ¯",
        "Beauty roadmapâ€¦ ðŸ—ºï¸",
        "Refining lookâ€¦ ðŸ”§",
        "Pro tutorialsâ€¦ ðŸŽ¥",
        "Mood tuneâ€¦ ðŸŽ­",
        "Stepâ€‘byâ€‘stepâ€¦ ðŸ“š",
        "Dream vibeâ€¦ âœ¨",
        "Beauty upgradeâ€¦ ðŸ”’",
        "Unlock VIPâ€¦ ðŸ”“",
        "Premium awaitsâ€¦ ðŸ’Ž",
        "Subscribe nowâ€¦ ðŸ·ï¸",
        "Pro toolsâ€¦ ðŸ› ï¸",
        "Go PREMIUM! ðŸš¨",
        "Glam boostâ€¦ ðŸŒˆ",
        "Beauty perksâ€¦ âš¡ï¸",
        "Luxe filtersâ€¦ ðŸ’¼",
        "Almost readyâ€¦ ðŸ¥‚",
        "Get VIP accessâ€¦ ðŸŒŸ"
    ]

    /// Returns a random playful loading string.
    static func random() -> String {
        all.randomElement() ?? "Generatingâ€¦ hang tight!"
    }
}
import SwiftUI

// MARK: â€“ Photo / slider view
 struct PhotoWithRefreshOverlay: View {
    // Inputs
    let originalImage: UIImage?
    let editedImage: UIImage?
    let depthMapImage: UIImage?
    let isGenerating: Bool
    @Binding var sliderPosition: CGFloat
    @Binding var showSlider: Bool
    let onReplaceTap: () -> Void
    let onAddTap: () -> Void
    let onSaveTap: () -> Void

    // Zoom / pan state omitted for brevity â€“ unchanged from earlier version

    var body: some View {
        ZStack {
            contentView
        }
    }

    @ViewBuilder private var contentView: some View {
        if let orig = originalImage, let edit = editedImage {
            Image(uiImage: edit).resizable().scaledToFit()
        } else if let edit = editedImage {
            Image(uiImage: edit).resizable().scaledToFit()
        } else {
            EmptyStateView(onAddTap: onAddTap, isGenerating: isGenerating)
        }
    }
}


struct EmptyStateView: View {
    let onAddTap: () -> Void
    let isGenerating: Bool

    @State private var shineAdd = false

    var body: some View {
        VStack {
            Spacer()
            if isGenerating {
                Text(LoadingMessages.random())
                    .font(.headline)
                    .multilineTextAlignment(.center)
                    .foregroundColor(.white)
                    .padding()
            } else {
                Button(action: {
                    shineAdd = false
                    onAddTap()
                }) {
                    VStack(spacing: 12) {
                        Image(systemName: "photo.fill.on.rectangle.fill")
                            .font(.system(size: 40))
                        Text("Add Image +")
                            .font(.headline)
                    }
                    .foregroundColor(.black)
                    .padding()
                    .background(Color.white)
                    .cornerRadius(12)
                    .shadow(radius: 10)
                    // shimmer overlay
                    .overlay(
                        Rectangle()
                            .fill(
                                LinearGradient(
                                    gradient: Gradient(colors: [Color.white.opacity(0.1), Color.white.opacity(0.4), Color.white.opacity(0.1)]),
                                    startPoint: .leading,
                                    endPoint: .trailing
                                )
                            )
                            .rotationEffect(.degrees(30))
                            .offset(x: shineAdd ? 200 : -200)
                            .mask(RoundedRectangle(cornerRadius: 12))
                    )
                }
                .onAppear {
                    withAnimation(Animation.linear(duration: 1.5).repeatForever(autoreverses: false)) {
                        shineAdd = true
                    }
                }
            }
            Spacer()
        }
    }
}

// MARK: â€“ Stub generation worker
 enum ImageEditingWorker {
    static func generate(input: UIImage, prompt: String) async -> UIImage? {
        let vm = ImageEditingViewModel()
        do {
            try await vm.loadModel()
            vm.editedImage = input
            vm.prompt = prompt
            await MainActor.run { vm.editImage() }
            while await MainActor.run(body: { vm.isLoading }) {
                if #available(iOS 16.0, *) {
                    try? await Task.sleep(for: .milliseconds(100))
                } else {
                    // Fallback on earlier versions
                }
            }
            return await MainActor.run(body: { vm.editedImage })
        } catch {
            print("Generation failed: \(error)")
            return nil
        }
    }
}
import SwiftUI

/// The enhancement panel shows a scroll of options and a bottom bar.
/// It pre-selects the first option automatically.
import SwiftUI

struct BottomBar: View {
    let iconAssetName: String?
    let onCancel: () -> Void
    let onApply: () -> Void
    let canApply: Bool

    @State private var shineApply = false

    var body: some View {
        HStack {
            // Cancel
            Button(action: onCancel) {
                Label("Cancel", systemImage: "xmark")
                    .font(.headline)
                    .foregroundColor(.white)
                    .padding(.vertical, 14)
                    .padding(.horizontal, 20)
            }

            Spacer()

            // Icon
            if let asset = iconAssetName {
                Image(asset)
                    .resizable()
                    .aspectRatio(contentMode: .fit)
                    .frame(width: 44, height: 44)
            }

            Spacer()

            // Apply with shimmer when canApply
            Button(action: onApply) {
                Label("Apply", systemImage: "checkmark")
                    .font(.headline)
                    .foregroundColor(.white)
                    .padding(.vertical, 12)
                    .padding(.horizontal, 24)
                    .background(
                        // use the mask & moving gradient
                        RoundedRectangle(cornerRadius: 24)
                            .fill(Color.clear)
                            .overlay(
                                Group {
                                    if canApply {
                                        Rectangle()
                                            .fill(
                                                LinearGradient(
                                                    gradient: Gradient(colors: [
                                                        Color.black.opacity(0.1),
                                                        Color.black.opacity(0.3),
                                                        Color.black.opacity(0.1)
                                                    ]),
                                                    startPoint: .leading,
                                                    endPoint: .trailing
                                                )
                                            )
                                            .rotationEffect(.degrees(30))
                                            .offset(x: shineApply ? 200 : -200)
                                            .mask(RoundedRectangle(cornerRadius: 24))
                                            .animation(
                                                Animation
                                                    .linear(duration: 2.5)
                                                    .repeatForever(autoreverses: false),
                                                value: shineApply
                                            )
                                    }
                                }
                            )
                    )
            }
            .onAppear {
                // kick it off if we're already allowed
                if canApply {
                    shineApply = true
                }
            }
            .onChange(of: canApply) { newValue in
                // whenever we flip to true, reset & start the shimmer
                if newValue {
                    shineApply = false
                    shineApply = true
                } else {
                    shineApply = false
                }
            }
        }
        .padding(.horizontal, 7)
        .padding(.bottom, 20)
    }
}

// EnhancementPanelView itself
struct EnhancementPanelView: View {
    let section: String
    let options: [EnhancementOption]
    @Binding var selectedOption: EnhancementOption?
    let applyAction: () -> Void
    let cancelAction: () -> Void

    var body: some View {
        VStack(spacing: 12) {
            PillsScroll(options: options, selectedOption: $selectedOption)
            Divider().background(Color.white.opacity(0.5))
            BottomBar(
                iconAssetName: sectionIconName,
                onCancel: cancelAction,
                onApply: applyAction,
                canApply: selectedOption != nil
            )
        }
        .background(.ultraThinMaterial)
        .cornerRadius(16)
        .padding(.horizontal, 16)
        .padding(.bottom, 8)
        .padding(.top, 12)
        .onAppear {
            // Pre-select first option
            if selectedOption == nil, let first = options.first {
                selectedOption = first
            }
        }
    }

    private var sectionIconName: String {
        section.replacingOccurrences(of: " ", with: "")
    }
}




// MARK: â€” Pills Scroll
private struct PillsScroll: View {
    let options: [EnhancementOption]
    @Binding var selectedOption: EnhancementOption?

    var body: some View {
        ScrollView(.horizontal, showsIndicators: false) {
            HStack(spacing: 16) {
                ForEach(options) { opt in
                    OptionPill(
                        option: opt,
                        isSelected: opt.id == selectedOption?.id
                    )
                    .onTapGesture { selectedOption = opt }
                }
            }
            .padding(.horizontal, 16)
            .padding(.bottom, 8)
            .padding(.top, 12)
        }
    }
}

// MARK: â€” Single Pill
private struct OptionPill: View {
    let option: EnhancementOption
    let isSelected: Bool

    private var iconName: String {
        switch option.id {
        case "round":        return "circle"
        case "heart_shaped": return "heart.fill"
        case "superlift":    return "flame.fill"
        default:             return "sparkles"
        }
    }

    private var titleColor: AnyShapeStyle {
        if isSelected {
            AnyShapeStyle(
                LinearGradient(
                    colors: [Color.pink, Color.orange],
                    startPoint: .leading,
                    endPoint: .trailing
                )
            )
        } else {
            AnyShapeStyle(Color.white.opacity(0.9))
        }
    }

    var body: some View {
        HStack(spacing: 12) {
            Image(systemName: iconName)
                .font(.subheadline)
                .foregroundColor(isSelected ? .white : .white.opacity(0.7))
            Text(option.title)
                .font(.subheadline)
                .fontWeight(.medium)
                .foregroundStyle(titleColor)
        }
        .padding(.vertical, 12)
        .padding(.horizontal, 20)
        .background(isSelected ? Color.black.opacity(0.85) : Color.black.opacity(0.6))
        .cornerRadius(24)
        .overlay(
            Group {
                if isSelected {
                    Image(systemName: "checkmark.circle.fill")
                        .font(.title3)
                        .foregroundColor(.white)
                        .offset(x: 8, y: -8)
                }
            }, alignment: .topTrailing
        )
    }
}
//
//  OnboardingFlowView.swift
//  HairStyle
//
//  Pink-gradient, pill-style onboarding that matches the mock-ups.
//  Pages:
//    1. Budget picker
//    2. Skill-level picker
//    3. Social-proof / rate-us
//    4. Notification permission
//    5. Paywall (your existing WeeklyPaywallView)
//
//  Drop this file in; no other changes needed.
//

import SwiftUI
import StoreKit                     // rating
import UserNotifications            // notification prompt

// MARK: â€“ Entry point
struct OnboardingFlowView: View {
    @AppStorage("hasCompletedOnboarding") private var hasCompletedOnboarding = false
    @AppStorage("isPremium")              private var isPremium              = false
    
    @EnvironmentObject private var subscriptionManager: SubscriptionManager
    @State private var page = 0
    
    var body: some View {
        TabView(selection: $page) {
            
            BudgetPage     { page += 1 }.tag(0)
            SkillPage      { page += 1 }.tag(1)
            ReviewPage     { page += 1 }.tag(2)
            NotifyPage     { page += 1 }.tag(3)
            
            WeeklyPaywallView(                      // existing paywall
                thumbs:        subscriptionManager.previewThumbs,
                onUnlock:      { isPremium = true;  hasCompletedOnboarding = true },
                onClose:       { /* not shown in onboarding */ }
            )
            .environmentObject(subscriptionManager)
            .tag(4)
        }
        .tabViewStyle(.page(indexDisplayMode: .never))
        .ignoresSafeArea()
    }
}

// MARK: â€“ Common styling helpers
private struct GradientBackground<Content: View>: View {
    let content: () -> Content
    var body: some View {
        LinearGradient(
            gradient: Gradient(colors: [
                Color(red: 1, green: 0.95, blue: 0.96),
                Color(red: 1, green: 0.87, blue: 0.90)
            ]),
            startPoint: .top, endPoint: .bottom)
        .ignoresSafeArea()
        .overlay(content())
    }
}

private struct Pill: View {
    let title: String
    var body: some View {
        Text(title)
            .font(.headline.weight(.semibold))
            .padding(.vertical, 12)
            .padding(.horizontal, 30)
            .background(Color.white)
            .cornerRadius(26)
            .shadow(color: Color.black.opacity(0.06), radius: 4, x: 0, y: 2)
    }
}

// MARK: â€“ â¶ Budget
private struct BudgetPage: View {
    let onContinue: () -> Void
    @State private var selection: String?
    
    private let options: [(emoji: String, text: String)] = [
        ("âœ¨", "Light"),
        ("ðŸ’„", "Affordable"),
        ("ðŸ’°", "High-end"),
        ("ðŸ›ï¸", "Elite")
    ]
    
    var body: some View {
        GradientBackground {
            VStack(spacing: 40) {
                
                Spacer().frame(height: 60)
                
                Text("What's your\nbudget?")
                    .font(.largeTitle.bold())
                    .multilineTextAlignment(.center)
                
                VStack(spacing: 20) {
                    ForEach(options, id: \.text) { item in
                        Button {
                            selection = item.text
                        } label: {
                            Pill(title: "\(item.emoji) \(item.text)")
                                .overlay(
                                    RoundedRectangle(cornerRadius: 26)
                                        .stroke(Color.black.opacity(
                                            selection == item.text ? 0.4 : 0
                                        ), lineWidth: 2)
                                )
                        }
                    }
                }
                
                Spacer()
                
                Button(action: onContinue) {
                    Text("Continue")
                        .font(.headline)
                        .frame(maxWidth: .infinity)
                        .padding(.vertical, 18)
                        .background(Color.white)
                        .cornerRadius(32)
                }
                .padding(.horizontal, 40)
                .opacity(selection == nil ? 0.4 : 1)
                .disabled(selection == nil)
                
                Spacer().frame(height: 30)
            }
            .padding(.horizontal)
        }
    }
}

// MARK: â€“ â· Skill level
private struct SkillPage: View {
    let onContinue: () -> Void
    @State private var selection: String?
    
    private let options: [(emoji: String, text: String)] = [
        ("ðŸƒ", "Beginner"),
        ("âœ¨", "Intermediate"),
        ("ðŸ’„", "Expert"),
        ("ðŸŽ¨", "Pro")
    ]
    
    var body: some View {
        GradientBackground {
            VStack(spacing: 40) {
                
                Spacer().frame(height: 60)
                
                Text("How would you rate\nyour makeup skills?")
                    .font(.largeTitle.bold())
                    .multilineTextAlignment(.center)
                
                VStack(spacing: 20) {
                    ForEach(options, id: \.text) { item in
                        Button {
                            selection = item.text
                        } label: {
                            Pill(title: "\(item.emoji) \(item.text)")
                                .overlay(
                                    RoundedRectangle(cornerRadius: 26)
                                        .stroke(Color.black.opacity(
                                            selection == item.text ? 0.4 : 0
                                        ), lineWidth: 2)
                                )
                        }
                    }
                }
                
                Spacer()
                
                Button(action: onContinue) {
                    Text("Continue")
                        .font(.headline)
                        .frame(maxWidth: .infinity)
                        .padding(.vertical, 18)
                        .background(Color.white)
                        .cornerRadius(32)
                }
                .padding(.horizontal, 40)
                .opacity(selection == nil ? 0.4 : 1)
                .disabled(selection == nil)
                
                Spacer().frame(height: 30)
            }
            .padding(.horizontal)
        }
    }
}

// MARK: â€“ â¸ Review / social proof
private struct ReviewPage: View {
    let onContinue: () -> Void
    
    var body: some View {
        GradientBackground {
            VStack(spacing: 32) {
                
                Spacer().frame(height: 60)
                
                Text("Trusted by Over\n1+ Million People!")
                    .font(.largeTitle.bold())
                    .multilineTextAlignment(.center)
                
                Image("kiss_placeholder")            // replace w/ asset
                    .resizable()
                    .scaledToFit()
                    .frame(width: 200)
                    .padding(.vertical, 10)
                
                HStack(spacing: 4) {
                    ForEach(0..<5) { _ in Image(systemName: "star.fill") }
                }
                .foregroundColor(.yellow)
                .font(.largeTitle)
                
                Spacer()
                
                Button {
                    rateNow()
                    onContinue()
                } label: {
                    Text("Leave a Review! ðŸ¥°")
                        .font(.headline)
                        .frame(maxWidth: .infinity)
                        .padding(.vertical, 18)
                        .background(Color.white)
                        .cornerRadius(32)
                }
                .padding(.horizontal, 40)
                
                Spacer().frame(height: 30)
            }
            .padding(.horizontal)
        }
    }
    
    private func rateNow() {
        if let scene = UIApplication.shared.connectedScenes.first as? UIWindowScene {
            SKStoreReviewController.requestReview(in: scene)
        }
    }
}

// MARK: â€“ â¹ Notification permission
private struct NotifyPage: View {
    let onContinue: () -> Void
    @State private var isRequesting = false
    
    var body: some View {
        GradientBackground {
            VStack(spacing: 32) {
                
                Spacer().frame(height: 60)
                
                Text("Allow Notifications")
                    .font(.largeTitle.bold())
                    .multilineTextAlignment(.center)
                
                // illustrative mock (replace with real asset if desired)
                Image(systemName: "app.badge.fill")
                    .resizable()
                    .scaledToFit()
                    .frame(width: 180)
                    .foregroundColor(.pink)
                    .padding(.vertical)
                
                Spacer()
                
                Button {
                    requestPermission()
                } label: {
                    Text("Enable notifications! ðŸ¥°")
                        .font(.headline)
                        .frame(maxWidth: .infinity)
                        .padding(.vertical, 18)
                        .background(Color.white)
                        .cornerRadius(32)
                }
                .padding(.horizontal, 40)
                .opacity(isRequesting ? 0.5 : 1)
                .disabled(isRequesting)
                
                Spacer().frame(height: 30)
            }
            .padding(.horizontal)
        }
    }
    
    private func requestPermission() {
        isRequesting = true
        UNUserNotificationCenter.current()
            .requestAuthorization(options: [.alert, .sound, .badge]) { _, _ in
                DispatchQueue.main.async {
                    isRequesting = false
                    onContinue()
                }
            }
    }
}
//
//  PhotoContainerView.swift
//  HairStyle
//
//  Created by adam on 25/04/2025.
//

import SwiftUI

// MARK: â€“ Photo container
 struct PhotoContainerView: View {
    @Binding var inputImage: UIImage?
    let isGenerating: Bool
    let editedImage: UIImage?
    let depthMapImage: UIImage?
    @Binding var sliderPosition: CGFloat
    @Binding var showSlider: Bool
    let onAddTap: () -> Void
    let onReplaceTap: () -> Void
    let onSaveTap: () -> Void

    var body: some View {
        ZStack {
            backgroundView.ignoresSafeArea()
            PhotoWithRefreshOverlay(
                originalImage: inputImage,
                editedImage: editedImage,
                depthMapImage: depthMapImage,
                isGenerating: isGenerating,
                sliderPosition: $sliderPosition,
                showSlider: $showSlider,
                onReplaceTap: onReplaceTap,
                onAddTap: onAddTap,
                onSaveTap: onSaveTap
            )
        }
    }

    @ViewBuilder private var backgroundView: some View {
        if let img = inputImage {
            Image(uiImage: img).resizable().scaledToFill().blur(radius: 120).overlay(Color.black.opacity(0.4))
        } else {
            Color.black.opacity(0.6)
        }
    }
}
import SwiftUI
import UIKit
import StoreKit

// MARK: â€“ Thumbnail item model -------------------------------------------------
struct ThumbItem: Identifiable {
    /// id == -1 â†’ original; 0â€¦3 â†’ generated slots
    let id: Int
    var image: UIImage? = nil
    var isLoading: Bool = false
    var isOriginal: Bool { id == -1 }
}

// MARK: â€“ GenView --------------------------------------------------------------
struct GenView: View {
    // MARK: Inputs
    let section: String

    // MARK: View-model
    @StateObject private var viewModel = ImageEditingViewModel()

    // MARK: UI state
    @State private var selectedOption: EnhancementOption?
    @State private var inputImage: UIImage?
    @State private var showingImagePicker = false
    @State private var sliderPosition: CGFloat = 0.5
    @State private var showSlider = false
    @State private var showSaveSuccessAlert = false

    // thumbnails: original + generated
    @State private var thumbs: [ThumbItem] = []
    @State private var currentIdx: Int? = nil

    // paywall modal flag
    @State private var showPaywallModal = false

    // MARK: Environment
    @Environment(\.dismiss) private var dismiss
    @EnvironmentObject private var subscriptionManager: SubscriptionManager

    // Derived
    private var isGenerating: Bool { thumbs.contains { !$0.isOriginal && $0.isLoading } }
    private var hasThumbs: Bool { !thumbs.isEmpty }
    private var shouldShowPaywall: Bool {
        !subscriptionManager.purchasedIdentifiers.contains("weeksub")
        && thumbs.count >= 5
        && thumbs.dropFirst().allSatisfy { !$0.isLoading }
    }

    // MARK: Body ----------------------------------------------------------------
    var body: some View {
        ZStack {
            GeometryReader { geo in
                PhotoContainerView(
                    inputImage: $inputImage,
                    isGenerating: isGenerating,
                    editedImage: mainDisplayedImage,
                    depthMapImage: viewModel.depthMapImage,
                    sliderPosition: $sliderPosition,
                    showSlider: $showSlider,
                    onAddTap: handleReplacePhoto,
                    onReplaceTap: handleReplacePhoto,
                    onSaveTap: saveImage
                )
                .frame(width: geo.size.width, height: geo.size.height)
                .ignoresSafeArea()

                if inputImage != nil {
                    TopButtons(
                        onBack: { dismiss() },
                        onReplace: handleReplacePhoto,
                        onShare: shareImage,
                        onSave: saveImage,
                        topInset: -20
                    )
                    .padding(.horizontal, 16)
                }

                VStack {
                    Spacer()
                    if hasThumbs {
                        ThumbnailsStrip(
                            thumbs: thumbs,
                            onSelect: { currentIdx = $0 },
                            onRetry: beginParallelGeneration
                        )
                    } else {
                        EnhancementPanelView(
                            section: section,
                            options: enhancementOptions,
                            selectedOption: $selectedOption,
                            applyAction: beginParallelGeneration,
                            cancelAction: { dismiss() }
                        )
                    }
                }
                .frame(width: geo.size.width)
            }
        }
        .navigationBarBackButtonHidden(true)
        .overlay {
            if isGenerating {
                Color.black.opacity(0.35).ignoresSafeArea()
                ProgressView()
                    .progressViewStyle(CircularProgressViewStyle(tint: .white))
                    .scaleEffect(2)
            }
        }
        .sheet(isPresented: $showingImagePicker, onDismiss: loadImage) {
            ImagePicker(image: $inputImage)
        }
        .alert("Saved", isPresented: $showSaveSuccessAlert) {
            Button("OK", role: .cancel) {}
        } message: { Text("Image saved to Photos") }
        .onChange(of: shouldShowPaywall) { if $0 { showPaywallModal = true } }
        .fullScreenCover(isPresented: $showPaywallModal) {
            WeeklyPaywallView(
                thumbs: thumbs,
                onUnlock: { showPaywallModal = false },
                onClose: {
                    showPaywallModal = false
                    dismiss()
                }
            )
            .environmentObject(subscriptionManager)
        }
    }

    // MARK: Helpers ------------------------------------------------------------
    private var mainDisplayedImage: UIImage? {
        guard let idx = currentIdx, thumbs.indices.contains(idx) else {
            return viewModel.editedImage
        }
        return idx == 0 ? inputImage : thumbs[idx].image
    }

    // MARK: Generation ----------------------------------------------------------
    private func beginParallelGeneration() {
        guard let base = inputImage, let prompt = selectedOption?.prompt else { return }
        thumbs = [ThumbItem(id: -1, image: base, isLoading: false)] +
                 (0..<4).map { ThumbItem(id: $0, isLoading: true) }
        currentIdx = 1
        Task.detached(priority: .userInitiated) {
            await withTaskGroup(of: (Int, UIImage?).self) { group in
                for idx in 0..<4 {
                    group.addTask { (idx, await ImageEditingWorker.generate(input: base, prompt: prompt)) }
                }
                for await (idx, img) in group {
                    await MainActor.run {
                        thumbs[idx + 1].image = img
                        thumbs[idx + 1].isLoading = false
                    }
                }
            }
        }
    }

    // MARK: UI actions ---------------------------------------------------------
    private func handleReplacePhoto() { showingImagePicker = true }
    private func loadImage() {
        guard let img = inputImage else { return }
        viewModel.editedImage = img
        thumbs.removeAll()
        currentIdx = nil
    }
    private func saveImage() {
        guard let img = mainDisplayedImage else { return }
        UIImageWriteToSavedPhotosAlbum(img, nil, nil, nil)
        showSaveSuccessAlert = true
    }
    private func shareImage() {
        guard let img = mainDisplayedImage else { return }
        let av = UIActivityViewController(activityItems: [img], applicationActivities: nil)
        UIApplication.shared.windows.first?.rootViewController?.present(av, animated: true)
    }

    // MARK: Enhancement options -----------------------------------------------
    private var enhancementOptions: [EnhancementOption] {
        switch section {
        case "Chest":    return BodyEnhancementPrompts.breast
        case "Belly":    return BodyEnhancementPrompts.belly
        case "Buttock":  return BodyEnhancementPrompts.buttock
        case "Muscle":   return BodyEnhancementPrompts.muscle
        case "Hair":     return BodyEnhancementPrompts.hair
        case "Nose":     return BodyEnhancementPrompts.nose
        case "Eyes":     return BodyEnhancementPrompts.eyes
        case "Skin":     return BodyEnhancementPrompts.skin
        case "Face":     return BodyEnhancementPrompts.face
        case "Lips":     return BodyEnhancementPrompts.lips
        case "Waist":    return BodyEnhancementPrompts.waist
        case "Legs":     return BodyEnhancementPrompts.leg
        case "jewellery":return BodyEnhancementPrompts.jewellery
        case "Eyewear":  return BodyEnhancementPrompts.eyewear
        default:          return []
        }
    }
}

 struct ThumbnailsStrip: View {
    let thumbs: [ThumbItem]
    let onSelect: (Int) -> Void
    let onRetry: () -> Void
    var isGenerating: Bool { thumbs.contains { !$0.isOriginal && $0.isLoading } }

    var body: some View {
        ScrollView(.horizontal, showsIndicators: false) {
            HStack(spacing: 16) {
                ForEach(thumbs) { thumb in
                    ZStack {
                        // image or placeholder
                        Group {
                            if let ui = thumb.image {
                                Image(uiImage: ui)
                                    .resizable()
                                    .aspectRatio(contentMode: .fill)
                            } else {
                                Color.gray.opacity(0.3)
                            }
                        }
                        .frame(width: 70, height: 70)
                        .clipped()
                        .cornerRadius(12)

                        // centered spinner
                        if thumb.isLoading {
                            ProgressView()
                                .progressViewStyle(CircularProgressViewStyle(tint: .white))
                        }

                        // bottom â€œORIGINALâ€ badge
                        if thumb.isOriginal {
                            VStack {
                                Spacer()
                                Text("ORIGINAL")
                                    .font(.caption2.weight(.bold))
                                    .foregroundColor(.white)
                                    .padding(.vertical, 2)
                                    .frame(maxWidth: .infinity)
                                    .background(Color.black.opacity(0.6))
                            }
                        }
                    }
                    .frame(width: 70, height: 70)
                    .onTapGesture { onSelect(thumb.id == -1 ? 0 : thumb.id + 1) }
                }

                // retry buttonâ€¦
                Button(action: onRetry) {
                    ZStack {
                        Color.black.opacity(0.6)
                        Image(systemName: "arrow.clockwise")
                            .font(.title3.weight(.semibold))
                            .foregroundColor(.white)
                    }
                    .frame(width: 70, height: 70)
                    .cornerRadius(12)
                    .overlay(isGenerating ? Color.black.opacity(0.4).cornerRadius(12) : nil)
                }
                .disabled(isGenerating)
            }
            .padding(.horizontal, 16)
            .padding(.vertical, 8)
        }
        .background(.ultraThinMaterial)
        .cornerRadius(16)
    }
}


private struct TopButtons: View {
    let onBack, onReplace, onShare, onSave: () -> Void
    let topInset: CGFloat
    var body: some View {
        HStack(spacing: 12) {
            Button(action: onBack)    { Image(systemName: "chevron.left").modifier(circleIcon) }
            Button(action: onReplace) { Image(systemName: "arrow.triangle.2.circlepath").modifier(circleIcon) }
            Spacer()
            HStack(spacing: 12) {
                Button(action: onShare) { Image(systemName: "paperplane.fill").modifier(circleIcon) }
                Button(action: onSave)  { Image(systemName: "square.and.arrow.down").modifier(circleIcon) }
            }
        }
        .padding(.top, topInset + 20)
    }
    private var circleIcon: some ViewModifier { CircleIcon() }
}
private struct CircleIcon: ViewModifier {
    func body(content: Content) -> some View {
        content
            .font(.system(size: 20, weight: .medium))
            .foregroundColor(.white)
            .frame(width: 36, height: 36)
            .background(Color.black.opacity(0.6))
            .clipShape(Circle())
    }
}
import SwiftUI

struct CatalogView: View {
    // MARK: â€” Data
    private let bodyShapeItems: [(title: String, icon: String)] = [
        ("Chest Curve",   "Chest"),
        ("Flat Abs",      "Belly"),
        ("Buttocks+",     "Buttock"),
        ("Slim Waist",    "Waist"),
        ("Legs",          "Legs"),
        ("Muscles",       "Muscle")
    ]

    private let facialItems: [(title: String, icon: String)] = [
        ("Face",          "Face"),
        ("Eyes",          "Eyes"),
        ("Nose",          "Nose"),
        ("Lips",          "Lips"),
        ("Skin",          "Skin")
    ]

    private let hairAccessoryItems: [(title: String, icon: String)] = [
        ("Hair",          "Hair"),
        ("Jewellery",     "jewellery"),
        ("Eyewear",       "Eyewear")
    ]

    // Three flexible columns
    private let columns = Array(
        repeating: GridItem(.flexible(), spacing: 16),
        count: 3
    )

    var body: some View {
        NavigationView {
            ScrollView {
                VStack(alignment: .leading, spacing: 32) {

                    // MARK: â€” Header
                    HStack {
                        Text("BodyEditor Ai")
                            .font(.largeTitle).fontWeight(.bold)
                            .foregroundStyle(
                                LinearGradient(
                                    gradient: Gradient(colors: [Color.pink, Color.orange]),
                                    startPoint: .center,
                                    endPoint: .trailing
                                )
                            )
                        Spacer()
                    }
                    .padding(.horizontal)

                    // MARK: â€” Body Shape Section
                    SectionGrid(
                        title: "Body Shape",
                        items: bodyShapeItems,
                        columns: columns
                    )

                    // MARK: â€” Facial Section
                    SectionGrid(
                        title: "Facial",
                        items: facialItems,
                        columns: columns
                    )

                    // MARK: â€” Hair & Accessories Section
                    SectionGrid(
                        title: "Hair & Accessories",
                        items: hairAccessoryItems,
                        columns: columns
                    )
                }
                .padding(.vertical)
            }
            .background(Color(red: 0.14, green: 0.13, blue: 0.13).edgesIgnoringSafeArea(.all))
            .navigationBarHidden(true)
        }
    }
}

private struct SectionGrid: View {
    let title: String
    let items: [(title: String, icon: String)]
    let columns: [GridItem]

    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text(title)
                .font(.headline)
                .foregroundColor(.white)
                .padding(.horizontal)

            LazyVGrid(columns: columns, alignment: .leading, spacing: 16) {
                ForEach(items, id: \.title) { item in
                    NavigationLink(
                        destination: GenView(section: item.icon)
                    ) {
                        VStack(spacing: 8) {
                            // Circular icon background
                            ZStack {
                                RoundedRectangle(cornerRadius: 18)
                                    .fill(Color.black.opacity(0.6))
                                    .frame(width: 70, height: 70)
                                    .shadow(color: Color.white.opacity(0.2),
                                            radius: 6,
                                            x: 0,
                                            y: 0)

                                Image(item.icon)
                                    .resizable()
                                    .aspectRatio(contentMode: .fit)
                                    .frame(width: 50, height: 50)
                            }
                            
                            Text(item.title)
                                .font(.caption)
                                .multilineTextAlignment(.center)
                                .foregroundColor(.white)
                        }
                        .frame(maxWidth: .infinity)
                    }
                }
            }
            .padding(.horizontal)
        }
    }
}

struct CatalogView_Previews: PreviewProvider {
    static var previews: some View {
        CatalogView()
            .preferredColorScheme(.dark)
    }
}
import SwiftUI
import StoreKit

struct WeeklyPaywallView: View {
    @EnvironmentObject var subscriptionManager: SubscriptionManager
    let thumbs: [ThumbItem]
    let onUnlock: () -> Void
    let onClose: () -> Void

    @State private var closeDisabled = true
    @State private var currentPage = 0
    // ðŸ‘‡ new state for the bounce
    @State private var bounceOffset: CGFloat = 0
    @State private var hasBounced   = false     // ensures it fires only once
    // ðŸ”¸ NEW: scale for the Unlock button pulse
    @State private var buttonScale: CGFloat = 1.0

    private var weeklyProduct: Product? {
        subscriptionManager.subscriptions.first { $0.id == "weeksub" }
    }
    private var imageSize: CGFloat { UIScreen.main.bounds.width * 0.7 }

    var body: some View {
        ZStack(alignment: .topLeading) {
            // MARK: â€” Background Gradient
            LinearGradient(
                gradient: Gradient(colors: [
                    Color(red:1, green:0.95, blue:0.96),
                    Color(red:1, green:0.87, blue:0.90)
                ]),
                startPoint: .top,
                endPoint: .bottom
            )
            .ignoresSafeArea()

            // MARK: â€” Close Button
            Button(action: onClose) {
                Image(systemName: "xmark")
                    .font(.system(size: 15, weight: .medium))
                    .foregroundColor(.black)
                    .opacity(closeDisabled ? 0.3 : 0.6)
                    .padding(24)
            }
            .disabled(closeDisabled)
            .contentShape(Rectangle())
            .zIndex(1)

            VStack(spacing: 24) {
                Spacer().frame(height: 60)

                // MARK: â€” Headline (no truncation)
                Text("GET YOUR DREAM APPEARANCE!")
                    .font(.largeTitle).bold()
                    .foregroundColor(.black)
                    .multilineTextAlignment(.center)
                    .fixedSize(horizontal: false, vertical: true)

                Text("Proven to help you transform your beauty routine.")
                    .font(.subheadline)
                    .foregroundColor(.gray)
                    .multilineTextAlignment(.center)
                    .fixedSize(horizontal: false, vertical: true)
                    .padding(.horizontal, 32)

                // MARK: â€” Carousel & Dots
                Text("Reveal what you'll look like ðŸ‘€")
                    .font(.headline)
                    .foregroundColor(.black)

                TabView(selection: $currentPage) {
                    ForEach(thumbs.indices, id: \.self) { idx in
                        if let ui = thumbs[idx].image {
                            Image(uiImage: ui)
                                .resizable()
                                .scaledToFill()
                                .frame(width: imageSize, height: imageSize)
                                .blur(radius: 6)
                                .mask(RoundedRectangle(cornerRadius: 16))
                                .overlay(
                                    RoundedRectangle(cornerRadius: 16)
                                        .stroke(Color.white.opacity(0.6), lineWidth: 4)
                                )
                                .tag(idx)
                                .offset(x: idx == 0 ? bounceOffset : 0)
                        }
                    }
                }
                .tabViewStyle(PageTabViewStyle(indexDisplayMode: .never))
                .frame(height: imageSize)

                HStack(spacing: 8) {
                    ForEach(0..<thumbs.count, id: \.self) { dot in
                        Circle()
                            .frame(width: 8, height: 8)
                            .foregroundColor(dot == currentPage ? .black : .gray)
                    }
                }

                Text("1,000,000+ beauty upgrades created")
                    .font(.caption)
                    .foregroundColor(.gray)

                // MARK: â€” Unlock Button (white pill)
                Button(action: purchaseWeekly) {
                    Text("Unlock Now")
                        .font(.title3).bold()
                        .foregroundColor(.black)
                        .frame(maxWidth: .infinity)
                        .padding(.vertical, 16)
                        .background(Color.white)
                        .cornerRadius(30)
                        .shadow(color: Color.black.opacity(0.1), radius: 4, x: 0, y: 2)
                }
                .padding(.horizontal, 32)
                .disabled(weeklyProduct == nil)
                .scaleEffect(buttonScale)
                
                // MARK: â€” Renewal Info
                (Text("Renews Weekly at ")
                 + Text(weeklyProduct?.displayPrice ?? "â€“")
                        .bold()
                        .foregroundColor(.black)      // price only â†’ black
                )
                .font(.callout)
                .foregroundColor(.gray)

                Spacer()

                // MARK: â€” Footer Links
                HStack {
                    Button("Terms of Use")     { openURL("https://active-outcome.vercel.app/beautyCam") }
                    Spacer()
                    Button("Restore Purchase"){ Task { await restore() } }
                    Spacer()
                    Button("Privacy Policy")   { openURL("https://active-outcome.vercel.app/beautyCam") }
                }
                .font(.footnote)
                .foregroundColor(.gray)
                .padding(.horizontal, 32)

                Spacer().frame(height: 20)
            }
        }
        .onAppear {
            DispatchQueue.main.asyncAfter(deadline: .now() + 9) {
                withAnimation { closeDisabled = false }
            }
            
            // ðŸ‘‰ schedule a single left-nudge bounce after 0.8 s
            guard !hasBounced else { return }
            hasBounced = true
            DispatchQueue.main.asyncAfter(deadline: .now() + 3) {
                withAnimation(.easeInOut(duration: 0.28)) {
                    bounceOffset = -16          // nudge left â‰ˆ thumb-width cue
                }
                // spring back
                DispatchQueue.main.asyncAfter(deadline: .now() + 0.28) {
                    withAnimation(.interpolatingSpring(stiffness: 220, damping: 18)) {
                        bounceOffset = 0
                    }
                }
            }
            
            
            // ðŸ”¸ schedule the Unlock-button pulse 5 s after appear
            DispatchQueue.main.asyncAfter(deadline: .now() + 7) {
                withAnimation(.easeInOut(duration: 0.4)) {
                    buttonScale = 1.1            // grow ~8 %
                }
                // snap back
                DispatchQueue.main.asyncAfter(deadline: .now() + 0.4) {
                    withAnimation(.easeInOut(duration: 0.4)) {
                        buttonScale = 1.0
                    }
                }
            }
        }
        
    }

    private func purchaseWeekly() {
        guard let p = weeklyProduct else { return }
        Task {
            if (try? await subscriptionManager.purchase(p)) != nil {
                onUnlock()
            }
        }
    }

    private func restore() async {
        for await verification in Transaction.currentEntitlements {
            if case .verified(let t) = verification, t.productID == "weeksub" {
                onUnlock()
                break
            }
        }
    }

    private func openURL(_ s: String) {
        if let url = URL(string: s) {
            UIApplication.shared.open(url)
        }
    }
}
import SwiftUI
import Photos
import StoreKit

struct OnboardingView: View {
    @AppStorage("hasCompletedOnboarding") var hasCompletedOnboarding: Bool = false
    @AppStorage("isPremium") var isPremium: Bool = false
    
    @State private var currentPage = 0
    private let totalPages = 6

    var body: some View {
        TabView(selection: $currentPage) {
            // Page 1: Benefit 1
            OnboardingPageView(imageName: "star.fill",
                               title: "Amazing Features",
                               description: "Discover advanced AI editing to bring out your best self.",
                               onContinue: { currentPage = 1 })
                .tag(0)
            
            // Page 2: Benefit 2
            OnboardingPageView(imageName: "sparkles",
                               title: "Effortless Beauty",
                               description: "Instantly enhance your selfies with just a tap.",
                               onContinue: { currentPage = 2 })
                .tag(1)
            
            // Page 3: Benefit 3
            OnboardingPageView(imageName: "heart.fill",
                               title: "Share Your Style",
                               description: "Create stunning images and share your unique look with friends.",
                               onContinue: { currentPage = 3 })
                .tag(2)
            
            // Page 4: Photo Library Permission
            PhotoLibraryPermissionPageView(onContinue: { currentPage = 4 })
                .tag(3)
            
            // Page 5: Review Prompt
            ReviewPromptPageView(onContinue: { currentPage = 5 })
                .tag(4)
            
            // Page 6: Paywall
            PaywallPageView(isPremium: $isPremium, onComplete: completeOnboarding)
                .tag(5)
        }
        .tabViewStyle(PageTabViewStyle(indexDisplayMode: .never))
    }
    
    private func completeOnboarding() {
        hasCompletedOnboarding = true
    }
}

struct OnboardingPageView: View {
    let imageName: String
    let title: String
    let description: String
    let onContinue: () -> Void
    
    var body: some View {
        VStack(spacing: 20) {
            Spacer()
            Image(systemName: imageName)
                .resizable()
                .scaledToFit()
                .frame(width: 120, height: 120)
                .foregroundColor(.blue)
            Text(title)
                .font(.largeTitle)
                .fontWeight(.bold)
            Text(description)
                .font(.title3)
                .multilineTextAlignment(.center)
                .padding(.horizontal)
            Spacer()
            Button(action: onContinue) {
                Text("Continue")
                    .foregroundColor(.white)
                    .padding()
                    .frame(maxWidth: .infinity)
                    .background(Color.blue)
                    .cornerRadius(8)
            }
            .padding(.horizontal)
        }
    }
}

struct PhotoLibraryPermissionPageView: View {
    @State private var permissionGranted = false
    let onContinue: () -> Void

    var body: some View {
        VStack(spacing: 20) {
            Spacer()
            Image(systemName: "photo.on.rectangle.angled")
                .resizable()
                .scaledToFit()
                .frame(width: 120, height: 120)
                .foregroundColor(permissionGranted ? .green : .orange)
            Text("Photo Library Access")
                .font(.largeTitle)
                .fontWeight(.bold)
            Text("We need permission to save your edited photos to your library.")
                .font(.title3)
                .multilineTextAlignment(.center)
                .padding(.horizontal)
            Button(action: {
                PHPhotoLibrary.requestAuthorization(for: .addOnly) { status in
                    DispatchQueue.main.async {
                        permissionGranted = (status == .authorized || status == .limited)
                    }
                }
            }) {
                Text(permissionGranted ? "Permission Granted" : "Grant Photo Library Access")
                    .foregroundColor(.white)
                    .padding()
                    .frame(maxWidth: .infinity)
                    .background(permissionGranted ? Color.green : Color.blue)
                    .cornerRadius(8)
            }
            .padding(.horizontal)
            Spacer()
            Button(action: onContinue) {
                Text("Continue")
                    .foregroundColor(.white)
                    .padding()
                    .frame(maxWidth: .infinity)
                    .background(Color.blue)
                    .cornerRadius(8)
            }
            .padding(.horizontal)
        }
    }
}

struct ReviewPromptPageView: View {
    let onContinue: () -> Void

    var body: some View {
        VStack(spacing: 20) {
            Spacer()
            Image(systemName: "hand.thumbsup.fill")
                .resizable()
                .scaledToFit()
                .frame(width: 120, height: 120)
                .foregroundColor(.purple)
            Text("Enjoying the App?")
                .font(.largeTitle)
                .fontWeight(.bold)
            Text("Weâ€™d love to hear your feedback. Please take a moment to rate us!")
                .font(.title3)
                .multilineTextAlignment(.center)
                .padding(.horizontal)
            Button(action: {
                if let scene = UIApplication.shared.connectedScenes.first as? UIWindowScene {
                    SKStoreReviewController.requestReview(in: scene)
                }
            }) {
                Text("Rate Now")
                    .foregroundColor(.white)
                    .padding()
                    .frame(maxWidth: .infinity)
                    .background(Color.purple)
                    .cornerRadius(8)
            }
            .padding(.horizontal)
            Spacer()
            Button(action: onContinue) {
                Text("Continue")
                    .foregroundColor(.white)
                    .padding()
                    .frame(maxWidth: .infinity)
                    .background(Color.purple)
                    .cornerRadius(8)
            }
            .padding(.horizontal)
        }
    }
}
//
//  PaywallPageView.swift
//  HairStyle
//
//  Created by adam on 25/03/2025.
//


import SwiftUI
import StoreKit

struct PaywallPageView: View {
    /// We get the subscription manager from the environment
    @EnvironmentObject var subscriptionManager: SubscriptionManager
    
    /// This is your old @AppStorage property that indicates premium status
    @Binding var isPremium: Bool
    
    /// Called when user finishes this screen (either purchase or â€œNot Nowâ€)
    let onComplete: () -> Void
    
    var body: some View {
        VStack(spacing: 20) {
            Spacer()
            Text("Upgrade to Premium")
                .font(.largeTitle)
                .fontWeight(.bold)
            Text("Unlock unlimited image edits. Choose your plan below:")
                .font(.title3)
                .multilineTextAlignment(.center)
                .padding(.horizontal)
            
            if subscriptionManager.subscriptions.isEmpty {
                // If the products haven't loaded yet, show a spinner
                ProgressView("Loading subscriptions...")
                    .padding()
            } else {
                // Show each subscription product
                ForEach(subscriptionManager.subscriptions) { product in
                    Button {
                        Task {
                            do {
                                // Attempt to purchase
                                let transaction = try await subscriptionManager.purchase(product)
                                if transaction != nil {
                                    // Purchase successful
                                    isPremium = true
                                    onComplete()
                                }
                            } catch {
                                print("Purchase failed: \(error)")
                            }
                        }
                    } label: {
                        // Display the productâ€™s name and price from StoreKit
                        Text("\(product.displayName) â€“ \(product.displayPrice)")
                            .foregroundColor(.white)
                            .padding()
                            .frame(maxWidth: .infinity)
                            .background(Color.blue)
                            .cornerRadius(8)
                    }
                    .padding(.horizontal)
                }
            }
            
            Button(action: {
                // "Not Now" â€“ continue as freemium (limited to 3 generations)
                onComplete()
            }) {
                Text("Not Now")
                    .underline()
                    .foregroundColor(.gray)
            }
            Button(action: {
                if let url = URL(string: "https://example.com/terms") {
                    UIApplication.shared.open(url)
                }
            }) {
                Text("Terms of Service")
                    .underline()
                    .foregroundColor(.blue)
            }
            Spacer()
        }
        .padding(.horizontal)
    }
}
//
//  SubscriptionManager.swift
//  HairStyle
//
//  Created by adam on 25/03/2025.
//


import StoreKit
import SwiftUI

@MainActor
class SubscriptionManager: ObservableObject {
    /// The subscription products fetched from StoreKit configuration
    @Published var subscriptions: [Product] = []
    
    /// Keep track of purchased product identifiers
    @Published var purchasedIdentifiers = Set<String>()
    
    /// Task to listen for any subscription updates
    private var updates: Task<Void, Never>?
    
    /// Define your product IDs exactly as they appear in your StoreKit config
    private let productIDs = [
        "weeksub"
    ]
    
    init() {
        // Start listening for transaction updates
        updates = listenForTransactions()
        
        // Immediately fetch products and update purchased info
        Task {
            await requestProducts()
            await updatePurchasedIdentifiers()
        }
    }
    
    /// Request products from StoreKit
    func requestProducts() async {
        do {
            let storeProducts = try await Product.products(for: productIDs)
            subscriptions = storeProducts
        } catch {
            print("Failed to request products: \(error)")
        }
    }
    
    /// Listen for any transaction updates (e.g., renewals, cancellations)
    private func listenForTransactions() -> Task<Void, Never> {
        Task.detached { [weak self] in
            guard let self = self else { return }
            for await result in Transaction.updates {
                do {
                    let transaction = try await self.checkVerified(result)
                    // If transaction is verified, apply changes
                    await self.updatePurchasedIdentifiers()
                    await transaction.finish()
                } catch {
                    print("Transaction failed verification")
                }
            }
        }
    }
    
    /// Update purchased identifiers from current entitlements
    private func updatePurchasedIdentifiers() async {
        purchasedIdentifiers.removeAll()
        for await verificationResult in Transaction.currentEntitlements {
            do {
                let transaction = try checkVerified(verificationResult)
                purchasedIdentifiers.insert(transaction.productID)
            } catch {
                // Not verified
            }
        }
    }
    
    /// Purchase a specific product
    func purchase(_ product: Product) async throws -> StoreKit.Transaction? {
        let result = try await product.purchase()
        switch result {
        case .success(let verification):
            let transaction = try checkVerified(verification)
            await transaction.finish()
            await updatePurchasedIdentifiers()
            return transaction
        case .userCancelled, .pending:
            return nil
        @unknown default:
            return nil
        }
    }
    
    /// Verify the transaction with StoreKit
    private func checkVerified<T>(_ result: VerificationResult<T>) throws -> T {
        switch result {
        case .unverified:
            throw StoreError.failedVerification
        case .verified(let safe):
            return safe
        }
    }
    
    enum StoreError: Error {
        case failedVerification
    }
}
import SwiftUI
import Vision
import CoreML
import CoreImage
import UIKit
import os


// MARK: - ImageEditingViewModel
class ImageEditingViewModel: ObservableObject {
    // MARK: - Published Properties
    @Published var prompt: String = ""
    @Published var editedImage: UIImage? = nil
    @Published var textResult: String = ""
    @Published var isLoading: Bool = false
    @Published var errorMessage: String = ""
    @Published var showPremiumAlert: Bool = false
    @Published var depthMapImage: UIImage? = nil  // Holds the generated depth map image
    
    // Depth model property
    //var model: DepthAnythingV2SmallF16?
    
    // Proxy endpoint for your Gemini API key.
    let apiURL = URL(string: "https://gemini-proxy-flame.vercel.app/api/gemini")! // earlier was https://gemini-proxy-flame.vercel.app/api/gemini
    
    // Define the target size expected by the model.
    private let targetSize = CGSize(width: 518, height: 392)
    
    // Shared CIContext instance.
    private let ciContext = CIContext()
    
    
    // New property: Public sharing checkbox state (default true)
    @Published var isPublicSharing: Bool = true
    
    // MARK: - Depth Model Loading & Depth Map Generation
    
    /// Loads your depth removal model.
    func loadModel() async throws {
        let config = MLModelConfiguration()
        config.computeUnits = .cpuOnly
       // model = try DepthAnythingV2SmallF16(configuration: config)
    }
    
    /*
    func generateDepthMap(for image: UIImage) async {
        // Ensure the model is loaded.
        guard let depthModel = model else {
            await MainActor.run { self.errorMessage = "Model not loaded." }
            return
        }
        
        // Create a resized pixel buffer (518 x 392) using the helper extension.
        guard let resizedBuffer = image.resizedPixelBuffer(width: Int(targetSize.width), height: Int(targetSize.height)) else {
            await MainActor.run { self.errorMessage = "Failed to create resized pixel buffer." }
            return
        }
        
        // Debug: confirm the pixel buffer size.
        let w = CVPixelBufferGetWidth(resizedBuffer)
        let h = CVPixelBufferGetHeight(resizedBuffer)
        print("Pixel buffer is \(w)x\(h)")  // Should be 518x392
        
        do {
            // Run model inference synchronously.
            let prediction = try depthModel.prediction(image: resizedBuffer)
            let depthBuffer = prediction.depth
            let depthCI = CIImage(cvPixelBuffer: depthBuffer)
            
            if let cgImage = ciContext.createCGImage(depthCI, from: depthCI.extent) {
                let finalUIImage = UIImage(cgImage: cgImage)
                await MainActor.run {
                    self.depthMapImage = finalUIImage
                    print("Depth map generation successful")
                }
            }
        } catch {
            await MainActor.run {
                self.errorMessage = "Depth model error: \(error.localizedDescription)"
            }
        }
    }

    */
    
    func editImage() {
        guard let image = editedImage,
              let imageData = image.jpegData(compressionQuality: 0.8)?.base64EncodedString() else {
            DispatchQueue.main.async {
                self.isLoading = false
                self.errorMessage = "No valid image selected"
            }
            return
        }
        
        isLoading = true
        errorMessage = ""
        textResult = ""
        
        let payload: [String: Any] = [
            "prompt": prompt,
            "image": imageData
        ]
        
        guard let jsonData = try? JSONSerialization.data(withJSONObject: payload) else {
            DispatchQueue.main.async {
                self.isLoading = false
                self.errorMessage = "Failed to serialize request"
            }
            return
        }
        
        var request = URLRequest(url: apiURL)
        request.httpMethod = "POST"
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")
        request.httpBody = jsonData
        
        URLSession.shared.dataTask(with: request) { [weak self] data, response, error in
            guard let self = self else { return }
            
            DispatchQueue.main.async { self.isLoading = false }
            
            if let error = error {
                DispatchQueue.main.async {
                    self.errorMessage = "Network error: \(error.localizedDescription)"
                }
                return
            }
            
            guard let data = data else {
                DispatchQueue.main.async {
                    self.errorMessage = "No data received from server"
                }
                return
            }
            
            do {
                if let jsonResponse = try JSONSerialization.jsonObject(with: data) as? [String: Any] {
                    // (Handle API error responses)
                    if let errorDict = jsonResponse["error"] as? [String: Any] {
                        let errorMessage = (errorDict["message"] as? String) ?? "Unknown error"
                        DispatchQueue.main.async {
                            self.errorMessage = "API Error: \(errorMessage)"
                        }
                        return
                    }
                    
                    // Process text and inline data responses
                    if let candidates = jsonResponse["candidates"] as? [[String: Any]],
                       let candidate = candidates.first,
                       let content = candidate["content"] as? [String: Any],
                       let parts = content["parts"] as? [[String: Any]] {
                        
                        for part in parts {
                            if let text = part["text"] as? String {
                                DispatchQueue.main.async {
                                    self.textResult += text
                                }
                            }
                            
                            if let inlineData = part["inlineData"] as? [String: Any],
                               let dataString = inlineData["data"] as? String,
                               let imageData = Data(base64Encoded: dataString),
                               let image = UIImage(data: imageData) {
                                
                                DispatchQueue.main.async {
                                    self.editedImage = image
                                }
                                
                                // Only share publicly if the toggle is on.
                             /*   if self.isPublicSharing {
                                    CloudinaryManager.upload(image: image) { secureUrl in
                                        if let url = secureUrl {
                                            print("Image uploaded to Cloudinary: \(url)")
                                            // Optionally: save the URL for your feed if needed.
                                        }
                                    }
                                }*/
                            }
                        }
                    } else {
                        let responseString = String(data: data, encoding: .utf8) ?? "Unable to parse response"
                        DispatchQueue.main.async {
                            self.textResult = "Response: \(responseString)"
                        }
                    }
                }
            } catch {
                DispatchQueue.main.async {
                    self.errorMessage = "Failed to parse response: \(error.localizedDescription)"
                    self.textResult = String(data: data, encoding: .utf8) ?? "Unable to display response"
                }
            }
        }.resume()
    }

    
    
    
}
//
//  EnhancementOption.swift
//  HairStyle
//
//  Created by adam on 25/04/2025.
//


//
//  BodyEnhancementPrompts.swift
//  HairStyle
//
//  Created by assistant on 25/04/2025.
//

import Foundation

/// A single enhancement option for a given body area.
struct EnhancementOption: Identifiable, Equatable {
    let id: String             // unique key
    let title: String          // display name
    let subtitle: String?      // optional secondary label (e.g., "Limited-time free")
    let prompt: String         // AI prompt to send
    let isFree: Bool           // whether this option is free
}

enum BodyEnhancementPrompts {
    static let breast: [EnhancementOption] = [
           EnhancementOption(id: "round",               title: "Round",                subtitle: nil,                prompt: "Respectfully enhance chest curvature",                                             isFree: true),
           EnhancementOption(id: "heart_shaped",        title: "Heartâ€‘shaped",        subtitle: "Limitedâ€‘time free", prompt: "Enhance chest into a heartâ€‘shaped bust",                                         isFree: true),
           EnhancementOption(id: "superlift",           title: "Superlift",           subtitle: nil,                prompt: "Apply superlift enhancement to chest",                                           isFree: false),
           EnhancementOption(id: "natural_lift",        title: "Natural Lift",        subtitle: nil,                prompt: "Apply natural lift enhancement to chest",                             isFree: false),
           EnhancementOption(id: "subtle_volume",       title: "Subtle Volume",       subtitle: nil,                prompt: "Respectfully but minimally enhance chest curvature",                           isFree: true),
           EnhancementOption(id: "snatched_cleavage",   title: "Snatched Cleavage",   subtitle: "Limitedâ€‘time free", prompt: "Respectfully but subtly enhance chest curvature",                      isFree: true)
       ]

       // MARK: â€“ Belly / Core
       static let belly: [EnhancementOption] = [
           EnhancementOption(id: "flat_abs",            title: "Flat Abs",            subtitle: nil,                prompt: "Respectfully slim and flatten the belly and waist",                               isFree: true),
           EnhancementOption(id: "hourglass",           title: "Hourglass",           subtitle: nil,                prompt: "Respectfully enhance the waistâ€‘toâ€‘hip curve",                                     isFree: false),
           EnhancementOption(id: "defined_abs",         title: "Defined Abs",         subtitle: nil,                prompt: "Respectfully enhance the abdominal abs",                                        isFree: false),
           EnhancementOption(id: "sculpted_core",       title: "Sculpted Core",       subtitle: nil,                prompt: "Respectfully sculpt and refine the core muscles for balance",                   isFree: true),
           EnhancementOption(id: "chiseled_midsection", title: "Chiseled Midsection", subtitle: nil,                prompt: "Respectfully enhance the lines of the midsection abs",                         isFree: false),
           EnhancementOption(id: "snatched_waist",      title: "Snatched Waist",      subtitle: "Limitedâ€‘time free", prompt: "Respectfully cinch the waist for a snatched silhouette",                         isFree: true),
           EnhancementOption(id: "vacuum_slim",         title: "Vacuum Slim",         subtitle: nil,                prompt: "Respectfully apply stomachâ€‘vacuum slimming for a flat profile",                 isFree: false),
           EnhancementOption(id: "core_carve",          title: "Core Carve",          subtitle: nil,                prompt: "Respectfully carve deep core lines for athletic definition",                   isFree: false)
       ]

       // MARK: â€“ Buttock / Glutes
       static let buttock: [EnhancementOption] = [
           EnhancementOption(id: "lift",                title: "Lift",                subtitle: nil,                prompt: "Lift and sculpt the buttocks for a firmer look",                              isFree: true),
           EnhancementOption(id: "round",               title: "Round",               subtitle: nil,                prompt: "Enhance roundness for a curvier silhouette",                                   isFree: false),
           EnhancementOption(id: "heart_shaped",        title: "Heartâ€‘shaped",        subtitle: "Limitedâ€‘time free", prompt: "Respectfully reshape glutes into a heartâ€‘shaped form",                          isFree: true),
           EnhancementOption(id: "superlift",           title: "Superlift",           subtitle: nil,                prompt: "Apply superlift enhancement to buttocks for maximum elevation",               isFree: false),
           EnhancementOption(id: "sculpted_glutes",     title: "Sculpted Glutes",     subtitle: nil,                prompt: "Respectfully define and sculpt the glute muscles for a toned look",           isFree: false),
           EnhancementOption(id: "perky",               title: "Perky",               subtitle: nil,                prompt: "Respectfully perk up the buttocks for a youthful, lifted appearance",        isFree: true),
           EnhancementOption(id: "voluminous",          title: "Voluminous",          subtitle: nil,                prompt: "Enhance volume and roundness for fuller, more pronounced glutes",            isFree: false),
           EnhancementOption(id: "peach_lift",          title: "Peach Lift",          subtitle: nil,                prompt: "Respectfully lift glutes for a peachâ€‘emoji vibe ðŸ‘",                          isFree: true),
           EnhancementOption(id: "bubble_booty",        title: "Bubble Booty",        subtitle: nil,                prompt: "Respectfully add bubbleâ€‘shaped roundness for a playful look",                isFree: false),
           EnhancementOption(id: "brazilian_curve",     title: "Brazilian Curve",     subtitle: "Limitedâ€‘time free", prompt: "Respectfully enhance lowerâ€‘upper glute transition for Brazilian shape",       isFree: true),
           EnhancementOption(id: "shape_360",           title: "360 Shape",           subtitle: nil,                prompt: "Respectfully smooth and contour hips & glutes for a 360Â° hourglass",         isFree: false)
       ]

       // MARK: â€“ Muscle / Arms
       static let muscle: [EnhancementOption] = [
           EnhancementOption(id: "tone",                title: "Upper Body",          subtitle: nil,                prompt: "Respectfully increase the muscle shape on neck and upper body",               isFree: true),
           EnhancementOption(id: "sculpt",              title: "Arms & Forearms",     subtitle: nil,                prompt: "Respectfully enhance the muscle shape on the arms and forearms",            isFree: false),
           EnhancementOption(id: "bicep_peak",          title: "Bicep Peak",          subtitle: nil,                prompt: "Respectfully accentuate the bicep peak for a more pronounced flex",        isFree: false),
           EnhancementOption(id: "tricep_tone",         title: "Tricep Tone",         subtitle: nil,                prompt: "Respectfully slim and tone the triceps for sleek definition",              isFree: true),
           EnhancementOption(id: "vascular_forearms",   title: "Vascular Forearms",   subtitle: "Limitedâ€‘time free", prompt: "Respectfully highlight forearm veins and muscle separation",                  isFree: true),
           EnhancementOption(id: "forearm_definition",  title: "Forearm Definition",  subtitle: nil,                prompt: "Respectfully define the forearm muscles for enhanced detail",              isFree: false),
           EnhancementOption(id: "arm_strength",        title: "Strength Boost",       subtitle: nil,                prompt: "Respectfully add subtle bulk to arms",                                   isFree: false),
           EnhancementOption(id: "swimmer_build",       title: "Swimmer Build",       subtitle: nil,                prompt: "Respectfully broaden shoulders and taper waist for swimmer aesthetics",     isFree: false),
           EnhancementOption(id: "athlete_tone",        title: "Athlete Tone",        subtitle: nil,                prompt: "Respectfully tone arms for an athletic, sporty vibe",                      isFree: true),
           EnhancementOption(id: "power_flex",          title: "Power Flex",          subtitle: "Limitedâ€‘time free", prompt: "Respectfully sharpen muscle definition for a power pose",                     isFree: true)
       ]
    
    // MARK: â€“ Waist
    static let waist: [EnhancementOption] = [
        // Existing
        EnhancementOption(id: "slim",             title: "Slim",             subtitle: nil,                prompt: "Slim and cinch the waist",                                                     isFree: true),
        EnhancementOption(id: "curve",            title: "Curve",            subtitle: nil,                prompt: "Enhance waist curves for definition",                                         isFree: false),
        EnhancementOption(id: "v_shape",          title: "V-Shape",          subtitle: nil,                prompt: "Respectfully sculpt a tapered V-shape waist",                                  isFree: false),
        EnhancementOption(id: "corset_cinch",     title: "Corset Cinch",     subtitle: "Limited-time free", prompt: "Respectfully simulate corset-style waist cinching for TikTok snatch",           isFree: true),

        // New additions
        EnhancementOption(id: "hourglass",        title: "Hourglass",        subtitle: nil,                prompt: "Respectfully sculpt an hourglass silhouette",                                  isFree: false),
        EnhancementOption(id: "micro_cinch",      title: "Micro Cinch",      subtitle: "Limited-time free", prompt: "Respectfully simulate an ultra-cinched micro waist",                           isFree: true),
        EnhancementOption(id: "athletic_tone",    title: "Athletic Tone",    subtitle: nil,                prompt: "Define a toned, athletic waistline",                                           isFree: false),
        EnhancementOption(id: "balanced_curve",   title: "Balanced Curve",   subtitle: nil,                prompt: "Add gentle definition for a balanced waist curve",                             isFree: true),
        EnhancementOption(id: "dream_sculpt",     title: "Dream Sculpt",     subtitle: nil,                prompt: "Sculpt a dreamy snatched waistline fit for viral looks",                       isFree: false),
        EnhancementOption(id: "vapor_snatch",     title: "Vapor Snatch",     subtitle: "Limited-time free", prompt: "Respectfully vapor-snatch the waist for an ethereal cinched look",             isFree: true),
        EnhancementOption(id: "soft_taper",       title: "Soft Taper",       subtitle: nil,                prompt: "Create a soft, natural waist taper",                                           isFree: true),
        EnhancementOption(id: "precision_trim",   title: "Precision Trim",   subtitle: nil,                prompt: "Apply precise trimming for a sleek waist contour",                             isFree: false)
    ]


       // MARK: â€“ Hair
       static let hair: [EnhancementOption] = [
           EnhancementOption(id: "volume",              title: "Volume",              subtitle: nil,                prompt: "Add natural volume and body to hair",                                    isFree: true),
           EnhancementOption(id: "smooth",              title: "Smooth",              subtitle: nil,                prompt: "Smooth hair and reduce frizz",                                          isFree: false),
           EnhancementOption(id: "silver_blonde",       title: "Silver Blonde",       subtitle: nil,                prompt: "Transform hair to a chic silver blonde shade",                            isFree: true),
           EnhancementOption(id: "bob_cut",             title: "Bob Cut",             subtitle: nil,                prompt: "Give hair a modern bob cut",                                            isFree: false),
           EnhancementOption(id: "afro",                title: "Afro",                subtitle: "Limitedâ€‘time free", prompt: "Define natural afro texture and volume",                                    isFree: true),
           EnhancementOption(id: "pixie_cut",           title: "Pixie Cut",           subtitle: nil,                prompt: "Create a stylish pixie cut",                                           isFree: false),
           EnhancementOption(id: "ombre",               title: "Ombre",               subtitle: nil,                prompt: "Add subtle ombre color blending",                                       isFree: true),
           EnhancementOption(id: "highlights",          title: "Highlights",          subtitle: nil,                prompt: "Incorporate bright highlights throughout hair",                           isFree: false),
           EnhancementOption(id: "balayage",            title: "Balayage",            subtitle: nil,                prompt: "Apply a natural balayage painting technique",                             isFree: false),
           EnhancementOption(id: "loose_curls",         title: "Loose Curls",         subtitle: nil,                prompt: "Add loose, bouncy curls for movement",                                   isFree: true),
           EnhancementOption(id: "beach_waves",         title: "Beach Waves",         subtitle: "Limitedâ€‘time free", prompt: "Create soft, effortless beach waves",                                      isFree: true),
           EnhancementOption(id: "sleek_straight",      title: "Sleek Straight",      subtitle: nil,                prompt: "Smooth hair into a sleek, straight style",                                 isFree: false),
           EnhancementOption(id: "butterfly_layers",    title: "Butterfly Layers",    subtitle: nil,                prompt: "Add TikTok trending butterfly layers for airy movement",                   isFree: true),
           EnhancementOption(id: "curtain_bangs",       title: "Curtain Bangs",       subtitle: nil,                prompt: "Add soft curtain bangs framing the face",                                isFree: false),
           EnhancementOption(id: "mermaid_waves",       title: "Mermaid Waves",       subtitle: "Limitedâ€‘time free", prompt: "Create long, flowing mermaid waves with shine",                              isFree: true),
           EnhancementOption(id: "copper_glow",         title: "Copper Glow",         subtitle: nil,                prompt: "Transform hair to a warm LAâ€‘sun copper glow",                              isFree: false),
           EnhancementOption(id: "pastel_pink",         title: "Pastel Pink",         subtitle: nil,                prompt: "Tint hair a playful pastel pink",                                       isFree: false)
       ]
    // MARK: â€“ Nose
    static let nose: [EnhancementOption] = [
        // Existing
        EnhancementOption(id: "refine",           title: "Refine",            subtitle: nil,                 prompt: "Refine the nose shape subtly",                                                      isFree: true),
        EnhancementOption(id: "slim",             title: "Slim",              subtitle: nil,                 prompt: "Slim down the nose bridge",                                                        isFree: false),
        EnhancementOption(id: "button_tip",       title: "Button Tip",        subtitle: nil,                 prompt: "Respectfully soften and round the nose tip for a button effect",                  isFree: true),
        EnhancementOption(id: "soft_contour",     title: "Soft Contour",      subtitle: nil,                 prompt: "Respectfully add gentle shadow for a softly contoured nose",                      isFree: false),

        // New additions
        EnhancementOption(id: "pixie_lift",       title: "Pixie Lift",        subtitle: nil,                 prompt: "Respectfully lift and refine the nose tip for a pixie-esque profile",             isFree: false),
        EnhancementOption(id: "snatched_bridge",  title: "Snatched Bridge",   subtitle: "Limited-time free", prompt: "Respectfully slim and sharpen the nose bridge for a snatched look",               isFree: true),
        EnhancementOption(id: "doll_nose",        title: "Doll Nose",         subtitle: nil,                 prompt: "Respectfully sculpt a petite, doll-like nose shape",                               isFree: false),
        EnhancementOption(id: "airbrush_narrow",  title: "Airbrush Narrow",   subtitle: nil,                 prompt: "Airbrush-style narrowing for a photo-ready nose",                                  isFree: true),
        EnhancementOption(id: "slope_sculpt",     title: "Slope Sculpt",      subtitle: nil,                 prompt: "Respectfully sculpt a gentle ski-slope nose profile",                              isFree: false),
        EnhancementOption(id: "natural_polish",   title: "Natural Polish",    subtitle: "Limited-time free", prompt: "Add subtle refinement for a naturally polished nose",                               isFree: true),
        EnhancementOption(id: "cupids_dip",       title: "Cupidâ€™s Dip",       subtitle: nil,                 prompt: "Create a delicate dip just beneath the tip for a Cupid-inspired contour",          isFree: false),
        EnhancementOption(id: "halo_highlight",   title: "Halo Highlight",    subtitle: nil,                 prompt: "Respectfully add soft highlight to accentuate the nose bridge",                   isFree: true)
    ]


    // MARK: â€“ Eyes
    static let eyes: [EnhancementOption] = [
        // Existing
        EnhancementOption(id: "brighten",         title: "Brighten",          subtitle: nil,                 prompt: "Brighten eyes and reduce shadows",                                                  isFree: true),
        EnhancementOption(id: "enlarge",          title: "Enlarge",           subtitle: nil,                 prompt: "Subtly enlarge the eyes",                                                          isFree: false),
        EnhancementOption(id: "fox_lift",         title: "Fox Lift",          subtitle: nil,                 prompt: "Respectfully lift outer corners for a fox-eye trend",                               isFree: true),
        EnhancementOption(id: "doll_eyes",        title: "Doll Eyes",         subtitle: "Limited-time free", prompt: "Respectfully widen and round eyes for a doll-like effect",                           isFree: true),
        EnhancementOption(id: "winged_liner",     title: "Winged Liner",      subtitle: nil,                 prompt: "Apply a clean winged-liner illusion for sharp definition",                          isFree: false),

        // New additions
        EnhancementOption(id: "siren_lift",       title: "Siren Lift",        subtitle: nil,                 prompt: "Respectfully raise outer corners for a sultry siren-eye look",                     isFree: false),
        EnhancementOption(id: "soft_sparkle",     title: "Soft Sparkle",      subtitle: nil,                 prompt: "Gently add subtle shimmer for softly sparkling eyes",                               isFree: true),
        EnhancementOption(id: "mega_pop",         title: "Mega Pop",          subtitle: "Limited-time free", prompt: "Intensify iris clarity for ultra-pop TikTok eyes",                                   isFree: true),
        EnhancementOption(id: "pastel_twinkle",   title: "Pastel Twinkle",    subtitle: nil,                 prompt: "Tint eyes with a pastel twinkle for dreamy vibes",                                   isFree: false),
        EnhancementOption(id: "graphic_flick",    title: "Graphic Flick",     subtitle: nil,                 prompt: "Apply a bold graphic liner flick for statement eyes",                               isFree: false),
        EnhancementOption(id: "dreamy_haze",      title: "Dreamy Haze",       subtitle: nil,                 prompt: "Add a soft-focus haze for ethereal eyes",                                           isFree: true),
        EnhancementOption(id: "icicle_bright",    title: "Icicle Bright",     subtitle: "Limited-time free", prompt: "Cool-tone brighten for an icy, refreshed gaze",                                      isFree: true),
        EnhancementOption(id: "subtle_smoke",     title: "Subtle Smoke",      subtitle: nil,                 prompt: "Respectfully add a gentle smoky contour for depth",                                 isFree: false)
    ]

    // MARK: â€“ Skin
    static let skin: [EnhancementOption] = [
        // Existing
        EnhancementOption(id: "smooth",        title: "Smooth",        subtitle: nil,                 prompt: "Smooth skin texture and even tone",                             isFree: true),
        EnhancementOption(id: "glow",          title: "Glow",          subtitle: nil,                 prompt: "Add a healthy, radiant glow",                                   isFree: false),

        // New additions
        EnhancementOption(id: "airbrush",      title: "Airbrush",      subtitle: nil,                 prompt: "Apply studio-grade airbrush smoothing and even tones",           isFree: false),
        EnhancementOption(id: "glass_skin",    title: "Glass Skin",    subtitle: "Limited-time free", prompt: "Respectfully create a dewy glass-skin finish",                    isFree: true),
        EnhancementOption(id: "peachy_blush",  title: "Peachy Blush",  subtitle: nil,                 prompt: "Add a soft peachy flush for a healthy TikTok blush look",        isFree: true),
        EnhancementOption(id: "bronze_tan",    title: "Bronze Tan",    subtitle: nil,                 prompt: "Apply a subtle sun-kissed bronze tan",                           isFree: false),
        EnhancementOption(id: "freckle_kiss",  title: "Freckle Kiss",  subtitle: "Limited-time free", prompt: "Sprinkle natural-looking sun freckles for playful vibes",        isFree: true),
        EnhancementOption(id: "clarity_boost", title: "Clarity Boost", subtitle: nil,                 prompt: "Reduce blemishes and enhance skin clarity",                      isFree: false),
        EnhancementOption(id: "matte_filter",  title: "Matte Filter",  subtitle: nil,                 prompt: "Respectfully mattify skin to reduce shine",                      isFree: true),
        EnhancementOption(id: "pearl_highlight",title: "Pearl Highlight",subtitle: nil,               prompt: "Apply soft pearl highlights for luminous skin accents",          isFree: false)
    ]

    // MARK: â€“ Face
    static let face: [EnhancementOption] = [
        // Existing
        EnhancementOption(id: "contour",        title: "Contour",        subtitle: nil,                 prompt: "Add subtle contour to face",                                   isFree: true),
        EnhancementOption(id: "smooth",         title: "Smooth",         subtitle: nil,                 prompt: "Smooth overall facial features",                               isFree: false),

        // New additions
        EnhancementOption(id: "jawline_define", title: "Jawline Define", subtitle: nil,                 prompt: "Sharpen jawline for a defined look",                           isFree: false),
        EnhancementOption(id: "cheek_lift",     title: "Cheek Lift",     subtitle: nil,                 prompt: "Respectfully lift and sculpt cheekbones",                      isFree: true),
        EnhancementOption(id: "v_face",         title: "V-Face",         subtitle: "Limited-time free", prompt: "Respectfully sculpt a sleek V-shaped face",                    isFree: true),
        EnhancementOption(id: "baby_soft",      title: "Baby Soft",      subtitle: nil,                 prompt: "Subtly soften features for a baby-face effect",                isFree: true),
        EnhancementOption(id: "siren_sculpt",   title: "Siren Sculpt",   subtitle: nil,                 prompt: "Respectfully sculpt striking features for a siren look",       isFree: false),
        EnhancementOption(id: "golden_ratio",   title: "Golden Ratio",   subtitle: nil,                 prompt: "Refine facial proportions toward the golden ratio",            isFree: false),
        EnhancementOption(id: "soft_highlight", title: "Soft Highlight", subtitle: "Limited-time free", prompt: "Add gentle highlighted glow to lift features",                 isFree: true),
        EnhancementOption(id: "chin_tuck",      title: "Chin Tuck",      subtitle: nil,                 prompt: "Subtly tuck chin for a refined profile",                       isFree: false)
    ]

    // MARK: â€“ Lips
    static let lips: [EnhancementOption] = [
        // Existing
        EnhancementOption(id: "full",           title: "Full",            subtitle: nil,                 prompt: "Enhance lip fullness",                                                         isFree: true),
        EnhancementOption(id: "color",          title: "Color",           subtitle: nil,                 prompt: "Add natural lip color",                                                        isFree: false),

        // New additions
        EnhancementOption(id: "gloss_sheen",    title: "Gloss Sheen",      subtitle: "Limited-time free", prompt: "Add a high-shine gloss sheen for viral glow",                                    isFree: true),
        EnhancementOption(id: "soft_ombre",     title: "Soft OmbrÃ©",       subtitle: nil,                 prompt: "Apply a subtle ombrÃ© gradient for fuller-looking lips",                          isFree: false),
        EnhancementOption(id: "cupid_bow",      title: "Cupidâ€™s Bow",      subtitle: nil,                 prompt: "Enhance Cupidâ€™s bow definition for a crisp lip shape",                           isFree: false),
        EnhancementOption(id: "velvet_matte",   title: "Velvet Matte",     subtitle: nil,                 prompt: "Give lips a plush velvet-matte finish",                                         isFree: false),
        EnhancementOption(id: "plump_pout",     title: "Plump Pout",       subtitle: "Limited-time free", prompt: "Respectfully plump lips for a TikTok-ready pout",                                isFree: true),
        EnhancementOption(id: "blushed_tint",   title: "Blushed Tint",     subtitle: nil,                 prompt: "Add a soft blushed tint for a natural flush",                                   isFree: true),
        EnhancementOption(id: "frosted_shine",  title: "Frosted Shine",    subtitle: nil,                 prompt: "Apply shimmering frosted shine for nostalgic Y2K vibes",                        isFree: false)
    ]
    // MARK: â€“ Legs
    static let leg: [EnhancementOption] = [
        // Existing
        EnhancementOption(id: "slim",              title: "Slim",               subtitle: nil,                 prompt: "Slim and lengthen legs",                                                          isFree: true),
        EnhancementOption(id: "tone",              title: "Tone",               subtitle: nil,                 prompt: "Tone leg muscles for definition",                                                isFree: false),

        // New additions
        EnhancementOption(id: "barbie_length",     title: "Barbie Length",      subtitle: "Limited-time free", prompt: "Lengthen and refine legs for Barbiecore proportions",                              isFree: true),
        EnhancementOption(id: "model_stretch",     title: "Model Stretch",      subtitle: nil,                 prompt: "Respectfully elongate legs for a runway-model stretch",                          isFree: false),
        EnhancementOption(id: "athletic_sculpt",   title: "Athletic Sculpt",    subtitle: nil,                 prompt: "Enhance muscle definition for a sporty leg sculpt",                               isFree: false),
        EnhancementOption(id: "pilates_tone",      title: "Pilates Tone",       subtitle: nil,                 prompt: "Add gentle Pilates-inspired toning",                                             isFree: true),
        EnhancementOption(id: "sun_kissed_glow",   title: "Sun-Kissed Glow",    subtitle: nil,                 prompt: "Apply a subtle sun-bronzed glow to legs",                                        isFree: false),
        EnhancementOption(id: "glass_shine",       title: "Glass Shine",        subtitle: "Limited-time free", prompt: "Add glossy glass-skin shine for viral leg sheen",                                 isFree: true),
        EnhancementOption(id: "dreamy_slim",       title: "Dreamy Slim",        subtitle: nil,                 prompt: "Soft-focus slim effect for dreamy long legs",                                    isFree: false),
        EnhancementOption(id: "v_line_define",     title: "V-Line Define",      subtitle: nil,                 prompt: "Sculpt inner-thigh V-line for crisp definition",                                 isFree: false)
    ]

    
    static let jewellery: [EnhancementOption] = [
        EnhancementOption(
                id: "gold_hoop_minimal",
                title: "Minimal Gold Hoops",
                subtitle: nil,
                prompt: "Add sleek, minimalistic gold hoop earrings",
                isFree: true
            ),
            EnhancementOption(
                id: "delicate_gold_chain",
                title: "Delicate Gold Chain",
                subtitle: nil,
                prompt: "Add a thin, delicate gold chain necklace",
                isFree: true
            ),
            EnhancementOption(
                id: "stackable_bands",
                title: "Stackable Bands",
                subtitle: nil,
                prompt: "Add a set of minimal stackable gold rings",
                isFree: false
            ),
            EnhancementOption(
                id: "geometric_studs",
                title: "Geometric Studs",
                subtitle: nil,
                prompt: "Add small geometric stud earrings in gold",
                isFree: true
            ),
            EnhancementOption(
                id: "thin_gold_bangle",
                title: "Thin Gold Bangle",
                subtitle: nil,
                prompt: "Add a slender, minimalistic gold bangle bracelet",
                isFree: false
            ),
            EnhancementOption(
                id: "gold_bar_necklace",
                title: "Gold Bar Necklace",
                subtitle: "Limited-time free",
                prompt: "Add a minimalist gold bar pendant necklace",
                isFree: true
            ),
            EnhancementOption(
                id: "link_chain_bracelet",
                title: "Link Chain Bracelet",
                subtitle: nil,
                prompt: "Add a bold gold link chain bracelet",
                isFree: false
            ),
            EnhancementOption(
                id: "pearls_and_gold",
                title: "Pearls & Gold",
                subtitle: nil,
                prompt: "Add a blend of pearls with gold accents",
                isFree: true
            ),
            EnhancementOption(
                id: "gold_cuff_minimal",
                title: "Minimal Gold Cuff",
                subtitle: nil,
                prompt: "Add a clean, minimalistic gold cuff bracelet",
                isFree: false
            ),
            EnhancementOption(
                id: "layered_gold_chains",
                title: "Layered Gold Chains",
                subtitle: nil,
                prompt: "Add multiple thin gold chain necklaces for layering",
                isFree: false
            ),
        EnhancementOption(
            id: "earrings",
            title: "Earrings",
            subtitle: nil,
            prompt: "Add stylish earrings",
            isFree: true
        ),
        EnhancementOption(
            id: "necklace",
            title: "Necklace",
            subtitle: nil,
            prompt: "Add a beautiful necklace",
            isFree: false
        ),
        EnhancementOption(
            id: "bracelet",
            title: "Bracelet",
            subtitle: nil,
            prompt: "Add a delicate bracelet around the wrist",
            isFree: true
        ),
        EnhancementOption(
            id: "ring",
            title: "Ring",
            subtitle: nil,
            prompt: "Add a sparkling ring to the fingers",
            isFree: false
        ),
        EnhancementOption(
            id: "anklet",
            title: "Anklet",
            subtitle: "Limited-time free",
            prompt: "Add a subtle anklet for a refined touch",
            isFree: true
        ),
        EnhancementOption(
            id: "chandelier_earrings",
            title: "Chandelier Earrings",
            subtitle: nil,
            prompt: "Add elegant chandelier-style earrings",
            isFree: false
        ),
        EnhancementOption(
            id: "hoop_earrings",
            title: "Hoop Earrings",
            subtitle: nil,
            prompt: "Add classic hoop earrings",
            isFree: true
        ),
        EnhancementOption(
            id: "cuff_bracelet",
            title: "Cuff Bracelet",
            subtitle: nil,
            prompt: "Add a bold cuff bracelet to the wrist",
            isFree: false
        ),
        EnhancementOption(
            id: "choker",
            title: "Choker",
            subtitle: nil,
            prompt: "Add a sleek choker around the neck",
            isFree: true
        ),
        EnhancementOption(
            id: "pendant",
            title: "Pendant",
            subtitle: nil,
            prompt: "Add a charming pendant on a fine chain",
            isFree: false
        ),
        EnhancementOption(
            id: "brooch",
            title: "Brooch",
            subtitle: nil,
            prompt: "Add a decorative brooch for a vintage flair",
            isFree: true
        ),
        EnhancementOption(
            id: "watch",
            title: "Watch",
            subtitle: nil,
            prompt: "Add a stylish wristwatch",
            isFree: false
        )
    ]

    // New Eyewear options
    static let eyewear: [EnhancementOption] = [
        EnhancementOption(
            id: "eyewear",
            title: "Eyewear",
            subtitle: nil,
            prompt: "Add stylish eyewear frames",
            isFree: true
        ),
        EnhancementOption(
            id: "sunglasses",
            title: "Sunglasses",
            subtitle: nil,
            prompt: "Add trendy sunglasses with reflective lenses",
            isFree: false
        ),
        EnhancementOption(
            id: "reading_glasses",
            title: "Reading Glasses",
            subtitle: "Limited-time free",
            prompt: "Add elegant reading glasses with thin frames",
            isFree: true
        ),
        EnhancementOption(
            id: "aviators",
            title: "Aviator Frames",
            subtitle: nil,
            prompt: "Add classic aviator sunglasses with metal frames",
            isFree: false
        ),
        EnhancementOption(
            id: "wayfarer",
            title: "Wayfarer",
            subtitle: nil,
            prompt: "Add stylish wayfarer-style glasses",
            isFree: true
        ),
        EnhancementOption(
            id: "round_frames",
            title: "Round Frames",
            subtitle: nil,
            prompt: "Add vintage round frame glasses",
            isFree: false
        ),
        EnhancementOption(
            id: "cat_eye",
            title: "Cat-eye",
            subtitle: nil,
            prompt: "Add chic cat-eye glasses for a retro look",
            isFree: true
        ),
        EnhancementOption(
            id: "translucent_frames",
            title: "Translucent Frames",
            subtitle: nil,
            prompt: "Add translucent frame glasses with modern vibe",
            isFree: false
        ),
        EnhancementOption(
            id: "sports_goggles",
            title: "Sports Goggles",
            subtitle: nil,
            prompt: "Add sporty wrap-around goggles",
            isFree: false
        ),
        EnhancementOption(
            id: "steampunk_goggles",
            title: "Steampunk Goggles",
            subtitle: "Limited-time free",
            prompt: "Add decorative steampunk-style goggles",
            isFree: true
        )
    ]
}
//
//  ImagePicker.swift
//  HairStyle
//
//  Created by Adam Roszyk on 3/19/25.
//
import SwiftUI
import PhotosUI


// UIKit-based image picker integrated into SwiftUI using UIViewControllerRepresentable
struct ImagePicker: UIViewControllerRepresentable {
    class Coordinator: NSObject, UINavigationControllerDelegate, UIImagePickerControllerDelegate {
        let parent: ImagePicker

        init(_ parent: ImagePicker) {
            self.parent = parent
        }
        func imagePickerController(_ picker: UIImagePickerController,
                                   didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey : Any]) {
            if let uiImage = info[.originalImage] as? UIImage {
                parent.image = uiImage
            }
            picker.dismiss(animated: true)
        }
    }
    
    @Binding var image: UIImage?
    
    func makeCoordinator() -> Coordinator {
        Coordinator(self)
    }
    func makeUIViewController(context: Context) -> UIImagePickerController {
        let picker = UIImagePickerController()
        picker.delegate = context.coordinator
        return picker
    }
    func updateUIViewController(_ uiViewController: UIImagePickerController, context: Context) {}
}
import SwiftUI
import Vision
import CoreML
import CoreImage
import UIKit
import os

// MARK: - CIImage Extension
extension CIImage {
    /// Returns a resized CIImage.
    func resized(to size: CGSize) -> CIImage {
        let scaleX = size.width / extent.width
        let scaleY = size.height / extent.height
        var outputImage = transformed(by: CGAffineTransform(scaleX: scaleX, y: scaleY))
        // Reset the origin to (0,0)
        outputImage = outputImage.transformed(by: CGAffineTransform(translationX: -outputImage.extent.origin.x,
                                                                    y: -outputImage.extent.origin.y))
        return outputImage
    }
}
extension CIContext {
    /// Renders a CIImage to a new CVPixelBuffer using the specified pixel format.
    func render(_ image: CIImage, pixelFormat: OSType) -> CVPixelBuffer? {
        // Ensure valid dimensions by rounding up and enforcing a minimum value
        let width = max(Int(ceil(image.extent.width)), 1)
        let height = max(Int(ceil(image.extent.height)), 1)
        let attrs: [CFString: Any] = [
            kCVPixelBufferCGImageCompatibilityKey: true,
            kCVPixelBufferCGBitmapContextCompatibilityKey: true,
            kCVPixelBufferIOSurfacePropertiesKey: [:]
        ]
        var pixelBuffer: CVPixelBuffer?
        let status = CVPixelBufferCreate(
            kCFAllocatorDefault,
            width,
            height,
            pixelFormat,
            attrs as CFDictionary,
            &pixelBuffer
        )
        guard status == kCVReturnSuccess, let buffer = pixelBuffer else {
            print("CVPixelBufferCreate failed with status: \(status)")
            return nil
        }
        self.render(image, to: buffer)
        return buffer
    }
}


// Extension to enhance image contrast
extension UIImage {
    func applyingContrast(_ contrast: CGFloat) -> UIImage? {
        guard let cgImage = self.cgImage else { return nil }
        
        let context = CIContext()
        let ciImage = CIImage(cgImage: cgImage)
        
        let filter = CIFilter(name: "CIColorControls")
        filter?.setValue(ciImage, forKey: kCIInputImageKey)
        filter?.setValue(contrast, forKey: kCIInputContrastKey)
        filter?.setValue(0, forKey: kCIInputBrightnessKey)
        filter?.setValue(1.0, forKey: kCIInputSaturationKey)
        
        guard let outputImage = filter?.outputImage,
              let filteredCGImage = context.createCGImage(outputImage, from: outputImage.extent) else {
            return nil
        }
        
        return UIImage(cgImage: filteredCGImage, scale: self.scale, orientation: self.imageOrientation)
    }
}

extension UIImage {
    func resizedPixelBuffer(width: Int, height: Int) -> CVPixelBuffer? {
        var pxBuffer: CVPixelBuffer?
        let attrs = [
            kCVPixelBufferCGImageCompatibilityKey: true,
            kCVPixelBufferCGBitmapContextCompatibilityKey: true
        ] as CFDictionary
        
        guard CVPixelBufferCreate(kCFAllocatorDefault,
                                  width,
                                  height,
                                  kCVPixelFormatType_32ARGB,
                                  attrs,
                                  &pxBuffer) == kCVReturnSuccess,
              let buffer = pxBuffer,
              let cgImage = self.cgImage else {
            return nil
        }
        CVPixelBufferLockBaseAddress(buffer, [])
        defer { CVPixelBufferUnlockBaseAddress(buffer, []) }
        
        let context = CGContext(data: CVPixelBufferGetBaseAddress(buffer),
                                width: width,
                                height: height,
                                bitsPerComponent: 8,
                                bytesPerRow: CVPixelBufferGetBytesPerRow(buffer),
                                space: CGColorSpaceCreateDeviceRGB(),
                                bitmapInfo: CGImageAlphaInfo.noneSkipFirst.rawValue)
        guard let ctx = context else { return nil }
        
        let rect = CGRect(x: 0, y: 0, width: width, height: height)
        ctx.draw(cgImage, in: rect)
        
        return buffer
    }
}
import SwiftUI
@main
struct HairStyleApp: App {
    @AppStorage("hasSeenDemo")            private var hasSeenDemo            = false
    @AppStorage("hasCompletedOnboarding") private var hasCompletedOnboarding = false
    
    @StateObject private var subscriptionManager = SubscriptionManager()
    
    var body: some Scene {
        WindowGroup {
            if hasCompletedOnboarding {
                CatalogView()
                    .environmentObject(subscriptionManager)
            } else {
                OnboardingFlowView()          // â† new flow
                    .environmentObject(subscriptionManager)
            }
        }
    }
}
