2025-05-12 12:41:38
//
//  LoadingMessages.swift
//  HairStyle
//
//  Created by adam on 30/04/2025.
//


//  LoadingMessages.swift
//  PicUp
//  Generated 30‑04‑2025 – A sprinkle of Gen‑Z flavoured loading banter ✨
//
//  Call `LoadingMessages.random()` whenever you need a fresh status line.
//  Example:
//      Text(LoadingMessages.random())
//
//  The list can be expanded or localized later.

import Foundation

enum LoadingMessages {
    static let all: [String] = [
       /* "Casting ✨ filters… hold my boba!",
        "Crunching pixels like kettle chips…",
        "Tweaking the vibe parameters (scientifically, of course)…",
        "GPU is doing burpees—almost done!",
        "Uploading imagination to the cloud ☁️…",
        "Painting happy little bytes…",
        "Assembling AI drip, please stand by…",
        "Turning coffee into gradients…",
        "Charging the creativity capacitor ⚡️…",
        "Optimizing the funniness algorithm…",
        "Feeding hamsters more voltage…",
        "Rendering in ✨ Ultra‑Mega‑1080p ✨…",
        "Spinning up rainbow shaders…",
        "Injecting extra serotonin into pixels…",
        "Reticulating splines 2.0…",
        "Aligning photonic chakras…",
        "Manifesting your best self…",
        "Negotiating with the color wheel…",
        "Loading swag assets (almost there)…",
        "Finalizing epicness—do not unplug!",*/
        "Personalizing look… ✨",
        "Matching shades… 💄",
        "Crafting routine… 📝",
        "Virtual try‑on… 🤳",
        "Beauty tips… 💡",
        "Natural glow… 🌟",
        "Perfect combos… 🔄",
        "Loading palette… 🎨",
        "Next‑level glam… 🚀",
        "Highlighting you… ✨",
        "Color match… 🎯",
        "Beauty roadmap… 🗺️",
        "Refining look… 🔧",
        "Pro tutorials… 🎥",
        "Mood tune… 🎭",
        "Step‑by‑step… 📚",
        "Dream vibe… ✨",
        "Beauty upgrade… 🔒",
        "Unlock VIP… 🔓",
        "Premium awaits… 💎",
        "Subscribe now… 🏷️",
        "Pro tools… 🛠️",
        "Go PREMIUM! 🚨",
        "Glam boost… 🌈",
        "Beauty perks… ⚡️",
        "Luxe filters… 💼",
        "Almost ready… 🥂",
        "Get VIP access… 🌟"
    ]

    /// Returns a random playful loading string.
    static func random() -> String {
        all.randomElement() ?? "Generating… hang tight!"
    }
}
import SwiftUI

// MARK: – Photo / slider view
 struct PhotoWithRefreshOverlay: View {
    // Inputs
    let originalImage: UIImage?
    let editedImage: UIImage?
    let depthMapImage: UIImage?
    let isGenerating: Bool
    @Binding var sliderPosition: CGFloat
    @Binding var showSlider: Bool
    let onReplaceTap: () -> Void
    let onAddTap: () -> Void
    let onSaveTap: () -> Void

    // Zoom / pan state omitted for brevity – unchanged from earlier version

    var body: some View {
        ZStack {
            contentView
        }
    }

    @ViewBuilder private var contentView: some View {
        if let orig = originalImage, let edit = editedImage {
            Image(uiImage: edit).resizable().scaledToFit()
        } else if let edit = editedImage {
            Image(uiImage: edit).resizable().scaledToFit()
        } else {
            EmptyStateView(onAddTap: onAddTap, isGenerating: isGenerating)
        }
    }
}


struct EmptyStateView: View {
    let onAddTap: () -> Void
    let isGenerating: Bool

    @State private var shineAdd = false

    var body: some View {
        VStack {
            Spacer()
            if isGenerating {
                Text(LoadingMessages.random())
                    .font(.headline)
                    .multilineTextAlignment(.center)
                    .foregroundColor(.white)
                    .padding()
            } else {
                Button(action: {
                    shineAdd = false
                    onAddTap()
                }) {
                    VStack(spacing: 12) {
                        Image(systemName: "photo.fill.on.rectangle.fill")
                            .font(.system(size: 40))
                        Text("Add Image +")
                            .font(.headline)
                    }
                    .foregroundColor(.black)
                    .padding()
                    .background(Color.white)
                    .cornerRadius(12)
                    .shadow(radius: 10)
                    // shimmer overlay
                    .overlay(
                        Rectangle()
                            .fill(
                                LinearGradient(
                                    gradient: Gradient(colors: [Color.white.opacity(0.1), Color.white.opacity(0.4), Color.white.opacity(0.1)]),
                                    startPoint: .leading,
                                    endPoint: .trailing
                                )
                            )
                            .rotationEffect(.degrees(30))
                            .offset(x: shineAdd ? 200 : -200)
                            .mask(RoundedRectangle(cornerRadius: 12))
                    )
                }
                .onAppear {
                    withAnimation(Animation.linear(duration: 1.5).repeatForever(autoreverses: false)) {
                        shineAdd = true
                    }
                }
            }
            Spacer()
        }
    }
}

// MARK: – Stub generation worker
 enum ImageEditingWorker {
    static func generate(input: UIImage, prompt: String) async -> UIImage? {
        let vm = ImageEditingViewModel()
        do {
            try await vm.loadModel()
            vm.editedImage = input
            vm.prompt = prompt
            await MainActor.run { vm.editImage() }
            while await MainActor.run(body: { vm.isLoading }) {
                if #available(iOS 16.0, *) {
                    try? await Task.sleep(for: .milliseconds(100))
                } else {
                    // Fallback on earlier versions
                }
            }
            return await MainActor.run(body: { vm.editedImage })
        } catch {
            print("Generation failed: \(error)")
            return nil
        }
    }
}
import SwiftUI

/// The enhancement panel shows a scroll of options and a bottom bar.
/// It pre-selects the first option automatically.
import SwiftUI

struct BottomBar: View {
    let iconAssetName: String?
    let onCancel: () -> Void
    let onApply: () -> Void
    let canApply: Bool

    @State private var shineApply = false

    var body: some View {
        HStack {
            // Cancel
            Button(action: onCancel) {
                Label("Cancel", systemImage: "xmark")
                    .font(.headline)
                    .foregroundColor(.white)
                    .padding(.vertical, 14)
                    .padding(.horizontal, 20)
            }

            Spacer()

            // Icon
            if let asset = iconAssetName {
                Image(asset)
                    .resizable()
                    .aspectRatio(contentMode: .fit)
                    .frame(width: 44, height: 44)
            }

            Spacer()

            // Apply with shimmer when canApply
            Button(action: onApply) {
                Label("Apply", systemImage: "checkmark")
                    .font(.headline)
                    .foregroundColor(.white)
                    .padding(.vertical, 12)
                    .padding(.horizontal, 24)
                    .background(
                        // use the mask & moving gradient
                        RoundedRectangle(cornerRadius: 24)
                            .fill(Color.clear)
                            .overlay(
                                Group {
                                    if canApply {
                                        Rectangle()
                                            .fill(
                                                LinearGradient(
                                                    gradient: Gradient(colors: [
                                                        Color.black.opacity(0.1),
                                                        Color.black.opacity(0.3),
                                                        Color.black.opacity(0.1)
                                                    ]),
                                                    startPoint: .leading,
                                                    endPoint: .trailing
                                                )
                                            )
                                            .rotationEffect(.degrees(30))
                                            .offset(x: shineApply ? 200 : -200)
                                            .mask(RoundedRectangle(cornerRadius: 24))
                                            .animation(
                                                Animation
                                                    .linear(duration: 2.5)
                                                    .repeatForever(autoreverses: false),
                                                value: shineApply
                                            )
                                    }
                                }
                            )
                    )
            }
            .onAppear {
                // kick it off if we're already allowed
                if canApply {
                    shineApply = true
                }
            }
            .onChange(of: canApply) { newValue in
                // whenever we flip to true, reset & start the shimmer
                if newValue {
                    shineApply = false
                    shineApply = true
                } else {
                    shineApply = false
                }
            }
        }
        .padding(.horizontal, 7)
        .padding(.bottom, 20)
    }
}

// EnhancementPanelView itself
struct EnhancementPanelView: View {
    let section: String
    let options: [EnhancementOption]
    @Binding var selectedOption: EnhancementOption?
    let applyAction: () -> Void
    let cancelAction: () -> Void

    var body: some View {
        VStack(spacing: 12) {
            PillsScroll(options: options, selectedOption: $selectedOption)
            Divider().background(Color.white.opacity(0.5))
            BottomBar(
                iconAssetName: sectionIconName,
                onCancel: cancelAction,
                onApply: applyAction,
                canApply: selectedOption != nil
            )
        }
        .background(.ultraThinMaterial)
        .cornerRadius(16)
        .padding(.horizontal, 16)
        .padding(.bottom, 8)
        .padding(.top, 12)
        .onAppear {
            // Pre-select first option
            if selectedOption == nil, let first = options.first {
                selectedOption = first
            }
        }
    }

    private var sectionIconName: String {
        section.replacingOccurrences(of: " ", with: "")
    }
}




// MARK: — Pills Scroll
private struct PillsScroll: View {
    let options: [EnhancementOption]
    @Binding var selectedOption: EnhancementOption?

    var body: some View {
        ScrollView(.horizontal, showsIndicators: false) {
            HStack(spacing: 16) {
                ForEach(options) { opt in
                    OptionPill(
                        option: opt,
                        isSelected: opt.id == selectedOption?.id
                    )
                    .onTapGesture { selectedOption = opt }
                }
            }
            .padding(.horizontal, 16)
            .padding(.bottom, 8)
            .padding(.top, 12)
        }
    }
}

// MARK: — Single Pill
private struct OptionPill: View {
    let option: EnhancementOption
    let isSelected: Bool

    private var iconName: String {
        switch option.id {
        case "round":        return "circle"
        case "heart_shaped": return "heart.fill"
        case "superlift":    return "flame.fill"
        default:             return "sparkles"
        }
    }

    private var titleColor: AnyShapeStyle {
        if isSelected {
            AnyShapeStyle(
                LinearGradient(
                    colors: [Color.pink, Color.orange],
                    startPoint: .leading,
                    endPoint: .trailing
                )
            )
        } else {
            AnyShapeStyle(Color.white.opacity(0.9))
        }
    }

    var body: some View {
        HStack(spacing: 12) {
            Image(systemName: iconName)
                .font(.subheadline)
                .foregroundColor(isSelected ? .white : .white.opacity(0.7))
            Text(option.title)
                .font(.subheadline)
                .fontWeight(.medium)
                .foregroundStyle(titleColor)
        }
        .padding(.vertical, 12)
        .padding(.horizontal, 20)
        .background(isSelected ? Color.black.opacity(0.85) : Color.black.opacity(0.6))
        .cornerRadius(24)
        .overlay(
            Group {
                if isSelected {
                    Image(systemName: "checkmark.circle.fill")
                        .font(.title3)
                        .foregroundColor(.white)
                        .offset(x: 8, y: -8)
                }
            }, alignment: .topTrailing
        )
    }
}
//
//  OnboardingFlowView.swift
//  HairStyle
//
//  Pink-gradient, pill-style onboarding that matches the mock-ups.
//  Pages:
//    1. Budget picker
//    2. Skill-level picker
//    3. Social-proof / rate-us
//    4. Notification permission
//    5. Paywall (your existing WeeklyPaywallView)
//
//  Drop this file in; no other changes needed.
//

import SwiftUI
import StoreKit                     // rating
import UserNotifications            // notification prompt

// MARK: – Entry point
struct OnboardingFlowView: View {
    @AppStorage("hasCompletedOnboarding") private var hasCompletedOnboarding = false
    @AppStorage("isPremium")              private var isPremium              = false
    
    @EnvironmentObject private var subscriptionManager: SubscriptionManager
    @State private var page = 0
    
    var body: some View {
        TabView(selection: $page) {
            
            BudgetPage     { page += 1 }.tag(0)
            SkillPage      { page += 1 }.tag(1)
            ReviewPage     { page += 1 }.tag(2)
            NotifyPage     { page += 1 }.tag(3)
            
            WeeklyPaywallView(                      // existing paywall
                thumbs:        subscriptionManager.previewThumbs,
                onUnlock:      { isPremium = true;  hasCompletedOnboarding = true },
                onClose:       { /* not shown in onboarding */ }
            )
            .environmentObject(subscriptionManager)
            .tag(4)
        }
        .tabViewStyle(.page(indexDisplayMode: .never))
        .ignoresSafeArea()
    }
}

// MARK: – Common styling helpers
private struct GradientBackground<Content: View>: View {
    let content: () -> Content
    var body: some View {
        LinearGradient(
            gradient: Gradient(colors: [
                Color(red: 1, green: 0.95, blue: 0.96),
                Color(red: 1, green: 0.87, blue: 0.90)
            ]),
            startPoint: .top, endPoint: .bottom)
        .ignoresSafeArea()
        .overlay(content())
    }
}

private struct Pill: View {
    let title: String
    var body: some View {
        Text(title)
            .font(.headline.weight(.semibold))
            .padding(.vertical, 12)
            .padding(.horizontal, 30)
            .background(Color.white)
            .cornerRadius(26)
            .shadow(color: Color.black.opacity(0.06), radius: 4, x: 0, y: 2)
    }
}

// MARK: – ❶ Budget
private struct BudgetPage: View {
    let onContinue: () -> Void
    @State private var selection: String?
    
    private let options: [(emoji: String, text: String)] = [
        ("✨", "Light"),
        ("💄", "Affordable"),
        ("💰", "High-end"),
        ("🛍️", "Elite")
    ]
    
    var body: some View {
        GradientBackground {
            VStack(spacing: 40) {
                
                Spacer().frame(height: 60)
                
                Text("What's your\nbudget?")
                    .font(.largeTitle.bold())
                    .multilineTextAlignment(.center)
                
                VStack(spacing: 20) {
                    ForEach(options, id: \.text) { item in
                        Button {
                            selection = item.text
                        } label: {
                            Pill(title: "\(item.emoji) \(item.text)")
                                .overlay(
                                    RoundedRectangle(cornerRadius: 26)
                                        .stroke(Color.black.opacity(
                                            selection == item.text ? 0.4 : 0
                                        ), lineWidth: 2)
                                )
                        }
                    }
                }
                
                Spacer()
                
                Button(action: onContinue) {
                    Text("Continue")
                        .font(.headline)
                        .frame(maxWidth: .infinity)
                        .padding(.vertical, 18)
                        .background(Color.white)
                        .cornerRadius(32)
                }
                .padding(.horizontal, 40)
                .opacity(selection == nil ? 0.4 : 1)
                .disabled(selection == nil)
                
                Spacer().frame(height: 30)
            }
            .padding(.horizontal)
        }
    }
}

// MARK: – ❷ Skill level
private struct SkillPage: View {
    let onContinue: () -> Void
    @State private var selection: String?
    
    private let options: [(emoji: String, text: String)] = [
        ("🍃", "Beginner"),
        ("✨", "Intermediate"),
        ("💄", "Expert"),
        ("🎨", "Pro")
    ]
    
    var body: some View {
        GradientBackground {
            VStack(spacing: 40) {
                
                Spacer().frame(height: 60)
                
                Text("How would you rate\nyour makeup skills?")
                    .font(.largeTitle.bold())
                    .multilineTextAlignment(.center)
                
                VStack(spacing: 20) {
                    ForEach(options, id: \.text) { item in
                        Button {
                            selection = item.text
                        } label: {
                            Pill(title: "\(item.emoji) \(item.text)")
                                .overlay(
                                    RoundedRectangle(cornerRadius: 26)
                                        .stroke(Color.black.opacity(
                                            selection == item.text ? 0.4 : 0
                                        ), lineWidth: 2)
                                )
                        }
                    }
                }
                
                Spacer()
                
                Button(action: onContinue) {
                    Text("Continue")
                        .font(.headline)
                        .frame(maxWidth: .infinity)
                        .padding(.vertical, 18)
                        .background(Color.white)
                        .cornerRadius(32)
                }
                .padding(.horizontal, 40)
                .opacity(selection == nil ? 0.4 : 1)
                .disabled(selection == nil)
                
                Spacer().frame(height: 30)
            }
            .padding(.horizontal)
        }
    }
}

// MARK: – ❸ Review / social proof
private struct ReviewPage: View {
    let onContinue: () -> Void
    
    var body: some View {
        GradientBackground {
            VStack(spacing: 32) {
                
                Spacer().frame(height: 60)
                
                Text("Trusted by Over\n1+ Million People!")
                    .font(.largeTitle.bold())
                    .multilineTextAlignment(.center)
                
                Image("kiss_placeholder")            // replace w/ asset
                    .resizable()
                    .scaledToFit()
                    .frame(width: 200)
                    .padding(.vertical, 10)
                
                HStack(spacing: 4) {
                    ForEach(0..<5) { _ in Image(systemName: "star.fill") }
                }
                .foregroundColor(.yellow)
                .font(.largeTitle)
                
                Spacer()
                
                Button {
                    rateNow()
                    onContinue()
                } label: {
                    Text("Leave a Review! 🥰")
                        .font(.headline)
                        .frame(maxWidth: .infinity)
                        .padding(.vertical, 18)
                        .background(Color.white)
                        .cornerRadius(32)
                }
                .padding(.horizontal, 40)
                
                Spacer().frame(height: 30)
            }
            .padding(.horizontal)
        }
    }
    
    private func rateNow() {
        if let scene = UIApplication.shared.connectedScenes.first as? UIWindowScene {
            SKStoreReviewController.requestReview(in: scene)
        }
    }
}

// MARK: – ❹ Notification permission
private struct NotifyPage: View {
    let onContinue: () -> Void
    @State private var isRequesting = false
    
    var body: some View {
        GradientBackground {
            VStack(spacing: 32) {
                
                Spacer().frame(height: 60)
                
                Text("Allow Notifications")
                    .font(.largeTitle.bold())
                    .multilineTextAlignment(.center)
                
                // illustrative mock (replace with real asset if desired)
                Image(systemName: "app.badge.fill")
                    .resizable()
                    .scaledToFit()
                    .frame(width: 180)
                    .foregroundColor(.pink)
                    .padding(.vertical)
                
                Spacer()
                
                Button {
                    requestPermission()
                } label: {
                    Text("Enable notifications! 🥰")
                        .font(.headline)
                        .frame(maxWidth: .infinity)
                        .padding(.vertical, 18)
                        .background(Color.white)
                        .cornerRadius(32)
                }
                .padding(.horizontal, 40)
                .opacity(isRequesting ? 0.5 : 1)
                .disabled(isRequesting)
                
                Spacer().frame(height: 30)
            }
            .padding(.horizontal)
        }
    }
    
    private func requestPermission() {
        isRequesting = true
        UNUserNotificationCenter.current()
            .requestAuthorization(options: [.alert, .sound, .badge]) { _, _ in
                DispatchQueue.main.async {
                    isRequesting = false
                    onContinue()
                }
            }
    }
}
//
//  PhotoContainerView.swift
//  HairStyle
//
//  Created by adam on 25/04/2025.
//

import SwiftUI

// MARK: – Photo container
 struct PhotoContainerView: View {
    @Binding var inputImage: UIImage?
    let isGenerating: Bool
    let editedImage: UIImage?
    let depthMapImage: UIImage?
    @Binding var sliderPosition: CGFloat
    @Binding var showSlider: Bool
    let onAddTap: () -> Void
    let onReplaceTap: () -> Void
    let onSaveTap: () -> Void

    var body: some View {
        ZStack {
            backgroundView.ignoresSafeArea()
            PhotoWithRefreshOverlay(
                originalImage: inputImage,
                editedImage: editedImage,
                depthMapImage: depthMapImage,
                isGenerating: isGenerating,
                sliderPosition: $sliderPosition,
                showSlider: $showSlider,
                onReplaceTap: onReplaceTap,
                onAddTap: onAddTap,
                onSaveTap: onSaveTap
            )
        }
    }

    @ViewBuilder private var backgroundView: some View {
        if let img = inputImage {
            Image(uiImage: img).resizable().scaledToFill().blur(radius: 120).overlay(Color.black.opacity(0.4))
        } else {
            Color.black.opacity(0.6)
        }
    }
}
import SwiftUI
import UIKit
import StoreKit

// MARK: – Thumbnail item model -------------------------------------------------
struct ThumbItem: Identifiable {
    /// id == -1 → original; 0…3 → generated slots
    let id: Int
    var image: UIImage? = nil
    var isLoading: Bool = false
    var isOriginal: Bool { id == -1 }
}

// MARK: – GenView --------------------------------------------------------------
struct GenView: View {
    // MARK: Inputs
    let section: String

    // MARK: View-model
    @StateObject private var viewModel = ImageEditingViewModel()

    // MARK: UI state
    @State private var selectedOption: EnhancementOption?
    @State private var inputImage: UIImage?
    @State private var showingImagePicker = false
    @State private var sliderPosition: CGFloat = 0.5
    @State private var showSlider = false
    @State private var showSaveSuccessAlert = false

    // thumbnails: original + generated
    @State private var thumbs: [ThumbItem] = []
    @State private var currentIdx: Int? = nil

    // paywall modal flag
    @State private var showPaywallModal = false

    // MARK: Environment
    @Environment(\.dismiss) private var dismiss
    @EnvironmentObject private var subscriptionManager: SubscriptionManager

    // Derived
    private var isGenerating: Bool { thumbs.contains { !$0.isOriginal && $0.isLoading } }
    private var hasThumbs: Bool { !thumbs.isEmpty }
    private var shouldShowPaywall: Bool {
        !subscriptionManager.purchasedIdentifiers.contains("weeksub")
        && thumbs.count >= 5
        && thumbs.dropFirst().allSatisfy { !$0.isLoading }
    }

    // MARK: Body ----------------------------------------------------------------
    var body: some View {
        ZStack {
            GeometryReader { geo in
                PhotoContainerView(
                    inputImage: $inputImage,
                    isGenerating: isGenerating,
                    editedImage: mainDisplayedImage,
                    depthMapImage: viewModel.depthMapImage,
                    sliderPosition: $sliderPosition,
                    showSlider: $showSlider,
                    onAddTap: handleReplacePhoto,
                    onReplaceTap: handleReplacePhoto,
                    onSaveTap: saveImage
                )
                .frame(width: geo.size.width, height: geo.size.height)
                .ignoresSafeArea()

                if inputImage != nil {
                    TopButtons(
                        onBack: { dismiss() },
                        onReplace: handleReplacePhoto,
                        onShare: shareImage,
                        onSave: saveImage,
                        topInset: -20
                    )
                    .padding(.horizontal, 16)
                }

                VStack {
                    Spacer()
                    if hasThumbs {
                        ThumbnailsStrip(
                            thumbs: thumbs,
                            onSelect: { currentIdx = $0 },
                            onRetry: beginParallelGeneration
                        )
                    } else {
                        EnhancementPanelView(
                            section: section,
                            options: enhancementOptions,
                            selectedOption: $selectedOption,
                            applyAction: beginParallelGeneration,
                            cancelAction: { dismiss() }
                        )
                    }
                }
                .frame(width: geo.size.width)
            }
        }
        .navigationBarBackButtonHidden(true)
        .overlay {
            if isGenerating {
                Color.black.opacity(0.35).ignoresSafeArea()
                ProgressView()
                    .progressViewStyle(CircularProgressViewStyle(tint: .white))
                    .scaleEffect(2)
            }
        }
        .sheet(isPresented: $showingImagePicker, onDismiss: loadImage) {
            ImagePicker(image: $inputImage)
        }
        .alert("Saved", isPresented: $showSaveSuccessAlert) {
            Button("OK", role: .cancel) {}
        } message: { Text("Image saved to Photos") }
        .onChange(of: shouldShowPaywall) { if $0 { showPaywallModal = true } }
        .fullScreenCover(isPresented: $showPaywallModal) {
            WeeklyPaywallView(
                thumbs: thumbs,
                onUnlock: { showPaywallModal = false },
                onClose: {
                    showPaywallModal = false
                    dismiss()
                }
            )
            .environmentObject(subscriptionManager)
        }
    }

    // MARK: Helpers ------------------------------------------------------------
    private var mainDisplayedImage: UIImage? {
        guard let idx = currentIdx, thumbs.indices.contains(idx) else {
            return viewModel.editedImage
        }
        return idx == 0 ? inputImage : thumbs[idx].image
    }

    // MARK: Generation ----------------------------------------------------------
    private func beginParallelGeneration() {
        guard let base = inputImage, let prompt = selectedOption?.prompt else { return }
        thumbs = [ThumbItem(id: -1, image: base, isLoading: false)] +
                 (0..<4).map { ThumbItem(id: $0, isLoading: true) }
        currentIdx = 1
        Task.detached(priority: .userInitiated) {
            await withTaskGroup(of: (Int, UIImage?).self) { group in
                for idx in 0..<4 {
                    group.addTask { (idx, await ImageEditingWorker.generate(input: base, prompt: prompt)) }
                }
                for await (idx, img) in group {
                    await MainActor.run {
                        thumbs[idx + 1].image = img
                        thumbs[idx + 1].isLoading = false
                    }
                }
            }
        }
    }

    // MARK: UI actions ---------------------------------------------------------
    private func handleReplacePhoto() { showingImagePicker = true }
    private func loadImage() {
        guard let img = inputImage else { return }
        viewModel.editedImage = img
        thumbs.removeAll()
        currentIdx = nil
    }
    private func saveImage() {
        guard let img = mainDisplayedImage else { return }
        UIImageWriteToSavedPhotosAlbum(img, nil, nil, nil)
        showSaveSuccessAlert = true
    }
    private func shareImage() {
        guard let img = mainDisplayedImage else { return }
        let av = UIActivityViewController(activityItems: [img], applicationActivities: nil)
        UIApplication.shared.windows.first?.rootViewController?.present(av, animated: true)
    }

    // MARK: Enhancement options -----------------------------------------------
    private var enhancementOptions: [EnhancementOption] {
        switch section {
        case "Chest":    return BodyEnhancementPrompts.breast
        case "Belly":    return BodyEnhancementPrompts.belly
        case "Buttock":  return BodyEnhancementPrompts.buttock
        case "Muscle":   return BodyEnhancementPrompts.muscle
        case "Hair":     return BodyEnhancementPrompts.hair
        case "Nose":     return BodyEnhancementPrompts.nose
        case "Eyes":     return BodyEnhancementPrompts.eyes
        case "Skin":     return BodyEnhancementPrompts.skin
        case "Face":     return BodyEnhancementPrompts.face
        case "Lips":     return BodyEnhancementPrompts.lips
        case "Waist":    return BodyEnhancementPrompts.waist
        case "Legs":     return BodyEnhancementPrompts.leg
        case "jewellery":return BodyEnhancementPrompts.jewellery
        case "Eyewear":  return BodyEnhancementPrompts.eyewear
        default:          return []
        }
    }
}

 struct ThumbnailsStrip: View {
    let thumbs: [ThumbItem]
    let onSelect: (Int) -> Void
    let onRetry: () -> Void
    var isGenerating: Bool { thumbs.contains { !$0.isOriginal && $0.isLoading } }

    var body: some View {
        ScrollView(.horizontal, showsIndicators: false) {
            HStack(spacing: 16) {
                ForEach(thumbs) { thumb in
                    ZStack {
                        // image or placeholder
                        Group {
                            if let ui = thumb.image {
                                Image(uiImage: ui)
                                    .resizable()
                                    .aspectRatio(contentMode: .fill)
                            } else {
                                Color.gray.opacity(0.3)
                            }
                        }
                        .frame(width: 70, height: 70)
                        .clipped()
                        .cornerRadius(12)

                        // centered spinner
                        if thumb.isLoading {
                            ProgressView()
                                .progressViewStyle(CircularProgressViewStyle(tint: .white))
                        }

                        // bottom “ORIGINAL” badge
                        if thumb.isOriginal {
                            VStack {
                                Spacer()
                                Text("ORIGINAL")
                                    .font(.caption2.weight(.bold))
                                    .foregroundColor(.white)
                                    .padding(.vertical, 2)
                                    .frame(maxWidth: .infinity)
                                    .background(Color.black.opacity(0.6))
                            }
                        }
                    }
                    .frame(width: 70, height: 70)
                    .onTapGesture { onSelect(thumb.id == -1 ? 0 : thumb.id + 1) }
                }

                // retry button…
                Button(action: onRetry) {
                    ZStack {
                        Color.black.opacity(0.6)
                        Image(systemName: "arrow.clockwise")
                            .font(.title3.weight(.semibold))
                            .foregroundColor(.white)
                    }
                    .frame(width: 70, height: 70)
                    .cornerRadius(12)
                    .overlay(isGenerating ? Color.black.opacity(0.4).cornerRadius(12) : nil)
                }
                .disabled(isGenerating)
            }
            .padding(.horizontal, 16)
            .padding(.vertical, 8)
        }
        .background(.ultraThinMaterial)
        .cornerRadius(16)
    }
}


private struct TopButtons: View {
    let onBack, onReplace, onShare, onSave: () -> Void
    let topInset: CGFloat
    var body: some View {
        HStack(spacing: 12) {
            Button(action: onBack)    { Image(systemName: "chevron.left").modifier(circleIcon) }
            Button(action: onReplace) { Image(systemName: "arrow.triangle.2.circlepath").modifier(circleIcon) }
            Spacer()
            HStack(spacing: 12) {
                Button(action: onShare) { Image(systemName: "paperplane.fill").modifier(circleIcon) }
                Button(action: onSave)  { Image(systemName: "square.and.arrow.down").modifier(circleIcon) }
            }
        }
        .padding(.top, topInset + 20)
    }
    private var circleIcon: some ViewModifier { CircleIcon() }
}
private struct CircleIcon: ViewModifier {
    func body(content: Content) -> some View {
        content
            .font(.system(size: 20, weight: .medium))
            .foregroundColor(.white)
            .frame(width: 36, height: 36)
            .background(Color.black.opacity(0.6))
            .clipShape(Circle())
    }
}
import SwiftUI

struct CatalogView: View {
    // MARK: — Data
    private let bodyShapeItems: [(title: String, icon: String)] = [
        ("Chest Curve",   "Chest"),
        ("Flat Abs",      "Belly"),
        ("Buttocks+",     "Buttock"),
        ("Slim Waist",    "Waist"),
        ("Legs",          "Legs"),
        ("Muscles",       "Muscle")
    ]

    private let facialItems: [(title: String, icon: String)] = [
        ("Face",          "Face"),
        ("Eyes",          "Eyes"),
        ("Nose",          "Nose"),
        ("Lips",          "Lips"),
        ("Skin",          "Skin")
    ]

    private let hairAccessoryItems: [(title: String, icon: String)] = [
        ("Hair",          "Hair"),
        ("Jewellery",     "jewellery"),
        ("Eyewear",       "Eyewear")
    ]

    // Three flexible columns
    private let columns = Array(
        repeating: GridItem(.flexible(), spacing: 16),
        count: 3
    )

    var body: some View {
        NavigationView {
            ScrollView {
                VStack(alignment: .leading, spacing: 32) {

                    // MARK: — Header
                    HStack {
                        Text("BodyEditor Ai")
                            .font(.largeTitle).fontWeight(.bold)
                            .foregroundStyle(
                                LinearGradient(
                                    gradient: Gradient(colors: [Color.pink, Color.orange]),
                                    startPoint: .center,
                                    endPoint: .trailing
                                )
                            )
                        Spacer()
                    }
                    .padding(.horizontal)

                    // MARK: — Body Shape Section
                    SectionGrid(
                        title: "Body Shape",
                        items: bodyShapeItems,
                        columns: columns
                    )

                    // MARK: — Facial Section
                    SectionGrid(
                        title: "Facial",
                        items: facialItems,
                        columns: columns
                    )

                    // MARK: — Hair & Accessories Section
                    SectionGrid(
                        title: "Hair & Accessories",
                        items: hairAccessoryItems,
                        columns: columns
                    )
                }
                .padding(.vertical)
            }
            .background(Color(red: 0.14, green: 0.13, blue: 0.13).edgesIgnoringSafeArea(.all))
            .navigationBarHidden(true)
        }
    }
}

private struct SectionGrid: View {
    let title: String
    let items: [(title: String, icon: String)]
    let columns: [GridItem]

    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text(title)
                .font(.headline)
                .foregroundColor(.white)
                .padding(.horizontal)

            LazyVGrid(columns: columns, alignment: .leading, spacing: 16) {
                ForEach(items, id: \.title) { item in
                    NavigationLink(
                        destination: GenView(section: item.icon)
                    ) {
                        VStack(spacing: 8) {
                            // Circular icon background
                            ZStack {
                                RoundedRectangle(cornerRadius: 18)
                                    .fill(Color.black.opacity(0.6))
                                    .frame(width: 70, height: 70)
                                    .shadow(color: Color.white.opacity(0.2),
                                            radius: 6,
                                            x: 0,
                                            y: 0)

                                Image(item.icon)
                                    .resizable()
                                    .aspectRatio(contentMode: .fit)
                                    .frame(width: 50, height: 50)
                            }
                            
                            Text(item.title)
                                .font(.caption)
                                .multilineTextAlignment(.center)
                                .foregroundColor(.white)
                        }
                        .frame(maxWidth: .infinity)
                    }
                }
            }
            .padding(.horizontal)
        }
    }
}

struct CatalogView_Previews: PreviewProvider {
    static var previews: some View {
        CatalogView()
            .preferredColorScheme(.dark)
    }
}
import SwiftUI
import StoreKit

struct WeeklyPaywallView: View {
    @EnvironmentObject var subscriptionManager: SubscriptionManager
    let thumbs: [ThumbItem]
    let onUnlock: () -> Void
    let onClose: () -> Void

    @State private var closeDisabled = true
    @State private var currentPage = 0
    // 👇 new state for the bounce
    @State private var bounceOffset: CGFloat = 0
    @State private var hasBounced   = false     // ensures it fires only once
    // 🔸 NEW: scale for the Unlock button pulse
    @State private var buttonScale: CGFloat = 1.0

    private var weeklyProduct: Product? {
        subscriptionManager.subscriptions.first { $0.id == "weeksub" }
    }
    private var imageSize: CGFloat { UIScreen.main.bounds.width * 0.7 }

    var body: some View {
        ZStack(alignment: .topLeading) {
            // MARK: — Background Gradient
            LinearGradient(
                gradient: Gradient(colors: [
                    Color(red:1, green:0.95, blue:0.96),
                    Color(red:1, green:0.87, blue:0.90)
                ]),
                startPoint: .top,
                endPoint: .bottom
            )
            .ignoresSafeArea()

            // MARK: — Close Button
            Button(action: onClose) {
                Image(systemName: "xmark")
                    .font(.system(size: 15, weight: .medium))
                    .foregroundColor(.black)
                    .opacity(closeDisabled ? 0.3 : 0.6)
                    .padding(24)
            }
            .disabled(closeDisabled)
            .contentShape(Rectangle())
            .zIndex(1)

            VStack(spacing: 24) {
                Spacer().frame(height: 60)

                // MARK: — Headline (no truncation)
                Text("GET YOUR DREAM APPEARANCE!")
                    .font(.largeTitle).bold()
                    .foregroundColor(.black)
                    .multilineTextAlignment(.center)
                    .fixedSize(horizontal: false, vertical: true)

                Text("Proven to help you transform your beauty routine.")
                    .font(.subheadline)
                    .foregroundColor(.gray)
                    .multilineTextAlignment(.center)
                    .fixedSize(horizontal: false, vertical: true)
                    .padding(.horizontal, 32)

                // MARK: — Carousel & Dots
                Text("Reveal what you'll look like 👀")
                    .font(.headline)
                    .foregroundColor(.black)

                TabView(selection: $currentPage) {
                    ForEach(thumbs.indices, id: \.self) { idx in
                        if let ui = thumbs[idx].image {
                            Image(uiImage: ui)
                                .resizable()
                                .scaledToFill()
                                .frame(width: imageSize, height: imageSize)
                                .blur(radius: 6)
                                .mask(RoundedRectangle(cornerRadius: 16))
                                .overlay(
                                    RoundedRectangle(cornerRadius: 16)
                                        .stroke(Color.white.opacity(0.6), lineWidth: 4)
                                )
                                .tag(idx)
                                .offset(x: idx == 0 ? bounceOffset : 0)
                        }
                    }
                }
                .tabViewStyle(PageTabViewStyle(indexDisplayMode: .never))
                .frame(height: imageSize)

                HStack(spacing: 8) {
                    ForEach(0..<thumbs.count, id: \.self) { dot in
                        Circle()
                            .frame(width: 8, height: 8)
                            .foregroundColor(dot == currentPage ? .black : .gray)
                    }
                }

                Text("1,000,000+ beauty upgrades created")
                    .font(.caption)
                    .foregroundColor(.gray)

                // MARK: — Unlock Button (white pill)
                Button(action: purchaseWeekly) {
                    Text("Unlock Now")
                        .font(.title3).bold()
                        .foregroundColor(.black)
                        .frame(maxWidth: .infinity)
                        .padding(.vertical, 16)
                        .background(Color.white)
                        .cornerRadius(30)
                        .shadow(color: Color.black.opacity(0.1), radius: 4, x: 0, y: 2)
                }
                .padding(.horizontal, 32)
                .disabled(weeklyProduct == nil)
                .scaleEffect(buttonScale)
                
                // MARK: — Renewal Info
                (Text("Renews Weekly at ")
                 + Text(weeklyProduct?.displayPrice ?? "–")
                        .bold()
                        .foregroundColor(.black)      // price only → black
                )
                .font(.callout)
                .foregroundColor(.gray)

                Spacer()

                // MARK: — Footer Links
                HStack {
                    Button("Terms of Use")     { openURL("https://active-outcome.vercel.app/beautyCam") }
                    Spacer()
                    Button("Restore Purchase"){ Task { await restore() } }
                    Spacer()
                    Button("Privacy Policy")   { openURL("https://active-outcome.vercel.app/beautyCam") }
                }
                .font(.footnote)
                .foregroundColor(.gray)
                .padding(.horizontal, 32)

                Spacer().frame(height: 20)
            }
        }
        .onAppear {
            DispatchQueue.main.asyncAfter(deadline: .now() + 9) {
                withAnimation { closeDisabled = false }
            }
            
            // 👉 schedule a single left-nudge bounce after 0.8 s
            guard !hasBounced else { return }
            hasBounced = true
            DispatchQueue.main.asyncAfter(deadline: .now() + 3) {
                withAnimation(.easeInOut(duration: 0.28)) {
                    bounceOffset = -16          // nudge left ≈ thumb-width cue
                }
                // spring back
                DispatchQueue.main.asyncAfter(deadline: .now() + 0.28) {
                    withAnimation(.interpolatingSpring(stiffness: 220, damping: 18)) {
                        bounceOffset = 0
                    }
                }
            }
            
            
            // 🔸 schedule the Unlock-button pulse 5 s after appear
            DispatchQueue.main.asyncAfter(deadline: .now() + 7) {
                withAnimation(.easeInOut(duration: 0.4)) {
                    buttonScale = 1.1            // grow ~8 %
                }
                // snap back
                DispatchQueue.main.asyncAfter(deadline: .now() + 0.4) {
                    withAnimation(.easeInOut(duration: 0.4)) {
                        buttonScale = 1.0
                    }
                }
            }
        }
        
    }

    private func purchaseWeekly() {
        guard let p = weeklyProduct else { return }
        Task {
            if (try? await subscriptionManager.purchase(p)) != nil {
                onUnlock()
            }
        }
    }

    private func restore() async {
        for await verification in Transaction.currentEntitlements {
            if case .verified(let t) = verification, t.productID == "weeksub" {
                onUnlock()
                break
            }
        }
    }

    private func openURL(_ s: String) {
        if let url = URL(string: s) {
            UIApplication.shared.open(url)
        }
    }
}
import SwiftUI
import Photos
import StoreKit

struct OnboardingView: View {
    @AppStorage("hasCompletedOnboarding") var hasCompletedOnboarding: Bool = false
    @AppStorage("isPremium") var isPremium: Bool = false
    
    @State private var currentPage = 0
    private let totalPages = 6

    var body: some View {
        TabView(selection: $currentPage) {
            // Page 1: Benefit 1
            OnboardingPageView(imageName: "star.fill",
                               title: "Amazing Features",
                               description: "Discover advanced AI editing to bring out your best self.",
                               onContinue: { currentPage = 1 })
                .tag(0)
            
            // Page 2: Benefit 2
            OnboardingPageView(imageName: "sparkles",
                               title: "Effortless Beauty",
                               description: "Instantly enhance your selfies with just a tap.",
                               onContinue: { currentPage = 2 })
                .tag(1)
            
            // Page 3: Benefit 3
            OnboardingPageView(imageName: "heart.fill",
                               title: "Share Your Style",
                               description: "Create stunning images and share your unique look with friends.",
                               onContinue: { currentPage = 3 })
                .tag(2)
            
            // Page 4: Photo Library Permission
            PhotoLibraryPermissionPageView(onContinue: { currentPage = 4 })
                .tag(3)
            
            // Page 5: Review Prompt
            ReviewPromptPageView(onContinue: { currentPage = 5 })
                .tag(4)
            
            // Page 6: Paywall
            PaywallPageView(isPremium: $isPremium, onComplete: completeOnboarding)
                .tag(5)
        }
        .tabViewStyle(PageTabViewStyle(indexDisplayMode: .never))
    }
    
    private func completeOnboarding() {
        hasCompletedOnboarding = true
    }
}

struct OnboardingPageView: View {
    let imageName: String
    let title: String
    let description: String
    let onContinue: () -> Void
    
    var body: some View {
        VStack(spacing: 20) {
            Spacer()
            Image(systemName: imageName)
                .resizable()
                .scaledToFit()
                .frame(width: 120, height: 120)
                .foregroundColor(.blue)
            Text(title)
                .font(.largeTitle)
                .fontWeight(.bold)
            Text(description)
                .font(.title3)
                .multilineTextAlignment(.center)
                .padding(.horizontal)
            Spacer()
            Button(action: onContinue) {
                Text("Continue")
                    .foregroundColor(.white)
                    .padding()
                    .frame(maxWidth: .infinity)
                    .background(Color.blue)
                    .cornerRadius(8)
            }
            .padding(.horizontal)
        }
    }
}

struct PhotoLibraryPermissionPageView: View {
    @State private var permissionGranted = false
    let onContinue: () -> Void

    var body: some View {
        VStack(spacing: 20) {
            Spacer()
            Image(systemName: "photo.on.rectangle.angled")
                .resizable()
                .scaledToFit()
                .frame(width: 120, height: 120)
                .foregroundColor(permissionGranted ? .green : .orange)
            Text("Photo Library Access")
                .font(.largeTitle)
                .fontWeight(.bold)
            Text("We need permission to save your edited photos to your library.")
                .font(.title3)
                .multilineTextAlignment(.center)
                .padding(.horizontal)
            Button(action: {
                PHPhotoLibrary.requestAuthorization(for: .addOnly) { status in
                    DispatchQueue.main.async {
                        permissionGranted = (status == .authorized || status == .limited)
                    }
                }
            }) {
                Text(permissionGranted ? "Permission Granted" : "Grant Photo Library Access")
                    .foregroundColor(.white)
                    .padding()
                    .frame(maxWidth: .infinity)
                    .background(permissionGranted ? Color.green : Color.blue)
                    .cornerRadius(8)
            }
            .padding(.horizontal)
            Spacer()
            Button(action: onContinue) {
                Text("Continue")
                    .foregroundColor(.white)
                    .padding()
                    .frame(maxWidth: .infinity)
                    .background(Color.blue)
                    .cornerRadius(8)
            }
            .padding(.horizontal)
        }
    }
}

struct ReviewPromptPageView: View {
    let onContinue: () -> Void

    var body: some View {
        VStack(spacing: 20) {
            Spacer()
            Image(systemName: "hand.thumbsup.fill")
                .resizable()
                .scaledToFit()
                .frame(width: 120, height: 120)
                .foregroundColor(.purple)
            Text("Enjoying the App?")
                .font(.largeTitle)
                .fontWeight(.bold)
            Text("We’d love to hear your feedback. Please take a moment to rate us!")
                .font(.title3)
                .multilineTextAlignment(.center)
                .padding(.horizontal)
            Button(action: {
                if let scene = UIApplication.shared.connectedScenes.first as? UIWindowScene {
                    SKStoreReviewController.requestReview(in: scene)
                }
            }) {
                Text("Rate Now")
                    .foregroundColor(.white)
                    .padding()
                    .frame(maxWidth: .infinity)
                    .background(Color.purple)
                    .cornerRadius(8)
            }
            .padding(.horizontal)
            Spacer()
            Button(action: onContinue) {
                Text("Continue")
                    .foregroundColor(.white)
                    .padding()
                    .frame(maxWidth: .infinity)
                    .background(Color.purple)
                    .cornerRadius(8)
            }
            .padding(.horizontal)
        }
    }
}
//
//  PaywallPageView.swift
//  HairStyle
//
//  Created by adam on 25/03/2025.
//


import SwiftUI
import StoreKit

struct PaywallPageView: View {
    /// We get the subscription manager from the environment
    @EnvironmentObject var subscriptionManager: SubscriptionManager
    
    /// This is your old @AppStorage property that indicates premium status
    @Binding var isPremium: Bool
    
    /// Called when user finishes this screen (either purchase or “Not Now”)
    let onComplete: () -> Void
    
    var body: some View {
        VStack(spacing: 20) {
            Spacer()
            Text("Upgrade to Premium")
                .font(.largeTitle)
                .fontWeight(.bold)
            Text("Unlock unlimited image edits. Choose your plan below:")
                .font(.title3)
                .multilineTextAlignment(.center)
                .padding(.horizontal)
            
            if subscriptionManager.subscriptions.isEmpty {
                // If the products haven't loaded yet, show a spinner
                ProgressView("Loading subscriptions...")
                    .padding()
            } else {
                // Show each subscription product
                ForEach(subscriptionManager.subscriptions) { product in
                    Button {
                        Task {
                            do {
                                // Attempt to purchase
                                let transaction = try await subscriptionManager.purchase(product)
                                if transaction != nil {
                                    // Purchase successful
                                    isPremium = true
                                    onComplete()
                                }
                            } catch {
                                print("Purchase failed: \(error)")
                            }
                        }
                    } label: {
                        // Display the product’s name and price from StoreKit
                        Text("\(product.displayName) – \(product.displayPrice)")
                            .foregroundColor(.white)
                            .padding()
                            .frame(maxWidth: .infinity)
                            .background(Color.blue)
                            .cornerRadius(8)
                    }
                    .padding(.horizontal)
                }
            }
            
            Button(action: {
                // "Not Now" – continue as freemium (limited to 3 generations)
                onComplete()
            }) {
                Text("Not Now")
                    .underline()
                    .foregroundColor(.gray)
            }
            Button(action: {
                if let url = URL(string: "https://example.com/terms") {
                    UIApplication.shared.open(url)
                }
            }) {
                Text("Terms of Service")
                    .underline()
                    .foregroundColor(.blue)
            }
            Spacer()
        }
        .padding(.horizontal)
    }
}
//
//  SubscriptionManager.swift
//  HairStyle
//
//  Created by adam on 25/03/2025.
//


import StoreKit
import SwiftUI

@MainActor
class SubscriptionManager: ObservableObject {
    /// The subscription products fetched from StoreKit configuration
    @Published var subscriptions: [Product] = []
    
    /// Keep track of purchased product identifiers
    @Published var purchasedIdentifiers = Set<String>()
    
    /// Task to listen for any subscription updates
    private var updates: Task<Void, Never>?
    
    /// Define your product IDs exactly as they appear in your StoreKit config
    private let productIDs = [
        "weeksub"
    ]
    
    init() {
        // Start listening for transaction updates
        updates = listenForTransactions()
        
        // Immediately fetch products and update purchased info
        Task {
            await requestProducts()
            await updatePurchasedIdentifiers()
        }
    }
    
    /// Request products from StoreKit
    func requestProducts() async {
        do {
            let storeProducts = try await Product.products(for: productIDs)
            subscriptions = storeProducts
        } catch {
            print("Failed to request products: \(error)")
        }
    }
    
    /// Listen for any transaction updates (e.g., renewals, cancellations)
    private func listenForTransactions() -> Task<Void, Never> {
        Task.detached { [weak self] in
            guard let self = self else { return }
            for await result in Transaction.updates {
                do {
                    let transaction = try await self.checkVerified(result)
                    // If transaction is verified, apply changes
                    await self.updatePurchasedIdentifiers()
                    await transaction.finish()
                } catch {
                    print("Transaction failed verification")
                }
            }
        }
    }
    
    /// Update purchased identifiers from current entitlements
    private func updatePurchasedIdentifiers() async {
        purchasedIdentifiers.removeAll()
        for await verificationResult in Transaction.currentEntitlements {
            do {
                let transaction = try checkVerified(verificationResult)
                purchasedIdentifiers.insert(transaction.productID)
            } catch {
                // Not verified
            }
        }
    }
    
    /// Purchase a specific product
    func purchase(_ product: Product) async throws -> StoreKit.Transaction? {
        let result = try await product.purchase()
        switch result {
        case .success(let verification):
            let transaction = try checkVerified(verification)
            await transaction.finish()
            await updatePurchasedIdentifiers()
            return transaction
        case .userCancelled, .pending:
            return nil
        @unknown default:
            return nil
        }
    }
    
    /// Verify the transaction with StoreKit
    private func checkVerified<T>(_ result: VerificationResult<T>) throws -> T {
        switch result {
        case .unverified:
            throw StoreError.failedVerification
        case .verified(let safe):
            return safe
        }
    }
    
    enum StoreError: Error {
        case failedVerification
    }
}
import SwiftUI
import Vision
import CoreML
import CoreImage
import UIKit
import os


// MARK: - ImageEditingViewModel
class ImageEditingViewModel: ObservableObject {
    // MARK: - Published Properties
    @Published var prompt: String = ""
    @Published var editedImage: UIImage? = nil
    @Published var textResult: String = ""
    @Published var isLoading: Bool = false
    @Published var errorMessage: String = ""
    @Published var showPremiumAlert: Bool = false
    @Published var depthMapImage: UIImage? = nil  // Holds the generated depth map image
    
    // Depth model property
    //var model: DepthAnythingV2SmallF16?
    
    // Proxy endpoint for your Gemini API key.
    let apiURL = URL(string: "https://gemini-proxy-flame.vercel.app/api/gemini")! // earlier was https://gemini-proxy-flame.vercel.app/api/gemini
    
    // Define the target size expected by the model.
    private let targetSize = CGSize(width: 518, height: 392)
    
    // Shared CIContext instance.
    private let ciContext = CIContext()
    
    
    // New property: Public sharing checkbox state (default true)
    @Published var isPublicSharing: Bool = true
    
    // MARK: - Depth Model Loading & Depth Map Generation
    
    /// Loads your depth removal model.
    func loadModel() async throws {
        let config = MLModelConfiguration()
        config.computeUnits = .cpuOnly
       // model = try DepthAnythingV2SmallF16(configuration: config)
    }
    
    /*
    func generateDepthMap(for image: UIImage) async {
        // Ensure the model is loaded.
        guard let depthModel = model else {
            await MainActor.run { self.errorMessage = "Model not loaded." }
            return
        }
        
        // Create a resized pixel buffer (518 x 392) using the helper extension.
        guard let resizedBuffer = image.resizedPixelBuffer(width: Int(targetSize.width), height: Int(targetSize.height)) else {
            await MainActor.run { self.errorMessage = "Failed to create resized pixel buffer." }
            return
        }
        
        // Debug: confirm the pixel buffer size.
        let w = CVPixelBufferGetWidth(resizedBuffer)
        let h = CVPixelBufferGetHeight(resizedBuffer)
        print("Pixel buffer is \(w)x\(h)")  // Should be 518x392
        
        do {
            // Run model inference synchronously.
            let prediction = try depthModel.prediction(image: resizedBuffer)
            let depthBuffer = prediction.depth
            let depthCI = CIImage(cvPixelBuffer: depthBuffer)
            
            if let cgImage = ciContext.createCGImage(depthCI, from: depthCI.extent) {
                let finalUIImage = UIImage(cgImage: cgImage)
                await MainActor.run {
                    self.depthMapImage = finalUIImage
                    print("Depth map generation successful")
                }
            }
        } catch {
            await MainActor.run {
                self.errorMessage = "Depth model error: \(error.localizedDescription)"
            }
        }
    }

    */
    
    func editImage() {
        guard let image = editedImage,
              let imageData = image.jpegData(compressionQuality: 0.8)?.base64EncodedString() else {
            DispatchQueue.main.async {
                self.isLoading = false
                self.errorMessage = "No valid image selected"
            }
            return
        }
        
        isLoading = true
        errorMessage = ""
        textResult = ""
        
        let payload: [String: Any] = [
            "prompt": prompt,
            "image": imageData
        ]
        
        guard let jsonData = try? JSONSerialization.data(withJSONObject: payload) else {
            DispatchQueue.main.async {
                self.isLoading = false
                self.errorMessage = "Failed to serialize request"
            }
            return
        }
        
        var request = URLRequest(url: apiURL)
        request.httpMethod = "POST"
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")
        request.httpBody = jsonData
        
        URLSession.shared.dataTask(with: request) { [weak self] data, response, error in
            guard let self = self else { return }
            
            DispatchQueue.main.async { self.isLoading = false }
            
            if let error = error {
                DispatchQueue.main.async {
                    self.errorMessage = "Network error: \(error.localizedDescription)"
                }
                return
            }
            
            guard let data = data else {
                DispatchQueue.main.async {
                    self.errorMessage = "No data received from server"
                }
                return
            }
            
            do {
                if let jsonResponse = try JSONSerialization.jsonObject(with: data) as? [String: Any] {
                    // (Handle API error responses)
                    if let errorDict = jsonResponse["error"] as? [String: Any] {
                        let errorMessage = (errorDict["message"] as? String) ?? "Unknown error"
                        DispatchQueue.main.async {
                            self.errorMessage = "API Error: \(errorMessage)"
                        }
                        return
                    }
                    
                    // Process text and inline data responses
                    if let candidates = jsonResponse["candidates"] as? [[String: Any]],
                       let candidate = candidates.first,
                       let content = candidate["content"] as? [String: Any],
                       let parts = content["parts"] as? [[String: Any]] {
                        
                        for part in parts {
                            if let text = part["text"] as? String {
                                DispatchQueue.main.async {
                                    self.textResult += text
                                }
                            }
                            
                            if let inlineData = part["inlineData"] as? [String: Any],
                               let dataString = inlineData["data"] as? String,
                               let imageData = Data(base64Encoded: dataString),
                               let image = UIImage(data: imageData) {
                                
                                DispatchQueue.main.async {
                                    self.editedImage = image
                                }
                                
                                // Only share publicly if the toggle is on.
                             /*   if self.isPublicSharing {
                                    CloudinaryManager.upload(image: image) { secureUrl in
                                        if let url = secureUrl {
                                            print("Image uploaded to Cloudinary: \(url)")
                                            // Optionally: save the URL for your feed if needed.
                                        }
                                    }
                                }*/
                            }
                        }
                    } else {
                        let responseString = String(data: data, encoding: .utf8) ?? "Unable to parse response"
                        DispatchQueue.main.async {
                            self.textResult = "Response: \(responseString)"
                        }
                    }
                }
            } catch {
                DispatchQueue.main.async {
                    self.errorMessage = "Failed to parse response: \(error.localizedDescription)"
                    self.textResult = String(data: data, encoding: .utf8) ?? "Unable to display response"
                }
            }
        }.resume()
    }

    
    
    
}
//
//  EnhancementOption.swift
//  HairStyle
//
//  Created by adam on 25/04/2025.
//


//
//  BodyEnhancementPrompts.swift
//  HairStyle
//
//  Created by assistant on 25/04/2025.
//

import Foundation

/// A single enhancement option for a given body area.
struct EnhancementOption: Identifiable, Equatable {
    let id: String             // unique key
    let title: String          // display name
    let subtitle: String?      // optional secondary label (e.g., "Limited-time free")
    let prompt: String         // AI prompt to send
    let isFree: Bool           // whether this option is free
}

enum BodyEnhancementPrompts {
    static let breast: [EnhancementOption] = [
           EnhancementOption(id: "round",               title: "Round",                subtitle: nil,                prompt: "Respectfully enhance chest curvature",                                             isFree: true),
           EnhancementOption(id: "heart_shaped",        title: "Heart‑shaped",        subtitle: "Limited‑time free", prompt: "Enhance chest into a heart‑shaped bust",                                         isFree: true),
           EnhancementOption(id: "superlift",           title: "Superlift",           subtitle: nil,                prompt: "Apply superlift enhancement to chest",                                           isFree: false),
           EnhancementOption(id: "natural_lift",        title: "Natural Lift",        subtitle: nil,                prompt: "Apply natural lift enhancement to chest",                             isFree: false),
           EnhancementOption(id: "subtle_volume",       title: "Subtle Volume",       subtitle: nil,                prompt: "Respectfully but minimally enhance chest curvature",                           isFree: true),
           EnhancementOption(id: "snatched_cleavage",   title: "Snatched Cleavage",   subtitle: "Limited‑time free", prompt: "Respectfully but subtly enhance chest curvature",                      isFree: true)
       ]

       // MARK: – Belly / Core
       static let belly: [EnhancementOption] = [
           EnhancementOption(id: "flat_abs",            title: "Flat Abs",            subtitle: nil,                prompt: "Respectfully slim and flatten the belly and waist",                               isFree: true),
           EnhancementOption(id: "hourglass",           title: "Hourglass",           subtitle: nil,                prompt: "Respectfully enhance the waist‑to‑hip curve",                                     isFree: false),
           EnhancementOption(id: "defined_abs",         title: "Defined Abs",         subtitle: nil,                prompt: "Respectfully enhance the abdominal abs",                                        isFree: false),
           EnhancementOption(id: "sculpted_core",       title: "Sculpted Core",       subtitle: nil,                prompt: "Respectfully sculpt and refine the core muscles for balance",                   isFree: true),
           EnhancementOption(id: "chiseled_midsection", title: "Chiseled Midsection", subtitle: nil,                prompt: "Respectfully enhance the lines of the midsection abs",                         isFree: false),
           EnhancementOption(id: "snatched_waist",      title: "Snatched Waist",      subtitle: "Limited‑time free", prompt: "Respectfully cinch the waist for a snatched silhouette",                         isFree: true),
           EnhancementOption(id: "vacuum_slim",         title: "Vacuum Slim",         subtitle: nil,                prompt: "Respectfully apply stomach‑vacuum slimming for a flat profile",                 isFree: false),
           EnhancementOption(id: "core_carve",          title: "Core Carve",          subtitle: nil,                prompt: "Respectfully carve deep core lines for athletic definition",                   isFree: false)
       ]

       // MARK: – Buttock / Glutes
       static let buttock: [EnhancementOption] = [
           EnhancementOption(id: "lift",                title: "Lift",                subtitle: nil,                prompt: "Lift and sculpt the buttocks for a firmer look",                              isFree: true),
           EnhancementOption(id: "round",               title: "Round",               subtitle: nil,                prompt: "Enhance roundness for a curvier silhouette",                                   isFree: false),
           EnhancementOption(id: "heart_shaped",        title: "Heart‑shaped",        subtitle: "Limited‑time free", prompt: "Respectfully reshape glutes into a heart‑shaped form",                          isFree: true),
           EnhancementOption(id: "superlift",           title: "Superlift",           subtitle: nil,                prompt: "Apply superlift enhancement to buttocks for maximum elevation",               isFree: false),
           EnhancementOption(id: "sculpted_glutes",     title: "Sculpted Glutes",     subtitle: nil,                prompt: "Respectfully define and sculpt the glute muscles for a toned look",           isFree: false),
           EnhancementOption(id: "perky",               title: "Perky",               subtitle: nil,                prompt: "Respectfully perk up the buttocks for a youthful, lifted appearance",        isFree: true),
           EnhancementOption(id: "voluminous",          title: "Voluminous",          subtitle: nil,                prompt: "Enhance volume and roundness for fuller, more pronounced glutes",            isFree: false),
           EnhancementOption(id: "peach_lift",          title: "Peach Lift",          subtitle: nil,                prompt: "Respectfully lift glutes for a peach‑emoji vibe 🍑",                          isFree: true),
           EnhancementOption(id: "bubble_booty",        title: "Bubble Booty",        subtitle: nil,                prompt: "Respectfully add bubble‑shaped roundness for a playful look",                isFree: false),
           EnhancementOption(id: "brazilian_curve",     title: "Brazilian Curve",     subtitle: "Limited‑time free", prompt: "Respectfully enhance lower‑upper glute transition for Brazilian shape",       isFree: true),
           EnhancementOption(id: "shape_360",           title: "360 Shape",           subtitle: nil,                prompt: "Respectfully smooth and contour hips & glutes for a 360° hourglass",         isFree: false)
       ]

       // MARK: – Muscle / Arms
       static let muscle: [EnhancementOption] = [
           EnhancementOption(id: "tone",                title: "Upper Body",          subtitle: nil,                prompt: "Respectfully increase the muscle shape on neck and upper body",               isFree: true),
           EnhancementOption(id: "sculpt",              title: "Arms & Forearms",     subtitle: nil,                prompt: "Respectfully enhance the muscle shape on the arms and forearms",            isFree: false),
           EnhancementOption(id: "bicep_peak",          title: "Bicep Peak",          subtitle: nil,                prompt: "Respectfully accentuate the bicep peak for a more pronounced flex",        isFree: false),
           EnhancementOption(id: "tricep_tone",         title: "Tricep Tone",         subtitle: nil,                prompt: "Respectfully slim and tone the triceps for sleek definition",              isFree: true),
           EnhancementOption(id: "vascular_forearms",   title: "Vascular Forearms",   subtitle: "Limited‑time free", prompt: "Respectfully highlight forearm veins and muscle separation",                  isFree: true),
           EnhancementOption(id: "forearm_definition",  title: "Forearm Definition",  subtitle: nil,                prompt: "Respectfully define the forearm muscles for enhanced detail",              isFree: false),
           EnhancementOption(id: "arm_strength",        title: "Strength Boost",       subtitle: nil,                prompt: "Respectfully add subtle bulk to arms",                                   isFree: false),
           EnhancementOption(id: "swimmer_build",       title: "Swimmer Build",       subtitle: nil,                prompt: "Respectfully broaden shoulders and taper waist for swimmer aesthetics",     isFree: false),
           EnhancementOption(id: "athlete_tone",        title: "Athlete Tone",        subtitle: nil,                prompt: "Respectfully tone arms for an athletic, sporty vibe",                      isFree: true),
           EnhancementOption(id: "power_flex",          title: "Power Flex",          subtitle: "Limited‑time free", prompt: "Respectfully sharpen muscle definition for a power pose",                     isFree: true)
       ]
    
    // MARK: – Waist
    static let waist: [EnhancementOption] = [
        // Existing
        EnhancementOption(id: "slim",             title: "Slim",             subtitle: nil,                prompt: "Slim and cinch the waist",                                                     isFree: true),
        EnhancementOption(id: "curve",            title: "Curve",            subtitle: nil,                prompt: "Enhance waist curves for definition",                                         isFree: false),
        EnhancementOption(id: "v_shape",          title: "V-Shape",          subtitle: nil,                prompt: "Respectfully sculpt a tapered V-shape waist",                                  isFree: false),
        EnhancementOption(id: "corset_cinch",     title: "Corset Cinch",     subtitle: "Limited-time free", prompt: "Respectfully simulate corset-style waist cinching for TikTok snatch",           isFree: true),

        // New additions
        EnhancementOption(id: "hourglass",        title: "Hourglass",        subtitle: nil,                prompt: "Respectfully sculpt an hourglass silhouette",                                  isFree: false),
        EnhancementOption(id: "micro_cinch",      title: "Micro Cinch",      subtitle: "Limited-time free", prompt: "Respectfully simulate an ultra-cinched micro waist",                           isFree: true),
        EnhancementOption(id: "athletic_tone",    title: "Athletic Tone",    subtitle: nil,                prompt: "Define a toned, athletic waistline",                                           isFree: false),
        EnhancementOption(id: "balanced_curve",   title: "Balanced Curve",   subtitle: nil,                prompt: "Add gentle definition for a balanced waist curve",                             isFree: true),
        EnhancementOption(id: "dream_sculpt",     title: "Dream Sculpt",     subtitle: nil,                prompt: "Sculpt a dreamy snatched waistline fit for viral looks",                       isFree: false),
        EnhancementOption(id: "vapor_snatch",     title: "Vapor Snatch",     subtitle: "Limited-time free", prompt: "Respectfully vapor-snatch the waist for an ethereal cinched look",             isFree: true),
        EnhancementOption(id: "soft_taper",       title: "Soft Taper",       subtitle: nil,                prompt: "Create a soft, natural waist taper",                                           isFree: true),
        EnhancementOption(id: "precision_trim",   title: "Precision Trim",   subtitle: nil,                prompt: "Apply precise trimming for a sleek waist contour",                             isFree: false)
    ]


       // MARK: – Hair
       static let hair: [EnhancementOption] = [
           EnhancementOption(id: "volume",              title: "Volume",              subtitle: nil,                prompt: "Add natural volume and body to hair",                                    isFree: true),
           EnhancementOption(id: "smooth",              title: "Smooth",              subtitle: nil,                prompt: "Smooth hair and reduce frizz",                                          isFree: false),
           EnhancementOption(id: "silver_blonde",       title: "Silver Blonde",       subtitle: nil,                prompt: "Transform hair to a chic silver blonde shade",                            isFree: true),
           EnhancementOption(id: "bob_cut",             title: "Bob Cut",             subtitle: nil,                prompt: "Give hair a modern bob cut",                                            isFree: false),
           EnhancementOption(id: "afro",                title: "Afro",                subtitle: "Limited‑time free", prompt: "Define natural afro texture and volume",                                    isFree: true),
           EnhancementOption(id: "pixie_cut",           title: "Pixie Cut",           subtitle: nil,                prompt: "Create a stylish pixie cut",                                           isFree: false),
           EnhancementOption(id: "ombre",               title: "Ombre",               subtitle: nil,                prompt: "Add subtle ombre color blending",                                       isFree: true),
           EnhancementOption(id: "highlights",          title: "Highlights",          subtitle: nil,                prompt: "Incorporate bright highlights throughout hair",                           isFree: false),
           EnhancementOption(id: "balayage",            title: "Balayage",            subtitle: nil,                prompt: "Apply a natural balayage painting technique",                             isFree: false),
           EnhancementOption(id: "loose_curls",         title: "Loose Curls",         subtitle: nil,                prompt: "Add loose, bouncy curls for movement",                                   isFree: true),
           EnhancementOption(id: "beach_waves",         title: "Beach Waves",         subtitle: "Limited‑time free", prompt: "Create soft, effortless beach waves",                                      isFree: true),
           EnhancementOption(id: "sleek_straight",      title: "Sleek Straight",      subtitle: nil,                prompt: "Smooth hair into a sleek, straight style",                                 isFree: false),
           EnhancementOption(id: "butterfly_layers",    title: "Butterfly Layers",    subtitle: nil,                prompt: "Add TikTok trending butterfly layers for airy movement",                   isFree: true),
           EnhancementOption(id: "curtain_bangs",       title: "Curtain Bangs",       subtitle: nil,                prompt: "Add soft curtain bangs framing the face",                                isFree: false),
           EnhancementOption(id: "mermaid_waves",       title: "Mermaid Waves",       subtitle: "Limited‑time free", prompt: "Create long, flowing mermaid waves with shine",                              isFree: true),
           EnhancementOption(id: "copper_glow",         title: "Copper Glow",         subtitle: nil,                prompt: "Transform hair to a warm LA‑sun copper glow",                              isFree: false),
           EnhancementOption(id: "pastel_pink",         title: "Pastel Pink",         subtitle: nil,                prompt: "Tint hair a playful pastel pink",                                       isFree: false)
       ]
    // MARK: – Nose
    static let nose: [EnhancementOption] = [
        // Existing
        EnhancementOption(id: "refine",           title: "Refine",            subtitle: nil,                 prompt: "Refine the nose shape subtly",                                                      isFree: true),
        EnhancementOption(id: "slim",             title: "Slim",              subtitle: nil,                 prompt: "Slim down the nose bridge",                                                        isFree: false),
        EnhancementOption(id: "button_tip",       title: "Button Tip",        subtitle: nil,                 prompt: "Respectfully soften and round the nose tip for a button effect",                  isFree: true),
        EnhancementOption(id: "soft_contour",     title: "Soft Contour",      subtitle: nil,                 prompt: "Respectfully add gentle shadow for a softly contoured nose",                      isFree: false),

        // New additions
        EnhancementOption(id: "pixie_lift",       title: "Pixie Lift",        subtitle: nil,                 prompt: "Respectfully lift and refine the nose tip for a pixie-esque profile",             isFree: false),
        EnhancementOption(id: "snatched_bridge",  title: "Snatched Bridge",   subtitle: "Limited-time free", prompt: "Respectfully slim and sharpen the nose bridge for a snatched look",               isFree: true),
        EnhancementOption(id: "doll_nose",        title: "Doll Nose",         subtitle: nil,                 prompt: "Respectfully sculpt a petite, doll-like nose shape",                               isFree: false),
        EnhancementOption(id: "airbrush_narrow",  title: "Airbrush Narrow",   subtitle: nil,                 prompt: "Airbrush-style narrowing for a photo-ready nose",                                  isFree: true),
        EnhancementOption(id: "slope_sculpt",     title: "Slope Sculpt",      subtitle: nil,                 prompt: "Respectfully sculpt a gentle ski-slope nose profile",                              isFree: false),
        EnhancementOption(id: "natural_polish",   title: "Natural Polish",    subtitle: "Limited-time free", prompt: "Add subtle refinement for a naturally polished nose",                               isFree: true),
        EnhancementOption(id: "cupids_dip",       title: "Cupid’s Dip",       subtitle: nil,                 prompt: "Create a delicate dip just beneath the tip for a Cupid-inspired contour",          isFree: false),
        EnhancementOption(id: "halo_highlight",   title: "Halo Highlight",    subtitle: nil,                 prompt: "Respectfully add soft highlight to accentuate the nose bridge",                   isFree: true)
    ]


    // MARK: – Eyes
    static let eyes: [EnhancementOption] = [
        // Existing
        EnhancementOption(id: "brighten",         title: "Brighten",          subtitle: nil,                 prompt: "Brighten eyes and reduce shadows",                                                  isFree: true),
        EnhancementOption(id: "enlarge",          title: "Enlarge",           subtitle: nil,                 prompt: "Subtly enlarge the eyes",                                                          isFree: false),
        EnhancementOption(id: "fox_lift",         title: "Fox Lift",          subtitle: nil,                 prompt: "Respectfully lift outer corners for a fox-eye trend",                               isFree: true),
        EnhancementOption(id: "doll_eyes",        title: "Doll Eyes",         subtitle: "Limited-time free", prompt: "Respectfully widen and round eyes for a doll-like effect",                           isFree: true),
        EnhancementOption(id: "winged_liner",     title: "Winged Liner",      subtitle: nil,                 prompt: "Apply a clean winged-liner illusion for sharp definition",                          isFree: false),

        // New additions
        EnhancementOption(id: "siren_lift",       title: "Siren Lift",        subtitle: nil,                 prompt: "Respectfully raise outer corners for a sultry siren-eye look",                     isFree: false),
        EnhancementOption(id: "soft_sparkle",     title: "Soft Sparkle",      subtitle: nil,                 prompt: "Gently add subtle shimmer for softly sparkling eyes",                               isFree: true),
        EnhancementOption(id: "mega_pop",         title: "Mega Pop",          subtitle: "Limited-time free", prompt: "Intensify iris clarity for ultra-pop TikTok eyes",                                   isFree: true),
        EnhancementOption(id: "pastel_twinkle",   title: "Pastel Twinkle",    subtitle: nil,                 prompt: "Tint eyes with a pastel twinkle for dreamy vibes",                                   isFree: false),
        EnhancementOption(id: "graphic_flick",    title: "Graphic Flick",     subtitle: nil,                 prompt: "Apply a bold graphic liner flick for statement eyes",                               isFree: false),
        EnhancementOption(id: "dreamy_haze",      title: "Dreamy Haze",       subtitle: nil,                 prompt: "Add a soft-focus haze for ethereal eyes",                                           isFree: true),
        EnhancementOption(id: "icicle_bright",    title: "Icicle Bright",     subtitle: "Limited-time free", prompt: "Cool-tone brighten for an icy, refreshed gaze",                                      isFree: true),
        EnhancementOption(id: "subtle_smoke",     title: "Subtle Smoke",      subtitle: nil,                 prompt: "Respectfully add a gentle smoky contour for depth",                                 isFree: false)
    ]

    // MARK: – Skin
    static let skin: [EnhancementOption] = [
        // Existing
        EnhancementOption(id: "smooth",        title: "Smooth",        subtitle: nil,                 prompt: "Smooth skin texture and even tone",                             isFree: true),
        EnhancementOption(id: "glow",          title: "Glow",          subtitle: nil,                 prompt: "Add a healthy, radiant glow",                                   isFree: false),

        // New additions
        EnhancementOption(id: "airbrush",      title: "Airbrush",      subtitle: nil,                 prompt: "Apply studio-grade airbrush smoothing and even tones",           isFree: false),
        EnhancementOption(id: "glass_skin",    title: "Glass Skin",    subtitle: "Limited-time free", prompt: "Respectfully create a dewy glass-skin finish",                    isFree: true),
        EnhancementOption(id: "peachy_blush",  title: "Peachy Blush",  subtitle: nil,                 prompt: "Add a soft peachy flush for a healthy TikTok blush look",        isFree: true),
        EnhancementOption(id: "bronze_tan",    title: "Bronze Tan",    subtitle: nil,                 prompt: "Apply a subtle sun-kissed bronze tan",                           isFree: false),
        EnhancementOption(id: "freckle_kiss",  title: "Freckle Kiss",  subtitle: "Limited-time free", prompt: "Sprinkle natural-looking sun freckles for playful vibes",        isFree: true),
        EnhancementOption(id: "clarity_boost", title: "Clarity Boost", subtitle: nil,                 prompt: "Reduce blemishes and enhance skin clarity",                      isFree: false),
        EnhancementOption(id: "matte_filter",  title: "Matte Filter",  subtitle: nil,                 prompt: "Respectfully mattify skin to reduce shine",                      isFree: true),
        EnhancementOption(id: "pearl_highlight",title: "Pearl Highlight",subtitle: nil,               prompt: "Apply soft pearl highlights for luminous skin accents",          isFree: false)
    ]

    // MARK: – Face
    static let face: [EnhancementOption] = [
        // Existing
        EnhancementOption(id: "contour",        title: "Contour",        subtitle: nil,                 prompt: "Add subtle contour to face",                                   isFree: true),
        EnhancementOption(id: "smooth",         title: "Smooth",         subtitle: nil,                 prompt: "Smooth overall facial features",                               isFree: false),

        // New additions
        EnhancementOption(id: "jawline_define", title: "Jawline Define", subtitle: nil,                 prompt: "Sharpen jawline for a defined look",                           isFree: false),
        EnhancementOption(id: "cheek_lift",     title: "Cheek Lift",     subtitle: nil,                 prompt: "Respectfully lift and sculpt cheekbones",                      isFree: true),
        EnhancementOption(id: "v_face",         title: "V-Face",         subtitle: "Limited-time free", prompt: "Respectfully sculpt a sleek V-shaped face",                    isFree: true),
        EnhancementOption(id: "baby_soft",      title: "Baby Soft",      subtitle: nil,                 prompt: "Subtly soften features for a baby-face effect",                isFree: true),
        EnhancementOption(id: "siren_sculpt",   title: "Siren Sculpt",   subtitle: nil,                 prompt: "Respectfully sculpt striking features for a siren look",       isFree: false),
        EnhancementOption(id: "golden_ratio",   title: "Golden Ratio",   subtitle: nil,                 prompt: "Refine facial proportions toward the golden ratio",            isFree: false),
        EnhancementOption(id: "soft_highlight", title: "Soft Highlight", subtitle: "Limited-time free", prompt: "Add gentle highlighted glow to lift features",                 isFree: true),
        EnhancementOption(id: "chin_tuck",      title: "Chin Tuck",      subtitle: nil,                 prompt: "Subtly tuck chin for a refined profile",                       isFree: false)
    ]

    // MARK: – Lips
    static let lips: [EnhancementOption] = [
        // Existing
        EnhancementOption(id: "full",           title: "Full",            subtitle: nil,                 prompt: "Enhance lip fullness",                                                         isFree: true),
        EnhancementOption(id: "color",          title: "Color",           subtitle: nil,                 prompt: "Add natural lip color",                                                        isFree: false),

        // New additions
        EnhancementOption(id: "gloss_sheen",    title: "Gloss Sheen",      subtitle: "Limited-time free", prompt: "Add a high-shine gloss sheen for viral glow",                                    isFree: true),
        EnhancementOption(id: "soft_ombre",     title: "Soft Ombré",       subtitle: nil,                 prompt: "Apply a subtle ombré gradient for fuller-looking lips",                          isFree: false),
        EnhancementOption(id: "cupid_bow",      title: "Cupid’s Bow",      subtitle: nil,                 prompt: "Enhance Cupid’s bow definition for a crisp lip shape",                           isFree: false),
        EnhancementOption(id: "velvet_matte",   title: "Velvet Matte",     subtitle: nil,                 prompt: "Give lips a plush velvet-matte finish",                                         isFree: false),
        EnhancementOption(id: "plump_pout",     title: "Plump Pout",       subtitle: "Limited-time free", prompt: "Respectfully plump lips for a TikTok-ready pout",                                isFree: true),
        EnhancementOption(id: "blushed_tint",   title: "Blushed Tint",     subtitle: nil,                 prompt: "Add a soft blushed tint for a natural flush",                                   isFree: true),
        EnhancementOption(id: "frosted_shine",  title: "Frosted Shine",    subtitle: nil,                 prompt: "Apply shimmering frosted shine for nostalgic Y2K vibes",                        isFree: false)
    ]
    // MARK: – Legs
    static let leg: [EnhancementOption] = [
        // Existing
        EnhancementOption(id: "slim",              title: "Slim",               subtitle: nil,                 prompt: "Slim and lengthen legs",                                                          isFree: true),
        EnhancementOption(id: "tone",              title: "Tone",               subtitle: nil,                 prompt: "Tone leg muscles for definition",                                                isFree: false),

        // New additions
        EnhancementOption(id: "barbie_length",     title: "Barbie Length",      subtitle: "Limited-time free", prompt: "Lengthen and refine legs for Barbiecore proportions",                              isFree: true),
        EnhancementOption(id: "model_stretch",     title: "Model Stretch",      subtitle: nil,                 prompt: "Respectfully elongate legs for a runway-model stretch",                          isFree: false),
        EnhancementOption(id: "athletic_sculpt",   title: "Athletic Sculpt",    subtitle: nil,                 prompt: "Enhance muscle definition for a sporty leg sculpt",                               isFree: false),
        EnhancementOption(id: "pilates_tone",      title: "Pilates Tone",       subtitle: nil,                 prompt: "Add gentle Pilates-inspired toning",                                             isFree: true),
        EnhancementOption(id: "sun_kissed_glow",   title: "Sun-Kissed Glow",    subtitle: nil,                 prompt: "Apply a subtle sun-bronzed glow to legs",                                        isFree: false),
        EnhancementOption(id: "glass_shine",       title: "Glass Shine",        subtitle: "Limited-time free", prompt: "Add glossy glass-skin shine for viral leg sheen",                                 isFree: true),
        EnhancementOption(id: "dreamy_slim",       title: "Dreamy Slim",        subtitle: nil,                 prompt: "Soft-focus slim effect for dreamy long legs",                                    isFree: false),
        EnhancementOption(id: "v_line_define",     title: "V-Line Define",      subtitle: nil,                 prompt: "Sculpt inner-thigh V-line for crisp definition",                                 isFree: false)
    ]

    
    static let jewellery: [EnhancementOption] = [
        EnhancementOption(
                id: "gold_hoop_minimal",
                title: "Minimal Gold Hoops",
                subtitle: nil,
                prompt: "Add sleek, minimalistic gold hoop earrings",
                isFree: true
            ),
            EnhancementOption(
                id: "delicate_gold_chain",
                title: "Delicate Gold Chain",
                subtitle: nil,
                prompt: "Add a thin, delicate gold chain necklace",
                isFree: true
            ),
            EnhancementOption(
                id: "stackable_bands",
                title: "Stackable Bands",
                subtitle: nil,
                prompt: "Add a set of minimal stackable gold rings",
                isFree: false
            ),
            EnhancementOption(
                id: "geometric_studs",
                title: "Geometric Studs",
                subtitle: nil,
                prompt: "Add small geometric stud earrings in gold",
                isFree: true
            ),
            EnhancementOption(
                id: "thin_gold_bangle",
                title: "Thin Gold Bangle",
                subtitle: nil,
                prompt: "Add a slender, minimalistic gold bangle bracelet",
                isFree: false
            ),
            EnhancementOption(
                id: "gold_bar_necklace",
                title: "Gold Bar Necklace",
                subtitle: "Limited-time free",
                prompt: "Add a minimalist gold bar pendant necklace",
                isFree: true
            ),
            EnhancementOption(
                id: "link_chain_bracelet",
                title: "Link Chain Bracelet",
                subtitle: nil,
                prompt: "Add a bold gold link chain bracelet",
                isFree: false
            ),
            EnhancementOption(
                id: "pearls_and_gold",
                title: "Pearls & Gold",
                subtitle: nil,
                prompt: "Add a blend of pearls with gold accents",
                isFree: true
            ),
            EnhancementOption(
                id: "gold_cuff_minimal",
                title: "Minimal Gold Cuff",
                subtitle: nil,
                prompt: "Add a clean, minimalistic gold cuff bracelet",
                isFree: false
            ),
            EnhancementOption(
                id: "layered_gold_chains",
                title: "Layered Gold Chains",
                subtitle: nil,
                prompt: "Add multiple thin gold chain necklaces for layering",
                isFree: false
            ),
        EnhancementOption(
            id: "earrings",
            title: "Earrings",
            subtitle: nil,
            prompt: "Add stylish earrings",
            isFree: true
        ),
        EnhancementOption(
            id: "necklace",
            title: "Necklace",
            subtitle: nil,
            prompt: "Add a beautiful necklace",
            isFree: false
        ),
        EnhancementOption(
            id: "bracelet",
            title: "Bracelet",
            subtitle: nil,
            prompt: "Add a delicate bracelet around the wrist",
            isFree: true
        ),
        EnhancementOption(
            id: "ring",
            title: "Ring",
            subtitle: nil,
            prompt: "Add a sparkling ring to the fingers",
            isFree: false
        ),
        EnhancementOption(
            id: "anklet",
            title: "Anklet",
            subtitle: "Limited-time free",
            prompt: "Add a subtle anklet for a refined touch",
            isFree: true
        ),
        EnhancementOption(
            id: "chandelier_earrings",
            title: "Chandelier Earrings",
            subtitle: nil,
            prompt: "Add elegant chandelier-style earrings",
            isFree: false
        ),
        EnhancementOption(
            id: "hoop_earrings",
            title: "Hoop Earrings",
            subtitle: nil,
            prompt: "Add classic hoop earrings",
            isFree: true
        ),
        EnhancementOption(
            id: "cuff_bracelet",
            title: "Cuff Bracelet",
            subtitle: nil,
            prompt: "Add a bold cuff bracelet to the wrist",
            isFree: false
        ),
        EnhancementOption(
            id: "choker",
            title: "Choker",
            subtitle: nil,
            prompt: "Add a sleek choker around the neck",
            isFree: true
        ),
        EnhancementOption(
            id: "pendant",
            title: "Pendant",
            subtitle: nil,
            prompt: "Add a charming pendant on a fine chain",
            isFree: false
        ),
        EnhancementOption(
            id: "brooch",
            title: "Brooch",
            subtitle: nil,
            prompt: "Add a decorative brooch for a vintage flair",
            isFree: true
        ),
        EnhancementOption(
            id: "watch",
            title: "Watch",
            subtitle: nil,
            prompt: "Add a stylish wristwatch",
            isFree: false
        )
    ]

    // New Eyewear options
    static let eyewear: [EnhancementOption] = [
        EnhancementOption(
            id: "eyewear",
            title: "Eyewear",
            subtitle: nil,
            prompt: "Add stylish eyewear frames",
            isFree: true
        ),
        EnhancementOption(
            id: "sunglasses",
            title: "Sunglasses",
            subtitle: nil,
            prompt: "Add trendy sunglasses with reflective lenses",
            isFree: false
        ),
        EnhancementOption(
            id: "reading_glasses",
            title: "Reading Glasses",
            subtitle: "Limited-time free",
            prompt: "Add elegant reading glasses with thin frames",
            isFree: true
        ),
        EnhancementOption(
            id: "aviators",
            title: "Aviator Frames",
            subtitle: nil,
            prompt: "Add classic aviator sunglasses with metal frames",
            isFree: false
        ),
        EnhancementOption(
            id: "wayfarer",
            title: "Wayfarer",
            subtitle: nil,
            prompt: "Add stylish wayfarer-style glasses",
            isFree: true
        ),
        EnhancementOption(
            id: "round_frames",
            title: "Round Frames",
            subtitle: nil,
            prompt: "Add vintage round frame glasses",
            isFree: false
        ),
        EnhancementOption(
            id: "cat_eye",
            title: "Cat-eye",
            subtitle: nil,
            prompt: "Add chic cat-eye glasses for a retro look",
            isFree: true
        ),
        EnhancementOption(
            id: "translucent_frames",
            title: "Translucent Frames",
            subtitle: nil,
            prompt: "Add translucent frame glasses with modern vibe",
            isFree: false
        ),
        EnhancementOption(
            id: "sports_goggles",
            title: "Sports Goggles",
            subtitle: nil,
            prompt: "Add sporty wrap-around goggles",
            isFree: false
        ),
        EnhancementOption(
            id: "steampunk_goggles",
            title: "Steampunk Goggles",
            subtitle: "Limited-time free",
            prompt: "Add decorative steampunk-style goggles",
            isFree: true
        )
    ]
}
//
//  ImagePicker.swift
//  HairStyle
//
//  Created by Adam Roszyk on 3/19/25.
//
import SwiftUI
import PhotosUI


// UIKit-based image picker integrated into SwiftUI using UIViewControllerRepresentable
struct ImagePicker: UIViewControllerRepresentable {
    class Coordinator: NSObject, UINavigationControllerDelegate, UIImagePickerControllerDelegate {
        let parent: ImagePicker

        init(_ parent: ImagePicker) {
            self.parent = parent
        }
        func imagePickerController(_ picker: UIImagePickerController,
                                   didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey : Any]) {
            if let uiImage = info[.originalImage] as? UIImage {
                parent.image = uiImage
            }
            picker.dismiss(animated: true)
        }
    }
    
    @Binding var image: UIImage?
    
    func makeCoordinator() -> Coordinator {
        Coordinator(self)
    }
    func makeUIViewController(context: Context) -> UIImagePickerController {
        let picker = UIImagePickerController()
        picker.delegate = context.coordinator
        return picker
    }
    func updateUIViewController(_ uiViewController: UIImagePickerController, context: Context) {}
}
import SwiftUI
import Vision
import CoreML
import CoreImage
import UIKit
import os

// MARK: - CIImage Extension
extension CIImage {
    /// Returns a resized CIImage.
    func resized(to size: CGSize) -> CIImage {
        let scaleX = size.width / extent.width
        let scaleY = size.height / extent.height
        var outputImage = transformed(by: CGAffineTransform(scaleX: scaleX, y: scaleY))
        // Reset the origin to (0,0)
        outputImage = outputImage.transformed(by: CGAffineTransform(translationX: -outputImage.extent.origin.x,
                                                                    y: -outputImage.extent.origin.y))
        return outputImage
    }
}
extension CIContext {
    /// Renders a CIImage to a new CVPixelBuffer using the specified pixel format.
    func render(_ image: CIImage, pixelFormat: OSType) -> CVPixelBuffer? {
        // Ensure valid dimensions by rounding up and enforcing a minimum value
        let width = max(Int(ceil(image.extent.width)), 1)
        let height = max(Int(ceil(image.extent.height)), 1)
        let attrs: [CFString: Any] = [
            kCVPixelBufferCGImageCompatibilityKey: true,
            kCVPixelBufferCGBitmapContextCompatibilityKey: true,
            kCVPixelBufferIOSurfacePropertiesKey: [:]
        ]
        var pixelBuffer: CVPixelBuffer?
        let status = CVPixelBufferCreate(
            kCFAllocatorDefault,
            width,
            height,
            pixelFormat,
            attrs as CFDictionary,
            &pixelBuffer
        )
        guard status == kCVReturnSuccess, let buffer = pixelBuffer else {
            print("CVPixelBufferCreate failed with status: \(status)")
            return nil
        }
        self.render(image, to: buffer)
        return buffer
    }
}


// Extension to enhance image contrast
extension UIImage {
    func applyingContrast(_ contrast: CGFloat) -> UIImage? {
        guard let cgImage = self.cgImage else { return nil }
        
        let context = CIContext()
        let ciImage = CIImage(cgImage: cgImage)
        
        let filter = CIFilter(name: "CIColorControls")
        filter?.setValue(ciImage, forKey: kCIInputImageKey)
        filter?.setValue(contrast, forKey: kCIInputContrastKey)
        filter?.setValue(0, forKey: kCIInputBrightnessKey)
        filter?.setValue(1.0, forKey: kCIInputSaturationKey)
        
        guard let outputImage = filter?.outputImage,
              let filteredCGImage = context.createCGImage(outputImage, from: outputImage.extent) else {
            return nil
        }
        
        return UIImage(cgImage: filteredCGImage, scale: self.scale, orientation: self.imageOrientation)
    }
}

extension UIImage {
    func resizedPixelBuffer(width: Int, height: Int) -> CVPixelBuffer? {
        var pxBuffer: CVPixelBuffer?
        let attrs = [
            kCVPixelBufferCGImageCompatibilityKey: true,
            kCVPixelBufferCGBitmapContextCompatibilityKey: true
        ] as CFDictionary
        
        guard CVPixelBufferCreate(kCFAllocatorDefault,
                                  width,
                                  height,
                                  kCVPixelFormatType_32ARGB,
                                  attrs,
                                  &pxBuffer) == kCVReturnSuccess,
              let buffer = pxBuffer,
              let cgImage = self.cgImage else {
            return nil
        }
        CVPixelBufferLockBaseAddress(buffer, [])
        defer { CVPixelBufferUnlockBaseAddress(buffer, []) }
        
        let context = CGContext(data: CVPixelBufferGetBaseAddress(buffer),
                                width: width,
                                height: height,
                                bitsPerComponent: 8,
                                bytesPerRow: CVPixelBufferGetBytesPerRow(buffer),
                                space: CGColorSpaceCreateDeviceRGB(),
                                bitmapInfo: CGImageAlphaInfo.noneSkipFirst.rawValue)
        guard let ctx = context else { return nil }
        
        let rect = CGRect(x: 0, y: 0, width: width, height: height)
        ctx.draw(cgImage, in: rect)
        
        return buffer
    }
}
import SwiftUI
@main
struct HairStyleApp: App {
    @AppStorage("hasSeenDemo")            private var hasSeenDemo            = false
    @AppStorage("hasCompletedOnboarding") private var hasCompletedOnboarding = false
    
    @StateObject private var subscriptionManager = SubscriptionManager()
    
    var body: some Scene {
        WindowGroup {
            if hasCompletedOnboarding {
                CatalogView()
                    .environmentObject(subscriptionManager)
            } else {
                OnboardingFlowView()          // ← new flow
                    .environmentObject(subscriptionManager)
            }
        }
    }
}
