2025-04-29 11:08:48
import SwiftUI

/// The bottom action bar for the enhancement panel.
/// Now displays the currently selected option’s icon in the center.
struct BottomBar: View {
    /// The name of the asset to show between Cancel and Apply.
    let iconAssetName: String?
    let onCancel: () -> Void
    let onApply: () -> Void

    var body: some View {
        HStack {
            // Cancel button
            Button(action: onCancel) {
                Label("Cancel", systemImage: "xmark")
                    .font(.headline)
                    .foregroundColor(.white)
                    .padding(.vertical, 14)
                    .padding(.horizontal, 20)
            }

            Spacer()

            // Center icon for the selected enhancement
            if let asset = iconAssetName {
                Image(asset)
                    .resizable()
                    .aspectRatio(contentMode: .fit)
                    .frame(width: 44, height: 44)
            }

            Spacer()

            // Apply button
            Button(action: onApply) {
                Label("Apply", systemImage: "checkmark")
                    .font(.headline)
                    .foregroundColor(.white)
                    .padding(.vertical, 6)
                    .padding(.horizontal, 18)
            }
        }
        .padding(.horizontal, 7)
        .padding(.bottom, 20)
    }
}
import SwiftUI

struct EnhancementPanelView: View {
    let section: String
    let options: [EnhancementOption]
    @Binding var selectedOption: EnhancementOption?
    let applyAction: () -> Void
    let cancelAction: () -> Void

    var body: some View {
        VStack(spacing: 12) {
            PillsScroll(options: options, selectedOption: $selectedOption)
            Divider().background(Color.white.opacity(0.5))
            BottomBar(
                iconAssetName: sectionIconName,
                onCancel: cancelAction,
                onApply: applyAction
            )
        }
        .background(.ultraThinMaterial)
        .cornerRadius(16)
        .padding(.horizontal, 16)
        .padding(.bottom, 8)
        .padding(.top, 12)
    }
    
    private var sectionIconName: String {
        // e.g. "Slim Waist" → "SlimWaist"
        section.replacingOccurrences(of: " ", with: "")
    }
}

// MARK: — Pills Scroll

private struct PillsScroll: View {
    let options: [EnhancementOption]
    @Binding var selectedOption: EnhancementOption?

    var body: some View {
        ScrollView(.horizontal, showsIndicators: false) {
            HStack(spacing: 16) {
                ForEach(options) { opt in
                    OptionPill(
                        option: opt,
                        isSelected: opt.id == selectedOption?.id
                    )
                    .onTapGesture { selectedOption = opt }
                }
            }
            .padding(.horizontal, 16)
            .padding(.bottom, 8)
            .padding(.top, 12)
        }
    }
}

// MARK: — Single Pill

private struct OptionPill: View {
    let option: EnhancementOption
    let isSelected: Bool

    // map id → SF symbol
    private var iconName: String {
        switch option.id {
        case "round":        return "circle"
        case "heart_shaped": return "heart.fill"
        case "superlift":    return "flame.fill"
        default:             return "sparkles"
        }
    }

    private var titleColor: AnyShapeStyle {
        if isSelected {
            return AnyShapeStyle(
                LinearGradient(
                    colors: [Color.pink, Color.orange],
                    startPoint: .leading,
                    endPoint: .trailing
                )
            )
        } else {
            return AnyShapeStyle(Color.white.opacity(0.9))
        }
    }

    var body: some View {
        HStack(spacing: 12) {
            Image(systemName: iconName)
                .font(.subheadline)
                .foregroundColor(isSelected ? .white : .white.opacity(0.7))
            Text(option.title)
                .font(.subheadline)
                .fontWeight(.medium)
                .foregroundStyle(titleColor)
        }
        // ↑ bump horizontal padding from 16 → 20, vertical from 8 → 12
        .padding(.vertical, 12)
        .padding(.horizontal, 20)
        .background(isSelected
                    ? Color.black.opacity(0.85)
                    : Color.black.opacity(0.6))
        .cornerRadius(24)  // slightly larger radius
        .overlay(
                    Group {
                        if isSelected {
                            Image(systemName: "checkmark.circle.fill")
                                .font(.title3)            // slightly larger
                                .foregroundColor(.white)  // white+
                                .offset(x: 8, y: -8)

                        }
                    },
                    alignment: .topTrailing
                )    }
    @ViewBuilder
    private var checkmarkOverlay: some View {
        if isSelected {
            Image(systemName: "checkmark.circle.fill")
                .font(.caption)
                .foregroundColor(.green)
                .offset(x: 12, y: -12)
        }
    }
}
//
//  PhotoContainerView.swift
//  HairStyle
//
//  Created by adam on 25/04/2025.
//

import SwiftUI

// MARK: - PhotoContainerView
struct PhotoContainerView: View {
    @Binding var inputImage: UIImage?
    let editedImage: UIImage?
    let depthMapImage: UIImage?
    @Binding var sliderPosition: CGFloat
    @Binding var showSlider: Bool
    let onAddTap: () -> Void
    let onReplaceTap: () -> Void
    let onSaveTap: () -> Void

    var body: some View {
        ZStack {
            backgroundView
                .ignoresSafeArea()

            PhotoWithRefreshOverlay(
                originalImage: inputImage,
                editedImage: editedImage,
                depthMapImage: depthMapImage,
                sliderPosition: $sliderPosition,
                showSlider: $showSlider,
                onReplaceTap: onReplaceTap,
                onAddTap: onAddTap,
                onSaveTap: onSaveTap
            )
            .frame(maxWidth: .infinity, maxHeight: .infinity)
        }
    }

    @ViewBuilder
    private var backgroundView: some View {
        if let img = inputImage {
            Image(uiImage: img)
                .resizable()
                .scaledToFill()
                .blur(radius: 120)
                .overlay(Color.black.opacity(0.4))
        } else {
            Color.black.opacity(0.6)
        }
    }
}
import SwiftUI

/// The main generation view, with a full-screen loading indicator and faster spinner.
struct GenView: View {
    let section: String
    @StateObject private var viewModel = ImageEditingViewModel()
    @State private var selectedOption: EnhancementOption?

    @State private var inputImage: UIImage?
    @State private var showingImagePicker = false
    @State private var sliderPosition: CGFloat = 0.5
    @State private var showSlider = false
    @State private var showSaveSuccessAlert = false
    @State private var isSpinning = false
    
    @Environment(\.dismiss) private var dismiss

    /// Enhancement options based on selected section
    private var enhancementOptions: [EnhancementOption] {
        switch section {
        case "Chest":    return BodyEnhancementPrompts.breast
        case "Belly":    return BodyEnhancementPrompts.belly
        case "Buttock":  return BodyEnhancementPrompts.buttock
        case "Muscle":   return BodyEnhancementPrompts.muscle
        case "Hair":     return BodyEnhancementPrompts.hair
        case "Nose":     return BodyEnhancementPrompts.nose
        case "Eyes":     return BodyEnhancementPrompts.eyes
        case "Skin":     return BodyEnhancementPrompts.skin
        case "Face":     return BodyEnhancementPrompts.face
        case "Lips":     return BodyEnhancementPrompts.lips
        case "Waist":    return BodyEnhancementPrompts.waist
        case "Legs":      return BodyEnhancementPrompts.leg
        case "jewellery": return BodyEnhancementPrompts.jewellery
        case "Eyewear":  return BodyEnhancementPrompts.eyewear
        default:          return []
        }
    }

    var body: some View {
        ZStack {
            // Content container, blurred & disabled when loading
            ZStack(alignment: .top) {
                GeometryReader { geo in
                    PhotoContainerView(
                        inputImage: $inputImage,
                        editedImage: viewModel.editedImage,
                        depthMapImage: viewModel.depthMapImage,
                        sliderPosition: $sliderPosition,
                        showSlider: $showSlider,
                        onAddTap: pickImage,
                        onReplaceTap: pickImage,
                        onSaveTap: saveImage
                    )
                    .frame(width: geo.size.width, height: geo.size.height)
                    .ignoresSafeArea()

                    if inputImage != nil {
                        TopButtons(
                            onReplace: pickImage,
                            onSave: saveImage,
                            topInset: -20
                        )
                        .padding(.horizontal, 16)
                    }

                    VStack {
                        Spacer()
                        EnhancementPanelView(
                            section: section,
                            options: enhancementOptions,
                            selectedOption: $selectedOption,
                            applyAction: { viewModel.editImage() },
                            cancelAction: { dismiss() }
                        )
                        .frame(width: geo.size.width)
                    }
                }
            }
            .blur(radius: viewModel.isLoading ? 12 : 0)
            .disabled(viewModel.isLoading)
            // Remove horizontal padding when loading to ensure full-width blur
            .padding(.horizontal, viewModel.isLoading ? 0 : 8)

            // Loading overlay with faster spinner
            if viewModel.isLoading {
                Color.black.opacity(0.4)
                    .ignoresSafeArea()

                ProgressView()
                    .progressViewStyle(CircularProgressViewStyle(tint: .white))
                    .scaleEffect(2)
                    //.rotationEffect(.degrees(isSpinning ? 360 : 0))
                    .animation(.linear(duration: 0.6).repeatForever(autoreverses: false), value: isSpinning)
                    .onAppear { isSpinning = true }
                    
            }
        }
        
        .navigationBarBackButtonHidden(true)
        .sheet(isPresented: $showingImagePicker, onDismiss: loadImage) {
            ImagePicker(image: $inputImage)
        }
        .alert("Saved", isPresented: $showSaveSuccessAlert) {
            Button("OK", role: .cancel) {}
        } message: {
            Text("Image saved successfully to your Photos.")
        }
        .onAppear {
            Task {
                do {
                    try await viewModel.loadModel()
                } catch {
                    viewModel.errorMessage = "Failed to load model: \(error.localizedDescription)"
                }
            }
            selectedOption = enhancementOptions.first
            viewModel.prompt = selectedOption?.prompt ?? ""
        }
        .onChange(of: selectedOption) { new in
                    viewModel.prompt = new?.prompt ?? ""
                }
        
    }

    private func pickImage() {
        showingImagePicker = true
    }

    private func loadImage() {
        guard let img = inputImage else { return }
        viewModel.editedImage = img
    }

    private func saveImage() {
        guard let img = viewModel.editedImage else { return }
        UIImageWriteToSavedPhotosAlbum(img, nil, nil, nil)
        showSaveSuccessAlert = true
    }
}

// Top button row extracted
private struct TopButtons: View {
    let onReplace: () -> Void
    let onSave: () -> Void
    let topInset: CGFloat

    var body: some View {
        HStack {
            Button(action: onReplace) {
                Image(systemName: "arrow.triangle.2.circlepath")
                    .font(.system(size: 20, weight: .medium))
                    .foregroundColor(.white)
                    .frame(width: 36, height: 36)
                    .background(Color.black.opacity(0.6))
                    .clipShape(Circle())
            }
            Spacer()
            Button(action: onSave) {
                Image(systemName: "square.and.arrow.down")
                    .font(.system(size: 20, weight: .medium))
                    .foregroundColor(.white)
                    .frame(width: 36, height: 36)
                    .background(Color.black.opacity(0.6))
                    .clipShape(Circle())
            }
        }
        .padding(.top, topInset + 20)
    }
}
import SwiftUI

struct CatalogView: View {
    // MARK: — Data
    private let bodyShapeItems: [(title: String, icon: String)] = [
        ("Chest Curve",   "Chest"),
        ("Flat Abs",      "Belly"),
        ("Buttocks+",     "Buttock"),
        ("Slim Waist",    "Waist"),
        ("Legs",          "Legs"),
        ("Muscles",       "Muscle")
    ]

    private let facialItems: [(title: String, icon: String)] = [
        ("Face",          "Face"),
        ("Eyes",          "Eyes"),
        ("Nose",          "Nose"),
        ("Lips",          "Lips"),
        ("Skin",          "Skin")
    ]

    private let hairAccessoryItems: [(title: String, icon: String)] = [
        ("Hair",          "Hair"),
        ("Jewellery",     "jewellery"),
        ("Eyewear",       "Eyewear")
    ]

    // Three flexible columns
    private let columns = Array(
        repeating: GridItem(.flexible(), spacing: 16),
        count: 3
    )

    var body: some View {
        NavigationView {
            ScrollView {
                VStack(alignment: .leading, spacing: 32) {

                    // MARK: — Header
                    HStack {
                        Text("PicUp ✨")
                            .font(.largeTitle).fontWeight(.bold)
                            .foregroundStyle(
                                LinearGradient(
                                    gradient: Gradient(colors: [Color.pink, Color.orange]),
                                    startPoint: .center,
                                    endPoint: .trailing
                                )
                            )
                        Spacer()
                    }
                    .padding(.horizontal)

                    // MARK: — Body Shape Section
                    SectionGrid(
                        title: "Body Shape",
                        items: bodyShapeItems,
                        columns: columns
                    )

                    // MARK: — Facial Section
                    SectionGrid(
                        title: "Facial",
                        items: facialItems,
                        columns: columns
                    )

                    // MARK: — Hair & Accessories Section
                    SectionGrid(
                        title: "Hair & Accessories",
                        items: hairAccessoryItems,
                        columns: columns
                    )
                }
                .padding(.vertical)
            }
            .background(Color(red: 0.14, green: 0.13, blue: 0.13).edgesIgnoringSafeArea(.all))
            .navigationBarHidden(true)
        }
    }
}

private struct SectionGrid: View {
    let title: String
    let items: [(title: String, icon: String)]
    let columns: [GridItem]

    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text(title)
                .font(.headline)
                .foregroundColor(.white)
                .padding(.horizontal)

            LazyVGrid(columns: columns, alignment: .leading, spacing: 16) {
                ForEach(items, id: \.title) { item in
                    NavigationLink(
                        destination: GenView(section: item.icon)
                    ) {
                        VStack(spacing: 8) {
                            // Circular icon background
                            ZStack {
                                RoundedRectangle(cornerRadius: 18)
                                    .fill(Color.black.opacity(0.6))
                                    .frame(width: 70, height: 70)
                                    .shadow(color: Color.white.opacity(0.2),
                                            radius: 6,
                                            x: 0,
                                            y: 0)

                                Image(item.icon)
                                    .resizable()
                                    .aspectRatio(contentMode: .fit)
                                    .frame(width: 50, height: 50)
                            }
                            
                            Text(item.title)
                                .font(.caption)
                                .multilineTextAlignment(.center)
                                .foregroundColor(.white)
                        }
                        .frame(maxWidth: .infinity)
                    }
                }
            }
            .padding(.horizontal)
        }
    }
}

struct CatalogView_Previews: PreviewProvider {
    static var previews: some View {
        CatalogView()
            .preferredColorScheme(.dark)
    }
}
//
//  SubscriptionManager.swift
//  HairStyle
//
//  Created by adam on 25/03/2025.
//


import StoreKit
import SwiftUI

@MainActor
class SubscriptionManager: ObservableObject {
    /// The subscription products fetched from StoreKit configuration
    @Published var subscriptions: [Product] = []
    
    /// Keep track of purchased product identifiers
    @Published var purchasedIdentifiers = Set<String>()
    
    /// Task to listen for any subscription updates
    private var updates: Task<Void, Never>?
    
    /// Define your product IDs exactly as they appear in your StoreKit config
    private let productIDs = [
        "wbweek",  // replace with your actual weekly ID
        "wbyear"   // replace with your actual annual ID
    ]
    
    init() {
        // Start listening for transaction updates
        updates = listenForTransactions()
        
        // Immediately fetch products and update purchased info
        Task {
            await requestProducts()
            await updatePurchasedIdentifiers()
        }
    }
    
    /// Request products from StoreKit
    func requestProducts() async {
        do {
            let storeProducts = try await Product.products(for: productIDs)
            subscriptions = storeProducts
        } catch {
            print("Failed to request products: \(error)")
        }
    }
    
    /// Listen for any transaction updates (e.g., renewals, cancellations)
    private func listenForTransactions() -> Task<Void, Never> {
        Task.detached { [weak self] in
            guard let self = self else { return }
            for await result in Transaction.updates {
                do {
                    let transaction = try await self.checkVerified(result)
                    // If transaction is verified, apply changes
                    await self.updatePurchasedIdentifiers()
                    await transaction.finish()
                } catch {
                    print("Transaction failed verification")
                }
            }
        }
    }
    
    /// Update purchased identifiers from current entitlements
    private func updatePurchasedIdentifiers() async {
        purchasedIdentifiers.removeAll()
        for await verificationResult in Transaction.currentEntitlements {
            do {
                let transaction = try checkVerified(verificationResult)
                purchasedIdentifiers.insert(transaction.productID)
            } catch {
                // Not verified
            }
        }
    }
    
    /// Purchase a specific product
    func purchase(_ product: Product) async throws -> StoreKit.Transaction? {
        let result = try await product.purchase()
        switch result {
        case .success(let verification):
            let transaction = try checkVerified(verification)
            await transaction.finish()
            await updatePurchasedIdentifiers()
            return transaction
        case .userCancelled, .pending:
            return nil
        @unknown default:
            return nil
        }
    }
    
    /// Verify the transaction with StoreKit
    private func checkVerified<T>(_ result: VerificationResult<T>) throws -> T {
        switch result {
        case .unverified:
            throw StoreError.failedVerification
        case .verified(let safe):
            return safe
        }
    }
    
    enum StoreError: Error {
        case failedVerification
    }
}
import SwiftUI
import Vision
import CoreML
import CoreImage
import UIKit
import os


// MARK: - ImageEditingViewModel
class ImageEditingViewModel: ObservableObject {
    // MARK: - Published Properties
    @Published var prompt: String = ""
    @Published var editedImage: UIImage? = nil
    @Published var textResult: String = ""
    @Published var isLoading: Bool = false
    @Published var errorMessage: String = ""
    @Published var showPremiumAlert: Bool = false
    @Published var depthMapImage: UIImage? = nil  // Holds the generated depth map image
    
    // Depth model property
    var model: DepthAnythingV2SmallF16?
    
    // Proxy endpoint for your Gemini API key.
    let apiURL = URL(string: "https://gemini-proxy-flame.vercel.app/api/gemini")!
    
    // Define the target size expected by the model.
    private let targetSize = CGSize(width: 518, height: 392)
    
    // Shared CIContext instance.
    private let ciContext = CIContext()
    
    
    // New property: Public sharing checkbox state (default true)
    @Published var isPublicSharing: Bool = true
    
    // MARK: - Depth Model Loading & Depth Map Generation
    
    /// Loads your depth removal model.
    func loadModel() async throws {
        let config = MLModelConfiguration()
        config.computeUnits = .cpuOnly
        model = try DepthAnythingV2SmallF16(configuration: config)
    }
    
    
    func generateDepthMap(for image: UIImage) async {
        // Ensure the model is loaded.
        guard let depthModel = model else {
            await MainActor.run { self.errorMessage = "Model not loaded." }
            return
        }
        
        // Create a resized pixel buffer (518 x 392) using the helper extension.
        guard let resizedBuffer = image.resizedPixelBuffer(width: Int(targetSize.width), height: Int(targetSize.height)) else {
            await MainActor.run { self.errorMessage = "Failed to create resized pixel buffer." }
            return
        }
        
        // Debug: confirm the pixel buffer size.
        let w = CVPixelBufferGetWidth(resizedBuffer)
        let h = CVPixelBufferGetHeight(resizedBuffer)
        print("Pixel buffer is \(w)x\(h)")  // Should be 518x392
        
        do {
            // Run model inference synchronously.
            let prediction = try depthModel.prediction(image: resizedBuffer)
            let depthBuffer = prediction.depth
            let depthCI = CIImage(cvPixelBuffer: depthBuffer)
            
            if let cgImage = ciContext.createCGImage(depthCI, from: depthCI.extent) {
                let finalUIImage = UIImage(cgImage: cgImage)
                await MainActor.run {
                    self.depthMapImage = finalUIImage
                    print("Depth map generation successful")
                }
            }
        } catch {
            await MainActor.run {
                self.errorMessage = "Depth model error: \(error.localizedDescription)"
            }
        }
    }

    
    
    func editImage() {
        guard let image = editedImage,
              let imageData = image.jpegData(compressionQuality: 0.8)?.base64EncodedString() else {
            DispatchQueue.main.async {
                self.isLoading = false
                self.errorMessage = "No valid image selected"
            }
            return
        }
        
        isLoading = true
        errorMessage = ""
        textResult = ""
        
        let payload: [String: Any] = [
            "prompt": prompt,
            "image": imageData
        ]
        
        guard let jsonData = try? JSONSerialization.data(withJSONObject: payload) else {
            DispatchQueue.main.async {
                self.isLoading = false
                self.errorMessage = "Failed to serialize request"
            }
            return
        }
        
        var request = URLRequest(url: apiURL)
        request.httpMethod = "POST"
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")
        request.httpBody = jsonData
        
        URLSession.shared.dataTask(with: request) { [weak self] data, response, error in
            guard let self = self else { return }
            
            DispatchQueue.main.async { self.isLoading = false }
            
            if let error = error {
                DispatchQueue.main.async {
                    self.errorMessage = "Network error: \(error.localizedDescription)"
                }
                return
            }
            
            guard let data = data else {
                DispatchQueue.main.async {
                    self.errorMessage = "No data received from server"
                }
                return
            }
            
            do {
                if let jsonResponse = try JSONSerialization.jsonObject(with: data) as? [String: Any] {
                    // (Handle API error responses)
                    if let errorDict = jsonResponse["error"] as? [String: Any] {
                        let errorMessage = (errorDict["message"] as? String) ?? "Unknown error"
                        DispatchQueue.main.async {
                            self.errorMessage = "API Error: \(errorMessage)"
                        }
                        return
                    }
                    
                    // Process text and inline data responses
                    if let candidates = jsonResponse["candidates"] as? [[String: Any]],
                       let candidate = candidates.first,
                       let content = candidate["content"] as? [String: Any],
                       let parts = content["parts"] as? [[String: Any]] {
                        
                        for part in parts {
                            if let text = part["text"] as? String {
                                DispatchQueue.main.async {
                                    self.textResult += text
                                }
                            }
                            
                            if let inlineData = part["inlineData"] as? [String: Any],
                               let dataString = inlineData["data"] as? String,
                               let imageData = Data(base64Encoded: dataString),
                               let image = UIImage(data: imageData) {
                                
                                DispatchQueue.main.async {
                                    self.editedImage = image
                                }
                                
                                // Only share publicly if the toggle is on.
                             /*   if self.isPublicSharing {
                                    CloudinaryManager.upload(image: image) { secureUrl in
                                        if let url = secureUrl {
                                            print("Image uploaded to Cloudinary: \(url)")
                                            // Optionally: save the URL for your feed if needed.
                                        }
                                    }
                                }*/
                            }
                        }
                    } else {
                        let responseString = String(data: data, encoding: .utf8) ?? "Unable to parse response"
                        DispatchQueue.main.async {
                            self.textResult = "Response: \(responseString)"
                        }
                    }
                }
            } catch {
                DispatchQueue.main.async {
                    self.errorMessage = "Failed to parse response: \(error.localizedDescription)"
                    self.textResult = String(data: data, encoding: .utf8) ?? "Unable to display response"
                }
            }
        }.resume()
    }

    
    
    
}
//
//  CloudinaryManager.swift
//  HairStyle
//
//  Created by adam on 25/03/2025.
//


import Cloudinary
import UIKit

struct CloudinaryManager {
    static let shared: CLDCloudinary = {
        let config = CLDConfiguration(
            cloudName: "dao9lckfd"
        )
        return CLDCloudinary(configuration: config)
    }()
    
    static func upload(image: UIImage, completion: @escaping (String?) -> Void) {
        guard let imageData = image.jpegData(compressionQuality: 0.8) else {
            completion(nil)
            return
        }
        let params = CLDUploadRequestParams().setFolder("photoGenerations").setTags(["myGen"])  // Add your chosen tag here

        CloudinaryManager.shared.createUploader().upload(data: imageData,
                                                         uploadPreset: "HairStyle01",
                                                         params: params) { result, error in
            if let error = error {
                print("Cloudinary upload error: \(error)")
                completion(nil)
            } else if let result = result {
                // Return the secure URL string for later use
                completion(result.secureUrl)
            }
        }
    }
}
import SwiftUI

struct CloudinaryImage: Decodable, Identifiable {
    let public_id: String
    let version: Int
    let format: String
    
    var id: String { public_id }
    
    // Construct the URL for the original uploaded image
    var imageUrl: String {
        "https://res.cloudinary.com/dao9lckfd/image/upload/v\(version)/\(public_id).\(format)"
    }
}

struct ImageListResponse: Decodable {
    let resources: [CloudinaryImage]
}

class FeedViewModel: ObservableObject {
    @Published var images: [CloudinaryImage] = []
    
    func loadImages() {
        // Replace "YOUR_CLOUD_NAME" and "myGenerations" with your actual values:
        guard let url = URL(string: "https://res.cloudinary.com/dao9lckfd/image/list/myGen.json") else { return }
        
        URLSession.shared.dataTask(with: url) { data, _, error in
            if let error = error {
                print("Error fetching feed images: \(error)")
                return
            }
            if let data = data {
                do {
                    let listResponse = try JSONDecoder().decode(ImageListResponse.self, from: data)
                    DispatchQueue.main.async {
                        self.images = listResponse.resources
                    }
                } catch {
                    print("Failed to decode Cloudinary image list: \(error)")
                }
            }
        }.resume()
    }
}
//
//  FeedView.swift
//  HairStyle
//
//  Created by adam on 25/03/2025.
//


import SwiftUI

struct FeedView: View {
    @StateObject private var viewModel = FeedViewModel()
    
    let columns = [
        GridItem(.flexible()),
        GridItem(.flexible())
    ]
    
    var body: some View {
        NavigationView {
            ScrollView {
                LazyVGrid(columns: columns, spacing: 16) {
                    ForEach(viewModel.images) { image in
                        AsyncImage(url: URL(string: image.imageUrl)) { phase in
                            switch phase {
                            case .empty:
                                ProgressView()
                                    .frame(width: 150, height: 150)
                            case .success(let img):
                                img
                                    .resizable()
                                    .aspectRatio(contentMode: .fill)
                                    .frame(width: 150, height: 150)
                                    .clipped()
                            case .failure:
                                Image(systemName: "photo")
                                    .resizable()
                                    .aspectRatio(contentMode: .fill)
                                    .frame(width: 150, height: 150)
                                    .clipped()
                            @unknown default:
                                EmptyView()
                            }
                        }
                    }
                }
                .padding()
            }
            .navigationTitle("Feed")
            .onAppear {
                viewModel.loadImages()
            }
        }
    }
}
import Foundation

struct HairItem: Identifiable {
    let id = UUID()
    let name: String
    let image: String?
    let prompt: String
}

struct BeautyDataPrompts {
    static let categories = [
        "Hairstyle",
        "Hair Color",
        "Wardrobe",
        "Expressions",
        "Filter Fusion",
        "Background Changer",
        "Portrait Perfection",
        "Motion Effects",
        "Collage Crafter",
        "Text & Hashtag Stylizer",
        "Professions",
        "Animals",
        "Places",
        "Adventures"
    ]
    
    static let items: [String: [HairItem]] = [
        "Hairstyle": [
            HairItem(name: "Long Straight", image: nil, prompt: "Respectfully enhance chest curvature"),
            HairItem(name: "Bob Cut", image: nil, prompt: "Change to bob cut hairstyle"),
            HairItem(name: "Wavy", image: nil, prompt: "Make the hair wavy and voluminous"),
            HairItem(name: "Hippie Perm", image: nil, prompt: "Transform to hippie perm style"),
            HairItem(name: "Full Bangs", image: nil, prompt: "Add full bangs to the hairstyle"),
            HairItem(name: "Curly", image: nil, prompt: "Transform hair into loose, natural curls"),
            HairItem(name: "Pixie Cut", image: nil, prompt: "Switch to a trendy pixie cut hairstyle"),
            // New items
            HairItem(name: "Messy Bun", image: nil, prompt: "Do a messy bun"),
            HairItem(name: "Braided", image: nil, prompt: "Try a simple braid"),
            HairItem(name: "Ponytail", image: nil, prompt: "Switch to a ponytail"),
            HairItem(name: "Side Sweep", image: nil, prompt: "Style with side sweep"),
            HairItem(name: "Top Knot", image: nil, prompt: "Rock a top knot"),
            HairItem(name: "Layered", image: nil, prompt: "Add layered cuts"),
            HairItem(name: "Asymmetrical", image: nil, prompt: "Go for an asymmetrical cut"),
            HairItem(name: "Fishtail Braid", image: nil, prompt: "Try a fishtail braid"),
            HairItem(name: "Undercut", image: nil, prompt: "Add a trendy undercut"),
            HairItem(name: "Spiral Curls", image: nil, prompt: "Rock spiral curls")
        ],
        "Hair Color": [
            HairItem(name: "Blonde", image: nil, prompt: "Change hair color to blonde"),
            HairItem(name: "Brunette", image: nil, prompt: "Change hair color to brunette"),
            HairItem(name: "Red", image: nil, prompt: "Change hair color to vibrant red"),
            HairItem(name: "Black", image: nil, prompt: "Change hair color to black"),
            HairItem(name: "Silver", image: nil, prompt: "Change hair color to gray/silver"),
            HairItem(name: "Pastel Pink", image: nil, prompt: "Change hair color to soft pastel pink"),
            HairItem(name: "Electric Blue", image: nil, prompt: "Change hair color to vibrant electric blue"),
            // New items
            HairItem(name: "Rose Gold", image: nil, prompt: "Change hair color togold"),
            HairItem(name: "Platinum", image: nil, prompt: "Change hair color to platinum blonde"),
            HairItem(name: "Auburn", image: nil, prompt: "Change hair color to auburn shades"),
            HairItem(name: "Copper", image: nil, prompt: "Change hair color to copper tones"),
            HairItem(name: "Jet Black", image: nil, prompt: "Change hair color to jet black"),
            HairItem(name: "Lilac", image: nil, prompt: "Change hair color to lilac"),
            HairItem(name: "Mint", image: nil, prompt: "Change hair color to mint tones"),
            HairItem(name: "Neon Green", image: nil, prompt: "Change hair color to Bright neon green"),
            HairItem(name: "Sunset Ombre", image: nil, prompt: "Change hair color to sunset ombre"),
            HairItem(name: "Icy Blue", image: nil, prompt: "Change hair color to icy blue hues")
        ],
        "Wardrobe": [
            HairItem(name: "Casual Chic", image: nil, prompt: "Transform into a casual chic outfit in one tap"),
            HairItem(name: "Formal Elegance", image: nil, prompt: "Switch to an elegant formal ensemble effortlessly"),
            HairItem(name: "Sporty", image: nil, prompt: "Adopt a sporty and dynamic look"),
            HairItem(name: "Vintage", image: nil, prompt: "Embrace a timeless vintage wardrobe style"),
            HairItem(name: "Urban Street", image: nil, prompt: "Show off an edgy urban street style"),
            HairItem(name: "Bohemian", image: nil, prompt: "Adopt a free-spirited bohemian wardrobe style"),
            HairItem(name: "Business Casual", image: nil, prompt: "Switch to a sharp business casual outfit"),
            // New items
            HairItem(name: "Edgy Rock", image: nil, prompt: "Rock edgy vibes"),
            HairItem(name: "Summer Vibes", image: nil, prompt: "Wear summer chic"),
            HairItem(name: "Retro", image: nil, prompt: "Go retro style"),
            HairItem(name: "Glam Night", image: nil, prompt: "Glam up for night"),
            HairItem(name: "Cozy Sweater", image: nil, prompt: "Sport a cozy sweater"),
            HairItem(name: "Streetwear", image: nil, prompt: "Try cool streetwear"),
            HairItem(name: "Festival", image: nil, prompt: "Festival-ready look"),
            HairItem(name: "Minimalist", image: nil, prompt: "Keep it minimalist"),
            HairItem(name: "Punk", image: nil, prompt: "Adopt a punk look"),
            HairItem(name: "Casual Denim", image: nil, prompt: "Go with denim style")
        ],
        "Expressions": [
            HairItem(name: "Happy Smile", image: nil, prompt: "Apply a cheerful, smiling expression"),
            HairItem(name: "Serene", image: nil, prompt: "Adopt a calm and serene facial expression"),
            HairItem(name: "Playful", image: nil, prompt: "Show a playful and engaging expression"),
            HairItem(name: "Confident", image: nil, prompt: "Convey a confident and assertive look"),
            HairItem(name: "Mysterious", image: nil, prompt: "Add a touch of mystery to your expression"),
            HairItem(name: "Surprised", image: nil, prompt: "Convey a surprised and animated expression"),
            HairItem(name: "Flirty", image: nil, prompt: "Apply a subtle flirty look to your face"),
            // New items
            HairItem(name: "Sassy", image: nil, prompt: "Show a sassy smirk"),
            HairItem(name: "Cool", image: nil, prompt: "Stay cool and calm"),
            HairItem(name: "Dreamy", image: nil, prompt: "Look dreamy and soft"),
            HairItem(name: "Cheeky", image: nil, prompt: "Give a cheeky grin"),
            HairItem(name: "Bold", image: nil, prompt: "Exude bold energy"),
            HairItem(name: "Gleeful", image: nil, prompt: "Display gleeful joy"),
            HairItem(name: "Relaxed", image: nil, prompt: "Keep a relaxed look"),
            HairItem(name: "Quirky", image: nil, prompt: "Show quirky vibes"),
            HairItem(name: "Energetic", image: nil, prompt: "Radiate energetic vibes"),
            HairItem(name: "Smirking", image: nil, prompt: "Flash a playful smirk")
        ],
        "Filter Fusion": [
            HairItem(name: "Artistic Blend", image: nil, prompt: "Blend multiple artistic filters for a unique look"),
            HairItem(name: "Vintage Vibes", image: nil, prompt: "Mix retro and modern filters for vintage vibes"),
            HairItem(name: "Cinematic Look", image: nil, prompt: "Blend cinematic filters for drama"),
            HairItem(name: "Dreamy Glow", image: nil, prompt: "Combine soft filters for a dreamy glow"),
            HairItem(name: "Bold Contrast", image: nil, prompt: "Merge high contrast for impact"),
            HairItem(name: "Color Pop", image: nil, prompt: "Fuse vibrant filters for pop colors"),
            HairItem(name: "Monochrome Magic", image: nil, prompt: "Blend B&W with a twist"),
            // New items
            HairItem(name: "Glitter Spark", image: nil, prompt: "Add glitter spark filters"),
            HairItem(name: "Neon Burst", image: nil, prompt: "Fuse neon burst effects"),
            HairItem(name: "Soft Haze", image: nil, prompt: "Apply a soft haze filter"),
            HairItem(name: "Retro Pop", image: nil, prompt: "Use retro pop effects"),
            HairItem(name: "Light Leak", image: nil, prompt: "Blend in light leak"),
            HairItem(name: "Funky Frame", image: nil, prompt: "Try a funky frame filter"),
            HairItem(name: "Pastel Dream", image: nil, prompt: "Use pastel dream vibes"),
            HairItem(name: "Shadow Play", image: nil, prompt: "Mix in shadow play"),
            HairItem(name: "Vivid Boost", image: nil, prompt: "Boost with vivid filters"),
            HairItem(name: "Crystal Clear", image: nil, prompt: "Opt for a crystal clear filter")
        ],
        "Background Changer": [
            HairItem(name: "Dynamic Backdrop", image: nil, prompt: "Swap dull backdrops for dynamic scenes"),
            HairItem(name: "Urban Skyline", image: nil, prompt: "Replace with a modern urban skyline"),
            HairItem(name: "Nature Escape", image: nil, prompt: "Switch to a serene natural landscape"),
            HairItem(name: "Abstract Art", image: nil, prompt: "Change to an abstract design"),
            HairItem(name: "Beach Paradise", image: nil, prompt: "Transform into a beach scene"),
            HairItem(name: "Cosmic Space", image: nil, prompt: "Set a cosmic background"),
            HairItem(name: "Studio Setting", image: nil, prompt: "Use a minimalist studio background"),
            // New items
            HairItem(name: "City Lights", image: nil, prompt: "Swap to city lights"),
            HairItem(name: "Countryside", image: nil, prompt: "Switch to countryside view"),
            HairItem(name: "Night Sky", image: nil, prompt: "Set a starry night sky"),
            HairItem(name: "Rainbow", image: nil, prompt: "Add a rainbow background"),
            HairItem(name: "Modern Loft", image: nil, prompt: "Go for a modern loft"),
            HairItem(name: "Pastel Wall", image: nil, prompt: "Switch to a pastel wall"),
            HairItem(name: "Neon City", image: nil, prompt: "Swap to neon city"),
            HairItem(name: "Zen Garden", image: nil, prompt: "Choose a zen garden"),
            HairItem(name: "Seaside", image: nil, prompt: "Use a seaside view"),
            HairItem(name: "Graffiti", image: nil, prompt: "Switch to graffiti art")
        ],
        "Portrait Perfection": [
            HairItem(name: "Selfie Enhancer", image: nil, prompt: "Enhance selfies with perfect lighting"),
            HairItem(name: "Flawless Skin", image: nil, prompt: "Smooth and perfect your skin"),
            HairItem(name: "Eye Catcher", image: nil, prompt: "Make your eyes pop"),
            HairItem(name: "Lip Pop", image: nil, prompt: "Boost lip color instantly"),
            HairItem(name: "Face Sculpt", image: nil, prompt: "Refine your facial contours"),
            HairItem(name: "Brighten Up", image: nil, prompt: "Brighten and add clarity"),
            HairItem(name: "Natural Radiance", image: nil, prompt: "Enhance natural features"),
            // New items
            HairItem(name: "Clear Complexion", image: nil, prompt: "Clear up your skin"),
            HairItem(name: "Smooth Contours", image: nil, prompt: "Smooth out your contours"),
            HairItem(name: "Eye Sparkle", image: nil, prompt: "Add sparkle to your eyes"),
            HairItem(name: "Lip Gloss", image: nil, prompt: "Shine with lip gloss"),
            HairItem(name: "Glow Up", image: nil, prompt: "Get that glow up"),
            HairItem(name: "Fresh Look", image: nil, prompt: "Enhance your fresh look"),
            HairItem(name: "Radiant Aura", image: nil, prompt: "Boost your radiant aura"),
            HairItem(name: "Flawless Filter", image: nil, prompt: "Apply a flawless filter"),
            HairItem(name: "Vivid Eyes", image: nil, prompt: "Enhance vivid eyes"),
            HairItem(name: "Perfect Pout", image: nil, prompt: "Define your pout")
        ],
        "Motion Effects": [
            HairItem(name: "Dynamic Motion", image: nil, prompt: "Add dynamic motion effects"),
            HairItem(name: "Subtle Blur", image: nil, prompt: "Apply a soft motion blur"),
            HairItem(name: "Flowing Light", image: nil, prompt: "Add flowing light effects"),
            HairItem(name: "Speed Trail", image: nil, prompt: "Create motion trails"),
            HairItem(name: "Ripple Effect", image: nil, prompt: "Simulate a ripple effect"),
            HairItem(name: "Vivid Sparks", image: nil, prompt: "Overlay vivid sparks"),
            HairItem(name: "Glide Transition", image: nil, prompt: "Smoothly blend motion elements"),
            // New items
            HairItem(name: "Quick Zoom", image: nil, prompt: "Add a quick zoom"),
            HairItem(name: "Time Warp", image: nil, prompt: "Try a time warp effect"),
            HairItem(name: "Slide Shift", image: nil, prompt: "Use a slide shift"),
            HairItem(name: "Bouncy Beat", image: nil, prompt: "Sync with a bouncy beat"),
            HairItem(name: "Flash Flicker", image: nil, prompt: "Apply a flash flicker"),
            HairItem(name: "Motion Burst", image: nil, prompt: "Create a motion burst"),
            HairItem(name: "Wave Motion", image: nil, prompt: "Use wave motion"),
            HairItem(name: "Strobe Light", image: nil, prompt: "Add strobe light flash"),
            HairItem(name: "Glitch Pop", image: nil, prompt: "Try a glitch pop effect"),
            HairItem(name: "Vibe Spin", image: nil, prompt: "Spin with vibe motion")
        ],
        "Collage Crafter": [
            HairItem(name: "Stylish Collage", image: nil, prompt: "Arrange photos into a stylish collage"),
            HairItem(name: "Grid Layout", image: nil, prompt: "Organize photos in a grid"),
            HairItem(name: "Freestyle Arrangement", image: nil, prompt: "Arrange photos creatively"),
            HairItem(name: "Story Montage", image: nil, prompt: "Compile photos into a montage"),
            HairItem(name: "Thematic Collage", image: nil, prompt: "Create a themed collage"),
            HairItem(name: "Artistic Mosaic", image: nil, prompt: "Craft an artistic mosaic"),
            HairItem(name: "Dynamic Layers", image: nil, prompt: "Layer photos dynamically"),
            // New items
            HairItem(name: "Photo Burst", image: nil, prompt: "Create a photo burst"),
            HairItem(name: "Snap Mix", image: nil, prompt: "Mix snaps creatively"),
            HairItem(name: "Pic Grid", image: nil, prompt: "Arrange pics in a grid"),
            HairItem(name: "Frame Play", image: nil, prompt: "Play with frame styles"),
            HairItem(name: "Quick Collage", image: nil, prompt: "Craft a quick collage"),
            HairItem(name: "Layout Love", image: nil, prompt: "Love your layout"),
            HairItem(name: "Instant Montage", image: nil, prompt: "Make an instant montage"),
            HairItem(name: "Creative Cluster", image: nil, prompt: "Cluster photos stylishly"),
            HairItem(name: "Vibe Collage", image: nil, prompt: "Blend your vibe collage"),
            HairItem(name: "Modern Patchwork", image: nil, prompt: "Design a modern patchwork")
        ],
        "Text & Hashtag Stylizer": [
            HairItem(name: "Dynamic Text", image: nil, prompt: "Generate dynamic text overlays"),
            HairItem(name: "Bold Caption", image: nil, prompt: "Create bold text captions"),
            HairItem(name: "Elegant Script", image: nil, prompt: "Apply elegant script fonts"),
            HairItem(name: "Hashtag Pop", image: nil, prompt: "Design catchy hashtag overlays"),
            HairItem(name: "Animated Text", image: nil, prompt: "Animate your text"),
            HairItem(name: "Shadow Effect", image: nil, prompt: "Add a shadow to text"),
            HairItem(name: "Color Gradient", image: nil, prompt: "Apply a color gradient to text"),
            // New items
            HairItem(name: "Fresh Fonts", image: nil, prompt: "Switch up with fresh fonts"),
            HairItem(name: "Quick Tag", image: nil, prompt: "Add a quick tag"),
            HairItem(name: "Text Swipe", image: nil, prompt: "Swipe in cool text"),
            HairItem(name: "Hashtag Wave", image: nil, prompt: "Ride the hashtag wave"),
            HairItem(name: "Font Flash", image: nil, prompt: "Flash a bold font"),
            HairItem(name: "Simple Script", image: nil, prompt: "Use simple script"),
            HairItem(name: "Text Punch", image: nil, prompt: "Give text a punch"),
            HairItem(name: "Hashtag Hype", image: nil, prompt: "Boost hashtag hype"),
            HairItem(name: "Smooth Overlay", image: nil, prompt: "Overlay text smoothly"),
            HairItem(name: "Modern Tag", image: nil, prompt: "Style with modern tag")
        ],
        "Professions": [
            HairItem(name: "Doctor", image: nil, prompt: "Adopt a doctor's look"),
            HairItem(name: "Chef", image: nil, prompt: "Transform into a chef"),
            HairItem(name: "Artist", image: nil, prompt: "Embrace an artist vibe"),
            HairItem(name: "Business Executive", image: nil, prompt: "Sport a business suit"),
            HairItem(name: "Engineer", image: nil, prompt: "Rock an engineer style"),
            HairItem(name: "Lawyer", image: nil, prompt: "Show a lawyer's look"),
            HairItem(name: "Military", image: nil, prompt: "Exude military discipline"),
            // New items
            HairItem(name: "Teacher", image: nil, prompt: "Show a teacher vibe"),
            HairItem(name: "Musician", image: nil, prompt: "Rock a musician look"),
            HairItem(name: "Pilot", image: nil, prompt: "Adopt a pilot style"),
            HairItem(name: "Nurse", image: nil, prompt: "Wear a nurse uniform"),
            HairItem(name: "Writer", image: nil, prompt: "Get a writer's touch"),
            HairItem(name: "Designer", image: nil, prompt: "Style as a designer"),
            HairItem(name: "Architect", image: nil, prompt: "Show an architect look"),
            HairItem(name: "Photographer", image: nil, prompt: "Snap a photographer vibe"),
            HairItem(name: "Dancer", image: nil, prompt: "Exude dancer flair"),
            HairItem(name: "Entrepreneur", image: nil, prompt: "Show entrepreneur energy")
        ],
        "Animals": [
            HairItem(name: "Cat Elegance", image: nil, prompt: "Add a sleek cat"),
            HairItem(name: "Dog Charm", image: nil, prompt: "Add a playful dog"),
            HairItem(name: "Lion's Mane", image: nil, prompt: "Add a bold lion"),
            HairItem(name: "Fox Features", image: nil, prompt: "Add a clever fox"),
            HairItem(name: "Rabbit Softness", image: nil, prompt: "Add a gentle rabbit"),
            HairItem(name: "Panda Cool", image: nil, prompt: "Add a relaxed panda"),
            HairItem(name: "Eagle Vision", image: nil, prompt: "Add a fierce eagle"),
            // New items
            HairItem(name: "Butterfly", image: nil, prompt: "Add a cute butterfly"),
            HairItem(name: "Penguin", image: nil, prompt: "Use a playful penguin"),
            HairItem(name: "Koala", image: nil, prompt: "Bring in a chill koala"),
            HairItem(name: "Horse", image: nil, prompt: "Show a noble horse"),
            HairItem(name: "Swan", image: nil, prompt: "Add a graceful swan"),
            HairItem(name: "Dolphin", image: nil, prompt: "Splash in a dolphin"),
            HairItem(name: "Bear", image: nil, prompt: "Bring a cuddly bear"),
            HairItem(name: "Parrot", image: nil, prompt: "Show a colorful parrot"),
            HairItem(name: "Turtle", image: nil, prompt: "Add a chill turtle"),
            HairItem(name: "Owl", image: nil, prompt: "Include a wise owl")
        ],
        "Places": [
            HairItem(name: "Parisian Street", image: nil, prompt: "Set a chic Paris street"),
            HairItem(name: "Tropical Paradise", image: nil, prompt: "Switch to a tropical vibe"),
            HairItem(name: "Futuristic City", image: nil, prompt: "Adopt a futuristic cityscape"),
            HairItem(name: "Mountain Retreat", image: nil, prompt: "Change to a mountain retreat"),
            HairItem(name: "Desert Oasis", image: nil, prompt: "Transform to a desert oasis"),
            HairItem(name: "Historic Castle", image: nil, prompt: "Set against a historic castle"),
            HairItem(name: "Urban Graffiti", image: nil, prompt: "Embrace urban graffiti art"),
            // New items
            HairItem(name: "Beachfront", image: nil, prompt: "Set a beachfront scene"),
            HairItem(name: "Snowy Village", image: nil, prompt: "Switch to a snowy village"),
            HairItem(name: "Countryside Farm", image: nil, prompt: "Go for a farm vibe"),
            HairItem(name: "Lakeside", image: nil, prompt: "Choose a lakeside view"),
            HairItem(name: "City Park", image: nil, prompt: "Opt for a lively park"),
            HairItem(name: "Rooftop", image: nil, prompt: "Set a rooftop vibe"),
            HairItem(name: "Garden", image: nil, prompt: "Switch to a blooming garden"),
            HairItem(name: "Harbor", image: nil, prompt: "Set a harbor backdrop"),
            HairItem(name: "Festival Grounds", image: nil, prompt: "Set festive grounds"),
            HairItem(name: "Canyon", image: nil, prompt: "Show a majestic canyon")
        ],
        "Adventures": [
            HairItem(name: "Sky Jumping", image: nil, prompt: "Set a sky jumping thrill"),
            HairItem(name: "Monk's Trail Hike", image: nil, prompt: "Try a monk's trail hike"),
            HairItem(name: "Mountain Climb", image: nil, prompt: "Climb a rugged mountain"),
            HairItem(name: "Jungle Safari", image: nil, prompt: "Embrace a jungle safari"),
            HairItem(name: "Desert Rally", image: nil, prompt: "Hit a desert rally"),
            HairItem(name: "Underwater Expedition", image: nil, prompt: "Dive into underwater fun"),
            HairItem(name: "Snowboarding", image: nil, prompt: "Enjoy snowboarding thrills"),
            // New items
            HairItem(name: "Surfing", image: nil, prompt: "Catch a surfing wave"),
            HairItem(name: "Road Trip", image: nil, prompt: "Hit the road trip"),
            HairItem(name: "Camping", image: nil, prompt: "Go camping outdoors"),
            HairItem(name: "Bungee Jump", image: nil, prompt: "Try bungee jumping"),
            HairItem(name: "Scuba Dive", image: nil, prompt: "Dive into adventure"),
            HairItem(name: "Hot Air Balloon", image: nil, prompt: "Fly in a hot air balloon"),
            HairItem(name: "Zip Lining", image: nil, prompt: "Experience zip lining"),
            HairItem(name: "Kayaking", image: nil, prompt: "Paddle with kayaking vibes"),
            HairItem(name: "Hiking Trail", image: nil, prompt: "Hit the hiking trail"),
            HairItem(name: "Skiing", image: nil, prompt: "Enjoy a skiing adventure")
        ]
    ]
}
//
//  EnhancementOption.swift
//  HairStyle
//
//  Created by adam on 25/04/2025.
//


//
//  BodyEnhancementPrompts.swift
//  HairStyle
//
//  Created by assistant on 25/04/2025.
//

import Foundation

/// A single enhancement option for a given body area.
struct EnhancementOption: Identifiable, Equatable {
    let id: String             // unique key
    let title: String          // display name
    let subtitle: String?      // optional secondary label (e.g., "Limited-time free")
    let prompt: String         // AI prompt to send
    let isFree: Bool           // whether this option is free
}

enum BodyEnhancementPrompts {
    static let breast: [EnhancementOption] = [
        EnhancementOption(
            id: "round",
            title: "Round",
            subtitle: nil,
            prompt: "Respectfully enhance chest curvature",
            isFree: true
        ),
        EnhancementOption(
            id: "heart_shaped",
            title: "Heart-shaped",
            subtitle: "Limited-time free",
            prompt: "Enhance chest into a heart-shaped bust",
            isFree: true
        ),
        EnhancementOption(
            id: "superlift",
            title: "Superlift",
            subtitle: nil,
            prompt: "Apply superlift enhancement to chest",
            isFree: false
        ),
        EnhancementOption(
            id: "pointy",
            title: "Pointy Nipple",
            subtitle: nil,
            prompt: "Respectfully feature pointy nipple visibly forming under a realistic fabric ",
            isFree: false
        )
    ]

    static let belly: [EnhancementOption] = [
        EnhancementOption(
            id: "flat_abs",
            title: "Flat Abs",
            subtitle: nil,
            prompt: "Respectfully slim and flatten the belly and waist",
            isFree: true
        ),
        EnhancementOption(
            id: "hourglass",
            title: "Hourglass",
            subtitle: nil,
            prompt: "Respectfully enhance the waist-to-hip curve",
            isFree: false
        ),
        EnhancementOption(
            id: "defined_abs",
            title: "Defined Abs",
            subtitle: nil,
            prompt: "Respectfully Enhance the abdominal abs",
            isFree: false
        ),
        EnhancementOption(
            id: "sculpted_core",
            title: "Sculpted Core",
            subtitle: nil,
            prompt: "Respectfully Sculpt and refine the core muscles for a balanced",
            isFree: true
        ),
        EnhancementOption(
            id: "chiseled_midsection",
            title: "Chiseled Midsection",
            subtitle: nil,
            prompt: "Respectfully enhance the lines of the midsection abs",
            isFree: false
        )
    ]

    static let buttock: [EnhancementOption] = [
        EnhancementOption(
            id: "lift",
            title: "Lift",
            subtitle: nil,
            prompt: "Lift and sculpt the buttocks for a firmer look",
            isFree: true
        ),
        EnhancementOption(
            id: "round",
            title: "Round",
            subtitle: nil,
            prompt: "Enhance roundness for a curvier silhouette",
            isFree: false
        ),
        EnhancementOption(
            id: "heart_shaped",
            title: "Heart-shaped",
            subtitle: "Limited-time free",
            prompt: "Respectfully reshape glutes into a heart-shaped form",
            isFree: true
        ),
        EnhancementOption(
            id: "superlift",
            title: "Superlift",
            subtitle: nil,
            prompt: "Apply superlift enhancement to buttocks for maximum elevation",
            isFree: false
        ),
        EnhancementOption(
            id: "sculpted_glutes",
            title: "Sculpted Glutes",
            subtitle: nil,
            prompt: "Respectfully define and sculpt the glute muscles for a toned look",
            isFree: false
        ),
        EnhancementOption(
            id: "perky",
            title: "Perky",
            subtitle: nil,
            prompt: "Respectfully perk up the buttocks for a youthful, lifted appearance",
            isFree: true
        ),
        EnhancementOption(
            id: "voluminous",
            title: "Voluminous",
            subtitle: nil,
            prompt: "Enhance volume and roundness for fuller, more pronounced glutes",
            isFree: false
        )
    ]
    static let muscle: [EnhancementOption] = [
        EnhancementOption(
            id: "tone",
            title: "Upper Body",
            subtitle: nil,
            prompt: "Respectfully increase the muscle shape on neck and upper body",
            isFree: true
        ),
        EnhancementOption(
            id: "sculpt",
            title: "Arms & Forearms",
            subtitle: nil,
            prompt: "Respectfully enhance the muscle shape on the arms and forearms",
            isFree: false
        ),
        EnhancementOption(
            id: "bicep_peak",
            title: "Bicep Peak",
            subtitle: nil,
            prompt: "Respectfully accentuate the bicep peak for a more pronounced flex",
            isFree: false
        ),
        EnhancementOption(
            id: "tricep_tone",
            title: "Tricep Tone",
            subtitle: nil,
            prompt: "Respectfully slim and tone the triceps for sleek definition",
            isFree: true
        ),
        EnhancementOption(
            id: "vascular_forearms",
            title: "Vascular Forearms",
            subtitle: "Limited-time free",
            prompt: "Respectfully highlight forearm veins and muscle separation",
            isFree: true
        ),
        EnhancementOption(
            id: "forearm_definition",
            title: "Forearm Definition",
            subtitle: nil,
            prompt: "Respectfully define the forearm muscles for enhanced detail",
            isFree: false
        ),
        EnhancementOption(
            id: "arm_strength",
            title: "Strength Boost",
            subtitle: nil,
            prompt: "Respectfully add subtle bulk to arms",
            isFree: false
        )
    ]


    static let waist: [EnhancementOption] = [
        EnhancementOption(
            id: "slim",
            title: "Slim",
            subtitle: nil,
            prompt: "Slim and cinch the waist",
            isFree: true
        ),
        EnhancementOption(
            id: "curve",
            title: "Curve",
            subtitle: nil,
            prompt: "Enhance waist curves for definition",
            isFree: false
        )
    ]

    static let hair: [EnhancementOption] = [
        EnhancementOption(
            id: "volume",
            title: "Volume",
            subtitle: nil,
            prompt: "Add natural volume and body to hair",
            isFree: true
        ),
        EnhancementOption(
            id: "smooth",
            title: "Smooth",
            subtitle: nil,
            prompt: "Smooth hair and reduce frizz",
            isFree: false
        ),
        EnhancementOption(
            id: "silver_blonde",
            title: "Silver Blonde",
            subtitle: nil,
            prompt: "Transform hair to a chic silver blonde shade",
            isFree: true
        ),
        EnhancementOption(
            id: "bob_cut",
            title: "Bob Cut",
            subtitle: nil,
            prompt: "Give hair a modern bob cut",
            isFree: false
        ),
        EnhancementOption(
            id: "afro",
            title: "Afro",
            subtitle: "Limited-time free",
            prompt: "Define natural afro texture and volume",
            isFree: true
        ),
        EnhancementOption(
            id: "pixie_cut",
            title: "Pixie Cut",
            subtitle: nil,
            prompt: "Create a stylish pixie cut",
            isFree: false
        ),
        EnhancementOption(
            id: "ombre",
            title: "Ombre",
            subtitle: nil,
            prompt: "Add subtle ombre color blending",
            isFree: true
        ),
        EnhancementOption(
            id: "highlights",
            title: "Highlights",
            subtitle: nil,
            prompt: "Incorporate bright highlights throughout hair",
            isFree: false
        ),
        EnhancementOption(
            id: "balayage",
            title: "Balayage",
            subtitle: nil,
            prompt: "Apply a natural balayage painting technique",
            isFree: false
        ),
        EnhancementOption(
            id: "loose_curls",
            title: "Loose Curls",
            subtitle: nil,
            prompt: "Add loose, bouncy curls for movement",
            isFree: true
        ),
        EnhancementOption(
            id: "beach_waves",
            title: "Beach Waves",
            subtitle: "Limited-time free",
            prompt: "Create soft, effortless beach waves",
            isFree: true
        ),
        EnhancementOption(
            id: "sleek_straight",
            title: "Sleek Straight",
            subtitle: nil,
            prompt: "Smooth hair into a sleek, straight style",
            isFree: false
        )
    ]


    static let nose: [EnhancementOption] = [
        EnhancementOption(
            id: "refine",
            title: "Refine",
            subtitle: nil,
            prompt: "Refine the nose shape subtly",
            isFree: true
        ),
        EnhancementOption(
            id: "slim",
            title: "Slim",
            subtitle: nil,
            prompt: "Slim down the nose bridge",
            isFree: false
        )
    ]

    static let eyes: [EnhancementOption] = [
        EnhancementOption(
            id: "brighten",
            title: "Brighten",
            subtitle: nil,
            prompt: "Brighten eyes and reduce shadows",
            isFree: true
        ),
        EnhancementOption(
            id: "enlarge",
            title: "Enlarge",
            subtitle: nil,
            prompt: "Subtly enlarge the eyes",
            isFree: false
        )
    ]

    static let skin: [EnhancementOption] = [
        EnhancementOption(
            id: "smooth",
            title: "Smooth",
            subtitle: nil,
            prompt: "Smooth skin texture and even tone",
            isFree: true
        ),
        EnhancementOption(
            id: "glow",
            title: "Glow",
            subtitle: nil,
            prompt: "Add a healthy, radiant glow",
            isFree: false
        )
    ]

    static let face: [EnhancementOption] = [
        EnhancementOption(
            id: "contour",
            title: "Contour",
            subtitle: nil,
            prompt: "Add subtle contour to face",
            isFree: true
        ),
        EnhancementOption(
            id: "smooth",
            title: "Smooth",
            subtitle: nil,
            prompt: "Smooth overall facial features",
            isFree: false
        )
    ]

    static let lips: [EnhancementOption] = [
        EnhancementOption(
            id: "full",
            title: "Full",
            subtitle: nil,
            prompt: "Enhance lip fullness",
            isFree: true
        ),
        EnhancementOption(
            id: "color",
            title: "Color",
            subtitle: nil,
            prompt: "Add natural lip color",
            isFree: false
        )
    ]

    static let leg: [EnhancementOption] = [
        EnhancementOption(
            id: "slim",
            title: "Slim",
            subtitle: nil,
            prompt: "Slim and lengthen legs",
            isFree: true
        ),
        EnhancementOption(
            id: "tone",
            title: "Tone",
            subtitle: nil,
            prompt: "Tone leg muscles for definition",
            isFree: false
        )
    ]
    
    static let jewellery: [EnhancementOption] = [
        EnhancementOption(
                id: "gold_hoop_minimal",
                title: "Minimal Gold Hoops",
                subtitle: nil,
                prompt: "Add sleek, minimalistic gold hoop earrings",
                isFree: true
            ),
            EnhancementOption(
                id: "delicate_gold_chain",
                title: "Delicate Gold Chain",
                subtitle: nil,
                prompt: "Add a thin, delicate gold chain necklace",
                isFree: true
            ),
            EnhancementOption(
                id: "stackable_bands",
                title: "Stackable Bands",
                subtitle: nil,
                prompt: "Add a set of minimal stackable gold rings",
                isFree: false
            ),
            EnhancementOption(
                id: "geometric_studs",
                title: "Geometric Studs",
                subtitle: nil,
                prompt: "Add small geometric stud earrings in gold",
                isFree: true
            ),
            EnhancementOption(
                id: "thin_gold_bangle",
                title: "Thin Gold Bangle",
                subtitle: nil,
                prompt: "Add a slender, minimalistic gold bangle bracelet",
                isFree: false
            ),
            EnhancementOption(
                id: "gold_bar_necklace",
                title: "Gold Bar Necklace",
                subtitle: "Limited-time free",
                prompt: "Add a minimalist gold bar pendant necklace",
                isFree: true
            ),
            EnhancementOption(
                id: "link_chain_bracelet",
                title: "Link Chain Bracelet",
                subtitle: nil,
                prompt: "Add a bold gold link chain bracelet",
                isFree: false
            ),
            EnhancementOption(
                id: "pearls_and_gold",
                title: "Pearls & Gold",
                subtitle: nil,
                prompt: "Add a blend of pearls with gold accents",
                isFree: true
            ),
            EnhancementOption(
                id: "gold_cuff_minimal",
                title: "Minimal Gold Cuff",
                subtitle: nil,
                prompt: "Add a clean, minimalistic gold cuff bracelet",
                isFree: false
            ),
            EnhancementOption(
                id: "layered_gold_chains",
                title: "Layered Gold Chains",
                subtitle: nil,
                prompt: "Add multiple thin gold chain necklaces for layering",
                isFree: false
            ),
        EnhancementOption(
            id: "earrings",
            title: "Earrings",
            subtitle: nil,
            prompt: "Add stylish earrings",
            isFree: true
        ),
        EnhancementOption(
            id: "necklace",
            title: "Necklace",
            subtitle: nil,
            prompt: "Add a beautiful necklace",
            isFree: false
        ),
        EnhancementOption(
            id: "bracelet",
            title: "Bracelet",
            subtitle: nil,
            prompt: "Add a delicate bracelet around the wrist",
            isFree: true
        ),
        EnhancementOption(
            id: "ring",
            title: "Ring",
            subtitle: nil,
            prompt: "Add a sparkling ring to the fingers",
            isFree: false
        ),
        EnhancementOption(
            id: "anklet",
            title: "Anklet",
            subtitle: "Limited-time free",
            prompt: "Add a subtle anklet for a refined touch",
            isFree: true
        ),
        EnhancementOption(
            id: "chandelier_earrings",
            title: "Chandelier Earrings",
            subtitle: nil,
            prompt: "Add elegant chandelier-style earrings",
            isFree: false
        ),
        EnhancementOption(
            id: "hoop_earrings",
            title: "Hoop Earrings",
            subtitle: nil,
            prompt: "Add classic hoop earrings",
            isFree: true
        ),
        EnhancementOption(
            id: "cuff_bracelet",
            title: "Cuff Bracelet",
            subtitle: nil,
            prompt: "Add a bold cuff bracelet to the wrist",
            isFree: false
        ),
        EnhancementOption(
            id: "choker",
            title: "Choker",
            subtitle: nil,
            prompt: "Add a sleek choker around the neck",
            isFree: true
        ),
        EnhancementOption(
            id: "pendant",
            title: "Pendant",
            subtitle: nil,
            prompt: "Add a charming pendant on a fine chain",
            isFree: false
        ),
        EnhancementOption(
            id: "brooch",
            title: "Brooch",
            subtitle: nil,
            prompt: "Add a decorative brooch for a vintage flair",
            isFree: true
        ),
        EnhancementOption(
            id: "watch",
            title: "Watch",
            subtitle: nil,
            prompt: "Add a stylish wristwatch",
            isFree: false
        )
    ]

    // New Eyewear options
    static let eyewear: [EnhancementOption] = [
        EnhancementOption(
            id: "eyewear",
            title: "Eyewear",
            subtitle: nil,
            prompt: "Add stylish eyewear frames",
            isFree: true
        ),
        EnhancementOption(
            id: "sunglasses",
            title: "Sunglasses",
            subtitle: nil,
            prompt: "Add trendy sunglasses with reflective lenses",
            isFree: false
        ),
        EnhancementOption(
            id: "reading_glasses",
            title: "Reading Glasses",
            subtitle: "Limited-time free",
            prompt: "Add elegant reading glasses with thin frames",
            isFree: true
        ),
        EnhancementOption(
            id: "aviators",
            title: "Aviator Frames",
            subtitle: nil,
            prompt: "Add classic aviator sunglasses with metal frames",
            isFree: false
        ),
        EnhancementOption(
            id: "wayfarer",
            title: "Wayfarer",
            subtitle: nil,
            prompt: "Add stylish wayfarer-style glasses",
            isFree: true
        ),
        EnhancementOption(
            id: "round_frames",
            title: "Round Frames",
            subtitle: nil,
            prompt: "Add vintage round frame glasses",
            isFree: false
        ),
        EnhancementOption(
            id: "cat_eye",
            title: "Cat-eye",
            subtitle: nil,
            prompt: "Add chic cat-eye glasses for a retro look",
            isFree: true
        ),
        EnhancementOption(
            id: "translucent_frames",
            title: "Translucent Frames",
            subtitle: nil,
            prompt: "Add translucent frame glasses with modern vibe",
            isFree: false
        ),
        EnhancementOption(
            id: "sports_goggles",
            title: "Sports Goggles",
            subtitle: nil,
            prompt: "Add sporty wrap-around goggles",
            isFree: false
        ),
        EnhancementOption(
            id: "steampunk_goggles",
            title: "Steampunk Goggles",
            subtitle: "Limited-time free",
            prompt: "Add decorative steampunk-style goggles",
            isFree: true
        )
    ]
}
//
//  ImagePicker.swift
//  HairStyle
//
//  Created by Adam Roszyk on 3/19/25.
//
import SwiftUI
import PhotosUI


// UIKit-based image picker integrated into SwiftUI using UIViewControllerRepresentable
struct ImagePicker: UIViewControllerRepresentable {
    class Coordinator: NSObject, UINavigationControllerDelegate, UIImagePickerControllerDelegate {
        let parent: ImagePicker

        init(_ parent: ImagePicker) {
            self.parent = parent
        }
        func imagePickerController(_ picker: UIImagePickerController,
                                   didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey : Any]) {
            if let uiImage = info[.originalImage] as? UIImage {
                parent.image = uiImage
            }
            picker.dismiss(animated: true)
        }
    }
    
    @Binding var image: UIImage?
    
    func makeCoordinator() -> Coordinator {
        Coordinator(self)
    }
    func makeUIViewController(context: Context) -> UIImagePickerController {
        let picker = UIImagePickerController()
        picker.delegate = context.coordinator
        return picker
    }
    func updateUIViewController(_ uiViewController: UIImagePickerController, context: Context) {}
}
import SwiftUI
import Vision
import CoreML
import CoreImage
import UIKit
import os

// MARK: - CIImage Extension
extension CIImage {
    /// Returns a resized CIImage.
    func resized(to size: CGSize) -> CIImage {
        let scaleX = size.width / extent.width
        let scaleY = size.height / extent.height
        var outputImage = transformed(by: CGAffineTransform(scaleX: scaleX, y: scaleY))
        // Reset the origin to (0,0)
        outputImage = outputImage.transformed(by: CGAffineTransform(translationX: -outputImage.extent.origin.x,
                                                                    y: -outputImage.extent.origin.y))
        return outputImage
    }
}
extension CIContext {
    /// Renders a CIImage to a new CVPixelBuffer using the specified pixel format.
    func render(_ image: CIImage, pixelFormat: OSType) -> CVPixelBuffer? {
        // Ensure valid dimensions by rounding up and enforcing a minimum value
        let width = max(Int(ceil(image.extent.width)), 1)
        let height = max(Int(ceil(image.extent.height)), 1)
        let attrs: [CFString: Any] = [
            kCVPixelBufferCGImageCompatibilityKey: true,
            kCVPixelBufferCGBitmapContextCompatibilityKey: true,
            kCVPixelBufferIOSurfacePropertiesKey: [:]
        ]
        var pixelBuffer: CVPixelBuffer?
        let status = CVPixelBufferCreate(
            kCFAllocatorDefault,
            width,
            height,
            pixelFormat,
            attrs as CFDictionary,
            &pixelBuffer
        )
        guard status == kCVReturnSuccess, let buffer = pixelBuffer else {
            print("CVPixelBufferCreate failed with status: \(status)")
            return nil
        }
        self.render(image, to: buffer)
        return buffer
    }
}


// Extension to enhance image contrast
extension UIImage {
    func applyingContrast(_ contrast: CGFloat) -> UIImage? {
        guard let cgImage = self.cgImage else { return nil }
        
        let context = CIContext()
        let ciImage = CIImage(cgImage: cgImage)
        
        let filter = CIFilter(name: "CIColorControls")
        filter?.setValue(ciImage, forKey: kCIInputImageKey)
        filter?.setValue(contrast, forKey: kCIInputContrastKey)
        filter?.setValue(0, forKey: kCIInputBrightnessKey)
        filter?.setValue(1.0, forKey: kCIInputSaturationKey)
        
        guard let outputImage = filter?.outputImage,
              let filteredCGImage = context.createCGImage(outputImage, from: outputImage.extent) else {
            return nil
        }
        
        return UIImage(cgImage: filteredCGImage, scale: self.scale, orientation: self.imageOrientation)
    }
}

extension UIImage {
    func resizedPixelBuffer(width: Int, height: Int) -> CVPixelBuffer? {
        var pxBuffer: CVPixelBuffer?
        let attrs = [
            kCVPixelBufferCGImageCompatibilityKey: true,
            kCVPixelBufferCGBitmapContextCompatibilityKey: true
        ] as CFDictionary
        
        guard CVPixelBufferCreate(kCFAllocatorDefault,
                                  width,
                                  height,
                                  kCVPixelFormatType_32ARGB,
                                  attrs,
                                  &pxBuffer) == kCVReturnSuccess,
              let buffer = pxBuffer,
              let cgImage = self.cgImage else {
            return nil
        }
        CVPixelBufferLockBaseAddress(buffer, [])
        defer { CVPixelBufferUnlockBaseAddress(buffer, []) }
        
        let context = CGContext(data: CVPixelBufferGetBaseAddress(buffer),
                                width: width,
                                height: height,
                                bitsPerComponent: 8,
                                bytesPerRow: CVPixelBufferGetBytesPerRow(buffer),
                                space: CGColorSpaceCreateDeviceRGB(),
                                bitmapInfo: CGImageAlphaInfo.noneSkipFirst.rawValue)
        guard let ctx = context else { return nil }
        
        let rect = CGRect(x: 0, y: 0, width: width, height: height)
        ctx.draw(cgImage, in: rect)
        
        return buffer
    }
}
//
//  HairStyleApp.swift
//  HairStyle
//
//  Created by Adam Roszyk on 3/19/25.
import SwiftUI

@main
struct HairStyleApp: App {
    @AppStorage("hasCompletedOnboarding") var hasCompletedOnboarding: Bool = true
    
    /// Create a single instance of SubscriptionManager
    @StateObject var subscriptionManager = SubscriptionManager()
    
    var body: some Scene {
        WindowGroup {
            if hasCompletedOnboarding {
                CatalogView()
                    .environmentObject(subscriptionManager)
            } else {
                OnboardingView()
                    .environmentObject(subscriptionManager)
            }
        }
    }
}
//
//  SettingsView.swift
//  HairStyle
//
//  Created by adam on 27/03/2025.
//

import SwiftUI
import PhotosUI
import Vision


struct SettingsView: View {
    @ObservedObject var viewModel: ImageEditingViewModel
    @Binding var sliderPosition: CGFloat
    
    var body: some View {
        List {
            Section(header: Text("Sharing Settings")) {
                Toggle(isOn: $viewModel.isPublicSharing) {
                    Text(viewModel.isPublicSharing ? "Share Generations Publicly: On" : "Share Generations Publicly: Off")
                }
            }
            
            Section(header: Text("Before/After Slider")) {
                Slider(value: $sliderPosition, in: 0...1)
                Text("Slider Position: \(sliderPosition, specifier: "%.2f")")
                    .font(.caption)
                    .foregroundColor(.gray)
            }
        }
        .navigationTitle("Settings")
        .listStyle(InsetGroupedListStyle())
    }
}
import SwiftUI

/// A zoomable & pannable container that shows either
/// • a comparison slider between an original & edited image
/// • a single edited image
/// • or an empty-state prompt when no image is loaded.
///
/// **Key fixes (v3):**
/// • Added a tiny `CGSize` `+` helper so the file *actually* compiles – Xcode
///   doesn’t ship an overload for adding two `CGSize`s. Nothing else about
///   the gesture logic changes.
///
/// (Icon-layout & animation-suppression tweaks from v2 remain.)
struct PhotoWithRefreshOverlay: View {
    // MARK: – Inputs
    let originalImage: UIImage?
    let editedImage: UIImage?
    let depthMapImage: UIImage?

    @Binding var sliderPosition: CGFloat
    @Binding var showSlider: Bool

    let onReplaceTap: () -> Void
    let onAddTap: () -> Void
    let onSaveTap: () -> Void

    // MARK: – Persistent transform state
    @State private var accumulatedScale: CGFloat = 1.0
    @State private var accumulatedOffset: CGSize = .zero

    // MARK: – Transient gesture state (cleared every frame)
    @GestureState private var gestureScale: CGFloat = 1.0
    @GestureState private var gestureOffset: CGSize = .zero

    // MARK: – Constants
    @ScaledMetric private var iconSide: CGFloat = 24
    private let minScale: CGFloat = 0.5
    private let maxScale: CGFloat = 5

    var body: some View {
        ZStack {
            contentView
                .scaleEffect(currentScale)
                .offset(currentOffset)
                .animation(.none, value: currentScale)
                .animation(.none, value: currentOffset)
                .gesture(transformGesture)
                .transaction { $0.disablesAnimations = true }

          /*  if editedImage != nil {
                actionButtons
                    .padding([.top, .horizontal], 12)
                    .frame(maxWidth: .infinity, maxHeight: .infinity, alignment: .top)
                    .zIndex(1)
            }*/
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
    }

    // MARK: – Computed helpers
    private var currentScale: CGFloat { accumulatedScale * gestureScale }

    private var currentOffset: CGSize {
        CGSize(width: accumulatedOffset.width + gestureOffset.width,
               height: accumulatedOffset.height + gestureOffset.height)
    }

    // MARK: – Sub-views
    @ViewBuilder
    private var contentView: some View {
        if let orig = originalImage, let edit = editedImage {
            AspectLimitedComparisonView(
                originalImage: orig,
                modifiedImage: edit,
                depthMapImage: depthMapImage,
                sliderPosition: $sliderPosition,
                showSlider: $showSlider
            )
            .id(depthMapImage)
        } else if let edit = editedImage {
            AspectLimitedSingleImageView(image: edit, showSlider: $showSlider)
        } else {
            EmptyStateView(onAddTap: onAddTap)
        }
    }

    private var actionButtons: some View {
        HStack {
            Button(action: onReplaceTap) {
                Image(systemName: "arrow.triangle.2.circlepath")
                    .modifier(ActionIcon(side: iconSide))
            }
            Spacer()
            Button(action: saveTapped) {
                Image(systemName: "square.and.arrow.down")
                    .modifier(ActionIcon(side: iconSide))
            }
        }
    }

    private func saveTapped() {
        if let img = editedImage {
            UIImageWriteToSavedPhotosAlbum(img, nil, nil, nil)
        }
        onSaveTap()
    }

    // MARK: – Gestures
    private var transformGesture: some Gesture {
        SimultaneousGesture(
            DragGesture(minimumDistance: 0)
                .updating($gestureOffset) { value, state, _ in
                    state = value.translation
                }
                .onEnded { value in
                    accumulatedOffset = clamped(offset: accumulatedOffset + value.translation)
                },
            MagnificationGesture()
                .updating($gestureScale) { value, state, _ in
                    state = value
                }
                .onEnded { value in
                    let newScale = accumulatedScale * value
                    accumulatedScale = min(max(newScale, minScale), maxScale)
                }
        )
    }

    private func clamped(offset: CGSize) -> CGSize {
        CGSize(width: max(min(offset.width, 2_000), -2_000),
               height: max(min(offset.height, 2_000), -2_000))
    }
}

// MARK: – `CGSize` arithmetic helper
private extension CGSize {
    static func + (lhs: CGSize, rhs: CGSize) -> CGSize {
        CGSize(width: lhs.width + rhs.width, height: lhs.height + rhs.height)
    }
}

// MARK: – Style helpers & stubs
private struct ActionIcon: ViewModifier {
    let side: CGFloat
    func body(content: Content) -> some View {
        content
            .font(.system(size: side * 0.45, weight: .medium))
            .foregroundColor(.white)
            .frame(width: side, height: side)
            .background(Color.black.opacity(0.6))
            .clipShape(Circle())
    }
}

struct EmptyStateView: View {
    let onAddTap: () -> Void
    var body: some View {
        Rectangle()
            .fill(Color.gray.opacity(0.3))
            .overlay(
                VStack {
                    Spacer()
                    Button(action: onAddTap) {
                        VStack(spacing: 12) {
                            Image(systemName: "photo.fill.on.rectangle.fill")
                                .font(.system(size: 40))
                            Text("Add Image +")
                                .font(.headline)
                        }
                        .foregroundColor(.black)
                        .padding()
                        .background(Color.white)
                        .cornerRadius(12)
                        .shadow(radius: 10)
                    }
                    Spacer()
                }
                .frame(height: 600)
            )
    }
}
//
//  OutlineTextModifier.swift
//  HairStyle
//
//  Created by adam on 24/03/2025.
//

import SwiftUI
import PhotosUI
import Vision

struct OutlineTextModifier: ViewModifier {
    func body(content: Content) -> some View {
        ZStack {
            content
                .foregroundColor(.black.opacity(0.3))
                .offset(x: -1, y: -1)
            content
                .foregroundColor(.black.opacity(0.3))
                .offset(x: 1, y: -1)
            content
                .foregroundColor(.black.opacity(0.3))
                .offset(x: -1, y: 1)
            content
                .foregroundColor(.black.opacity(0.3))
                .offset(x: 1, y: 1)
            content
        }
    }
}

struct IdentityModifier: ViewModifier {
    func body(content: Content) -> some View {
        content
    }
}
//
//  AspectLimitedSingleImageView.swift
//  HairStyle
//
//  Created by Adam Roszyk on 3/22/25.
//
import SwiftUI
import PhotosUI
import Vision

struct AspectLimitedSingleImageView: View {
    let image: UIImage
    @Binding var showSlider: Bool
    
    var body: some View {
        Image(uiImage: image)
            .resizable()
            .scaledToFit()
            .onTapGesture {
                withAnimation {
                    showSlider = false
                }
            }
    }
}
import SwiftUI
import StoreKit

struct BottomMenuView: View {
    @ObservedObject var viewModel: ImageEditingViewModel
    @Binding var inputImage: UIImage?
    @Binding var sliderPosition: CGFloat
    
    // drop the `private` here so we can initialize it
    @State var selectedCategory: String
    @State private var selectedItemId: UUID?
    @State private var generationCount: Int = 0

    /// Now put your init _inside_ the struct
    init(
      viewModel: ImageEditingViewModel,
      inputImage: Binding<UIImage?>,
      sliderPosition: Binding<CGFloat>,
      initialCategory: String = "Hairstyle"  // default so old calls still compile
    ) {
      self.viewModel = viewModel
      self._inputImage = inputImage
      self._sliderPosition = sliderPosition
      self._selectedCategory = State(initialValue: initialCategory)
    }
    
    var body: some View {
        VStack(spacing: 0) {
            categoriesSection
                .frame(height: 50)
                .padding(.horizontal)
            
            itemsSection
                .frame(height: 110)
        }
        .background(Color.clear)
        
        // Show a premium-limit alert if the user hits the generation limit
        .alert("Premium Limit", isPresented: $viewModel.showPremiumAlert) {
            Button("OK", role: .cancel) {}
        } message: {
            Text(viewModel.errorMessage)
        }
    }
    
    // MARK: - Categories Section
    private var categoriesSection: some View {
        ScrollView(.horizontal, showsIndicators: false) {
            HStack(spacing: 20) {
                ForEach(BeautyDataPrompts.categories, id: \.self) { category in
                    Text(category)
                        .fontWeight(selectedCategory == category ? .bold : .regular)
                        .padding(.vertical, 8)
                        .padding(.horizontal, 16)
                        .background(selectedCategory == category ? Color.white.opacity(0.1) : Color.clear)
                        .foregroundColor(selectedCategory == category ? .white : .primary)
                        .shadow(color: selectedCategory == category ? Color.black.opacity(0.5) : Color.clear, radius: 0, x: 1, y: 1)
                        .shadow(color: selectedCategory == category ? Color.black.opacity(0.5) : Color.clear, radius: 0, x: -1, y: 1)
                        .shadow(color: selectedCategory == category ? Color.black.opacity(0.5) : Color.clear, radius: 0, x: 1, y: -1)
                        .shadow(color: selectedCategory == category ? Color.black.opacity(0.5) : Color.clear, radius: 0, x: -1, y: -1)
                        .cornerRadius(8)
                        .cornerRadius(8)
                        .onTapGesture {
                            withAnimation {
                                selectedCategory = category
                            }
                        }
                }
            }
        }
    }
    
    // MARK: - Items Section
    private var itemsSection: some View {
        ScrollViewReader { proxy in
            ScrollView(.horizontal, showsIndicators: false) {
                LazyHStack(alignment: .center, spacing: 16) {
                    // Loop through the items for the selected category
                    ForEach(BeautyDataPrompts.items[selectedCategory] ?? []) { item in
                        itemButton(for: item)
                    }
                }
                .padding(.horizontal)
            }
            .onChange(of: selectedCategory) { _ in
                scrollToFirst(proxy: proxy)
            }
            .onAppear {
                scrollToFirst(proxy: proxy)
            }
        }
    }
    
    // MARK: - Item Button
    private func itemButton(for item: HairItem) -> some View {
        VStack {
            // You can place an Image or systemName icon for the item here
            ZStack {
                if let imageName = item.image {
                    Image(imageName)
                        .resizable()
                        .scaledToFit()
                        .frame(width: 60, height: 60)
                } else {
                    Image(systemName: "photo.fill")
                        .resizable()
                        .scaledToFit()
                        .frame(width: 40, height: 40)
                        .foregroundColor(.gray)
                }
                
                if viewModel.isLoading && selectedItemId == item.id {
                    ProgressView()
                        .progressViewStyle(CircularProgressViewStyle(tint: .white))
                        .frame(width: 60, height: 60)
                        .background(Color.black.opacity(0.3))
                }
            }
            
            Text(item.name)
                .font(.caption)
                .lineLimit(1)
        }
        .frame(width: 80)
        .padding(.vertical, 8)
        .padding(.horizontal, 12)
        .background(selectedItemId == item.id ? Color.white.opacity(0.01) : Color.white)
        .cornerRadius(8)
        .onTapGesture {
            guard !viewModel.isLoading else { return }
            selectedItemId = item.id
            viewModel.prompt = item.prompt
            
            // Increment generation count
            generationCount += 0// Disabled for now, will add the payments later.
            
            // Check if user reached the limit (3 in this example)
            if generationCount >= 3 {
                // Show premium-limit message
                viewModel.errorMessage = "Premium limit reached. Upgrade to premium for unlimited images."
                viewModel.showPremiumAlert = true
                
                // Optionally request a StoreKit review
                if let scene = UIApplication.shared.connectedScenes.first as? UIWindowScene {
                    SKStoreReviewController.requestReview(in: scene)
                }
                
                // Because we've reached the limit, we skip calling editImage()
                // Instead we display the alert. You can handle logic as you see fit.
                
            } else {
                // If user is still within the limit, proceed with the image edit
                viewModel.editImage()
            }
        }
        .disabled(viewModel.isLoading)
        .opacity(viewModel.isLoading && selectedItemId != item.id ? 0.5 : 1.0)
    }
    
    // MARK: - Helper: Scroll to First Item
    private func scrollToFirst(proxy: ScrollViewProxy) {
        if let firstId = BeautyDataPrompts.items[selectedCategory]?.first?.id {
            withAnimation {
                proxy.scrollTo(firstId, anchor: .leading)
            }
        }
    }
}
import SwiftUI
import Vision

// MARK: - NormalizedContour
struct NormalizedContour {
    let normalizedPoints: [CGPoint]
}

// Because `MeshGradient` is available in iOS 18.0+,
// we mark this property accordingly.
@available(iOS 18.0, *)
private var meshGradientStrokeStyle: MeshGradient {
    MeshGradient(
        width: 3,
        height: 3,
        points: [
            [0.0, 0.0], [0.5, 0.0], [1.0, 0.0],
            [0.0, 0.5], [0.8, 0.2], [1.0, 0.5],
            [0.0, 1.0], [0.5, 1.0], [1.0, 1.0]
        ],
        colors: [
            .black, .black, .black,
            .blue,  .blue,  .blue,
            .green, .green, .green
        ]
    )
}

func detectNormalizedContours(in image: UIImage) -> [NormalizedContour]? {
    guard let cgImage = image.cgImage else { return nil }

    let request = VNDetectContoursRequest()
    
    // If you're targeting iOS 15 or higher:
    if #available(iOS 15.0, *) {
        // Increase contrastAdjustment to detect more subtle edges
        request.contrastAdjustment = 0.70  // Try 1.2, 1.5, 2.0, etc.
        
        // If the image background is lighter than the foreground
        request.detectDarkOnLight = false
        
        // Limit how large the image is scaled before detection
        request.maximumImageDimension = 512
    }
    
    
    let handler = VNImageRequestHandler(cgImage: cgImage, options: [:])
    do {
        try handler.perform([request])
        guard let observation = request.results?.first as? VNContoursObservation else { return nil }
        
        var contours: [NormalizedContour] = []
        
        for i in 0..<observation.topLevelContourCount {
            guard let contour = observation.topLevelContours[safe: i] else { continue }
            // Flip y-coordinates to match SwiftUI's top-left origin
            let points = contour.normalizedPoints.map {
                CGPoint(x: CGFloat($0.x), y: CGFloat(1 - $0.y))
            }
            contours.append(NormalizedContour(normalizedPoints: points))
        }
        
        return contours
    } catch {
        print("Error detecting contours: \(error)")
        return nil
    }
}

struct ContoursOverlay: View {
    let contours: [NormalizedContour]
    let dashPhase: CGFloat
    
    var body: some View {
        if #available(iOS 18.0, *) {
            // iOS 17+ uses MeshGradient as the stroke fill
            ContoursShape(contours: contours)
                .stroke(
                   
                    MeshGradient(
                        width: 3,
                        height: 3,
                        points: [
                            // Same 3x3 grid of control points
                            [0.0, 0.0], [0.5, 0.0], [1.0, 0.0],
                            [0.0, 0.5], [0.8, 0.2], [1.0, 0.5],
                            [0.0, 1.0], [0.5, 1.0], [1.0, 1.0]
                        ],
                        colors: [
                            // Top row
                            Color(red: 1.0, green: 0.28, blue: 0.45), // pink
                            Color(red: 1.0, green: 0.28, blue: 0.45),
                            Color(red: 1.0, green: 0.55, blue: 0.20), // orange

                            // Middle row
                            Color(red: 1.0, green: 0.28, blue: 0.45),
                            Color(red: 1.0, green: 0.55, blue: 0.20),
                            Color(red: 1.0, green: 0.55, blue: 0.20),

                            // Bottom row
                            Color(red: 1.0, green: 0.28, blue: 0.45),
                            Color(red: 1.0, green: 0.55, blue: 0.20),
                            Color(red: 1.0, green: 0.72, blue: 0.10)  // yellowish
                        ]
                    ),
                    style: StrokeStyle(
                        lineWidth: 4,
                        lineCap: .round,
                        dash: [20, 40],
                        dashPhase: dashPhase
                    )
                )
        } else {
            // Fallback for iOS < 17
            ContoursShape(contours: contours)
                .stroke(
                    Color.red,
                    style: StrokeStyle(
                        lineWidth: 3,
                        lineCap: .round,
                        dash: [10, 20],
                        dashPhase: dashPhase
                    )
                )
        }
    }
}


// MARK: - ContoursShape
struct ContoursShape: Shape {
    let contours: [NormalizedContour]
    
    func path(in rect: CGRect) -> Path {
        var combined = Path()
        for contour in contours {
            guard let first = contour.normalizedPoints.first else { continue }
            combined.move(to: CGPoint(x: first.x * rect.width, y: first.y * rect.height))
            
            for point in contour.normalizedPoints.dropFirst() {
                combined.addLine(to: CGPoint(x: point.x * rect.width, y: point.y * rect.height))
            }
            combined.closeSubpath()
        }
        return combined
    }
}

// MARK: - Safe Collection Subscript
extension Collection {
    subscript(safe index: Index) -> Element? {
        indices.contains(index) ? self[index] : nil
    }
}

// MARK: - resizeImage(image:targetSize:)
func resizeImage(image: UIImage, targetSize: CGSize) -> UIImage {
    let renderer = UIGraphicsImageRenderer(size: targetSize)
    return renderer.image { _ in
        image.draw(in: CGRect(origin: .zero, size: targetSize))
    }
}


// MARK: - AspectLimitedComparisonView
struct AspectLimitedComparisonView: View {
    let originalImage: UIImage?
    let modifiedImage: UIImage?
    let depthMapImage: UIImage?
    
    @Binding var sliderPosition: CGFloat
    @Binding var showSlider: Bool
    
    @State private var normalizedContours: [NormalizedContour] = []
    @State private var dashPhase: CGFloat = 0.0
    
    // Use MeshGradient stroke if iOS >= 18, else fallback to a solid color.
  
    let CustomStrokeFill: any ShapeStyle = {
        if #available(iOS 18.0, *) {
            // Return the MeshGradient (which *is* a ShapeStyle in iOS 17)
            return meshGradientStrokeStyle
        } else {
            // Fallback for older iOS
            return Color.red
        }
    }()
    var body: some View {
        GeometryReader { geometry in
            let displaySize = geometry.size
            
            ZStack {
                // 1) Original image in the background
                Image(uiImage: originalImage!)
                    .resizable()
                    .scaledToFit()
                    .frame(width: displaySize.width, height: displaySize.height)
                
                if modifiedImage == originalImage {
                    // If 'modifiedImage' is the same as 'originalImage', show the depth overlay + contours
                    if let depth = depthMapImage {
                        // Resize depth to the same displayed size
                        let resizedDepth = resizeImage(image: depth, targetSize: displaySize)
                        
                        
                        Image(uiImage: resizedDepth)
                            .resizable()
                            .scaledToFit()
                            .frame(width: displaySize.width, height: displaySize.height)
                            .opacity(0.00)
                            .overlay(
                                ContoursOverlay(
                                    contours: normalizedContours,
                                    dashPhase: dashPhase
                                )
                            )
                            .onAppear {
                                // Detect contours in the resized depth image
                                if let contours = detectNormalizedContours(in: resizedDepth) {
                                    self.normalizedContours = contours
                                }
                                // Animate dash phase
                                withAnimation(
                                    Animation.linear(duration: 999).repeatForever(autoreverses: false)
                                ) {
                                    self.dashPhase -= 10000
                                }
                            }
                    }
                } else {
                    // Otherwise, just show the modified image
                    if let modified = modifiedImage {
                        Image(uiImage: modified)
                            .resizable()
                            .scaledToFit()
                            .frame(width: displaySize.width, height: displaySize.height)
                    }
                }
            }
            .onTapGesture {
                withAnimation {
                    showSlider.toggle()
                }
            }
        }
        // Force the overall aspect ratio to match the original
        .aspectRatio(originalImage!.size, contentMode: .fit)
    }
}
import SwiftUI
import Photos
import StoreKit

struct OnboardingView: View {
    @AppStorage("hasCompletedOnboarding") var hasCompletedOnboarding: Bool = false
    @AppStorage("isPremium") var isPremium: Bool = false
    
    @State private var currentPage = 0
    private let totalPages = 6

    var body: some View {
        TabView(selection: $currentPage) {
            // Page 1: Benefit 1
            OnboardingPageView(imageName: "star.fill",
                               title: "Amazing Features",
                               description: "Discover advanced AI editing to bring out your best self.",
                               onContinue: { currentPage = 1 })
                .tag(0)
            
            // Page 2: Benefit 2
            OnboardingPageView(imageName: "sparkles",
                               title: "Effortless Beauty",
                               description: "Instantly enhance your selfies with just a tap.",
                               onContinue: { currentPage = 2 })
                .tag(1)
            
            // Page 3: Benefit 3
            OnboardingPageView(imageName: "heart.fill",
                               title: "Share Your Style",
                               description: "Create stunning images and share your unique look with friends.",
                               onContinue: { currentPage = 3 })
                .tag(2)
            
            // Page 4: Photo Library Permission
            PhotoLibraryPermissionPageView(onContinue: { currentPage = 4 })
                .tag(3)
            
            // Page 5: Review Prompt
            ReviewPromptPageView(onContinue: { currentPage = 5 })
                .tag(4)
            
            // Page 6: Paywall
            PaywallPageView(isPremium: $isPremium, onComplete: completeOnboarding)
                .tag(5)
        }
        .tabViewStyle(PageTabViewStyle(indexDisplayMode: .never))
    }
    
    private func completeOnboarding() {
        hasCompletedOnboarding = true
    }
}

struct OnboardingPageView: View {
    let imageName: String
    let title: String
    let description: String
    let onContinue: () -> Void
    
    var body: some View {
        VStack(spacing: 20) {
            Spacer()
            Image(systemName: imageName)
                .resizable()
                .scaledToFit()
                .frame(width: 120, height: 120)
                .foregroundColor(.blue)
            Text(title)
                .font(.largeTitle)
                .fontWeight(.bold)
            Text(description)
                .font(.title3)
                .multilineTextAlignment(.center)
                .padding(.horizontal)
            Spacer()
            Button(action: onContinue) {
                Text("Continue")
                    .foregroundColor(.white)
                    .padding()
                    .frame(maxWidth: .infinity)
                    .background(Color.blue)
                    .cornerRadius(8)
            }
            .padding(.horizontal)
        }
    }
}

struct PhotoLibraryPermissionPageView: View {
    @State private var permissionGranted = false
    let onContinue: () -> Void

    var body: some View {
        VStack(spacing: 20) {
            Spacer()
            Image(systemName: "photo.on.rectangle.angled")
                .resizable()
                .scaledToFit()
                .frame(width: 120, height: 120)
                .foregroundColor(permissionGranted ? .green : .orange)
            Text("Photo Library Access")
                .font(.largeTitle)
                .fontWeight(.bold)
            Text("We need permission to save your edited photos to your library.")
                .font(.title3)
                .multilineTextAlignment(.center)
                .padding(.horizontal)
            Button(action: {
                PHPhotoLibrary.requestAuthorization(for: .addOnly) { status in
                    DispatchQueue.main.async {
                        permissionGranted = (status == .authorized || status == .limited)
                    }
                }
            }) {
                Text(permissionGranted ? "Permission Granted" : "Grant Photo Library Access")
                    .foregroundColor(.white)
                    .padding()
                    .frame(maxWidth: .infinity)
                    .background(permissionGranted ? Color.green : Color.blue)
                    .cornerRadius(8)
            }
            .padding(.horizontal)
            Spacer()
            Button(action: onContinue) {
                Text("Continue")
                    .foregroundColor(.white)
                    .padding()
                    .frame(maxWidth: .infinity)
                    .background(Color.blue)
                    .cornerRadius(8)
            }
            .padding(.horizontal)
        }
    }
}

struct ReviewPromptPageView: View {
    let onContinue: () -> Void

    var body: some View {
        VStack(spacing: 20) {
            Spacer()
            Image(systemName: "hand.thumbsup.fill")
                .resizable()
                .scaledToFit()
                .frame(width: 120, height: 120)
                .foregroundColor(.purple)
            Text("Enjoying the App?")
                .font(.largeTitle)
                .fontWeight(.bold)
            Text("We’d love to hear your feedback. Please take a moment to rate us!")
                .font(.title3)
                .multilineTextAlignment(.center)
                .padding(.horizontal)
            Button(action: {
                if let scene = UIApplication.shared.connectedScenes.first as? UIWindowScene {
                    SKStoreReviewController.requestReview(in: scene)
                }
            }) {
                Text("Rate Now")
                    .foregroundColor(.white)
                    .padding()
                    .frame(maxWidth: .infinity)
                    .background(Color.purple)
                    .cornerRadius(8)
            }
            .padding(.horizontal)
            Spacer()
            Button(action: onContinue) {
                Text("Continue")
                    .foregroundColor(.white)
                    .padding()
                    .frame(maxWidth: .infinity)
                    .background(Color.purple)
                    .cornerRadius(8)
            }
            .padding(.horizontal)
        }
    }
}
import SwiftUI

struct ContentView: View {
    @StateObject private var viewModel = ImageEditingViewModel()
    @State private var inputImage: UIImage?
    @State private var showingImagePicker = false
    @State private var sliderPosition: CGFloat = 0.5
    @State private var showSlider: Bool = false
    @State private var showSaveSuccessAlert = false

    var body: some View {
        ZStack {
            // MARK: Background covers full screen
            backgroundView
                .ignoresSafeArea()

            // MARK: Photo (maintain aspect ratio, no distortion)
            PhotoWithRefreshOverlay(
                originalImage: inputImage,
                editedImage: viewModel.editedImage,
                depthMapImage: viewModel.depthMapImage,
                sliderPosition: $sliderPosition,
                showSlider: $showSlider,
                onReplaceTap: pickImage,
                onAddTap: pickImage,
                onSaveTap: saveImage
            )
            .frame(maxWidth: .infinity, maxHeight: .infinity)

            // MARK: Bottom Controls Panel
            VStack {
                Spacer()
                BottomMenuView(
                    viewModel: viewModel,
                    inputImage: $inputImage,
                    sliderPosition: $sliderPosition
                )
                .padding()
                .background(.ultraThinMaterial)
                .cornerRadius(16)
                .padding(.horizontal, 16)
                .padding(.bottom, 8)
            }
        }
        // allow background to extend under status bar
        .edgesIgnoringSafeArea(.top)
        .sheet(isPresented: $showingImagePicker, onDismiss: loadImage) {
            ImagePicker(image: $inputImage)
        }
        .alert("Saved", isPresented: $showSaveSuccessAlert) {
            Button("OK", role: .cancel) {}
        } message: {
            Text("Image saved successfully to your Photos.")
        }
        .onAppear {
            Task {
                do { try await viewModel.loadModel() }
                catch { viewModel.errorMessage = "Failed to load model: \(error.localizedDescription)" }
            }
        }
    }
}

private extension ContentView {
    var backgroundView: some View {
        Group {
            if let image = inputImage {
                Image(uiImage: image)
                    .resizable()
                    .scaledToFill()
                    .blur(radius: 120)
                    .overlay(Color.black.opacity(0.4))
            } else {
                Color.black.opacity(0.6)
            }
        }
    }

    func pickImage() {
        showingImagePicker = true
    }

    func loadImage() {
        guard let selected = inputImage else { return }
        viewModel.editedImage = selected
        viewModel.errorMessage = ""
        Task { await viewModel.generateDepthMap(for: selected) }
    }

    func saveImage() {
        guard let imageToSave = viewModel.editedImage else { return }
        UIImageWriteToSavedPhotosAlbum(imageToSave, nil, nil, nil)
        showSaveSuccessAlert = true
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}
//
//  PaywallPageView.swift
//  HairStyle
//
//  Created by adam on 25/03/2025.
//


import SwiftUI
import StoreKit

struct PaywallPageView: View {
    /// We get the subscription manager from the environment
    @EnvironmentObject var subscriptionManager: SubscriptionManager
    
    /// This is your old @AppStorage property that indicates premium status
    @Binding var isPremium: Bool
    
    /// Called when user finishes this screen (either purchase or “Not Now”)
    let onComplete: () -> Void
    
    var body: some View {
        VStack(spacing: 20) {
            Spacer()
            Text("Upgrade to Premium")
                .font(.largeTitle)
                .fontWeight(.bold)
            Text("Unlock unlimited image edits. Choose your plan below:")
                .font(.title3)
                .multilineTextAlignment(.center)
                .padding(.horizontal)
            
            if subscriptionManager.subscriptions.isEmpty {
                // If the products haven't loaded yet, show a spinner
                ProgressView("Loading subscriptions...")
                    .padding()
            } else {
                // Show each subscription product
                ForEach(subscriptionManager.subscriptions) { product in
                    Button {
                        Task {
                            do {
                                // Attempt to purchase
                                let transaction = try await subscriptionManager.purchase(product)
                                if transaction != nil {
                                    // Purchase successful
                                    isPremium = true
                                    onComplete()
                                }
                            } catch {
                                print("Purchase failed: \(error)")
                            }
                        }
                    } label: {
                        // Display the product’s name and price from StoreKit
                        Text("\(product.displayName) – \(product.displayPrice)")
                            .foregroundColor(.white)
                            .padding()
                            .frame(maxWidth: .infinity)
                            .background(Color.blue)
                            .cornerRadius(8)
                    }
                    .padding(.horizontal)
                }
            }
            
            Button(action: {
                // "Not Now" – continue as freemium (limited to 3 generations)
                onComplete()
            }) {
                Text("Not Now")
                    .underline()
                    .foregroundColor(.gray)
            }
            Button(action: {
                if let url = URL(string: "https://example.com/terms") {
                    UIApplication.shared.open(url)
                }
            }) {
                Text("Terms of Service")
                    .underline()
                    .foregroundColor(.blue)
            }
            Spacer()
        }
        .padding(.horizontal)
    }
}
